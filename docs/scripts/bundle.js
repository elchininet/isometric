(()=>{var __webpack_modules__={741:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// NAMESPACE OBJECT: ./src/index.ts\nvar src_namespaceObject = {};\n__webpack_require__.r(src_namespaceObject);\n__webpack_require__.d(src_namespaceObject, {\n  Axis: () => (Axis),\n  IsometricCanvas: () => (IsometricCanvas),\n  IsometricCircle: () => (IsometricCircle),\n  IsometricGroup: () => (IsometricGroup),\n  IsometricPath: () => (IsometricPath),\n  IsometricPentagram: () => (IsometricPentagram),\n  IsometricRectangle: () => (IsometricRectangle),\n  IsometricStarPolygon: () => (IsometricStarPolygon),\n  IsometricText: () => (IsometricText),\n  LineCap: () => (LineCap),\n  LineJoin: () => (LineJoin),\n  PlaneView: () => (PlaneView)\n});\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/google-code-prettify@1.0.5/node_modules/google-code-prettify/bin/run_prettify.min.js\nvar run_prettify_min = __webpack_require__(966);\n;// ./src/@constants/index.ts\nvar SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\nvar SVG_ELEMENTS;\n(function (SVG_ELEMENTS) {\n    SVG_ELEMENTS["svg"] = "svg";\n    SVG_ELEMENTS["group"] = "g";\n    SVG_ELEMENTS["path"] = "path";\n    SVG_ELEMENTS["rect"] = "rect";\n    SVG_ELEMENTS["text"] = "text";\n    SVG_ELEMENTS["tspan"] = "tspan";\n    SVG_ELEMENTS["pattern"] = "pattern";\n    SVG_ELEMENTS["image"] = "image";\n    SVG_ELEMENTS["animate"] = "animate";\n    SVG_ELEMENTS["animateTransform"] = "animateTransform";\n})(SVG_ELEMENTS || (SVG_ELEMENTS = {}));\nvar SVG_PROPERTIES;\n(function (SVG_PROPERTIES) {\n    SVG_PROPERTIES["viewBox"] = "viewBox";\n})(SVG_PROPERTIES || (SVG_PROPERTIES = {}));\nvar DECIMALS = 6;\nvar SQRT3 = +(Math.sqrt(3).toFixed(DECIMALS));\nvar HSQRT3 = +((Math.sqrt(3) / 2).toFixed(DECIMALS));\nvar DEFAULT_WIDTH = 640;\nvar DEFAULT_HEIGHT = 480;\nvar N = \'(-?\\\\d+(?:\\\\.\\\\d+)?|-?\\\\.\\\\d+)\';\nvar S = \'\\\\s*\';\nvar SS = \'\\\\s+\';\nvar POINT = "".concat(N).concat(SS).concat(N).concat(SS).concat(N);\nvar CURVE = "".concat(POINT).concat(SS).concat(POINT);\nvar COMMANDS_REGEXP = new RegExp("(?:(M|L)".concat(S).concat(POINT).concat(S, "|(C)").concat(S).concat(CURVE, ")").concat(S), \'g\');\nvar SCALE = Math.sqrt(3 / 2);\nvar ROT_60 = Math.PI / 3;\nvar ROT_45 = Math.PI / 4;\nvar ROT_CMA = Math.atan(Math.SQRT2);\nvar Colors;\n(function (Colors) {\n    Colors["white"] = "white";\n    Colors["black"] = "black";\n})(Colors || (Colors = {}));\nvar LineCap;\n(function (LineCap) {\n    LineCap["butt"] = "butt";\n    LineCap["square"] = "square";\n    LineCap["round"] = "round";\n})(LineCap || (LineCap = {}));\nvar LineJoin;\n(function (LineJoin) {\n    LineJoin["miter"] = "miter";\n    LineJoin["round"] = "round";\n    LineJoin["bevel"] = "bevel";\n})(LineJoin || (LineJoin = {}));\nvar Command;\n(function (Command) {\n    Command["move"] = "move";\n    Command["line"] = "line";\n    Command["curve"] = "curve";\n})(Command || (Command = {}));\nvar PlaneView;\n(function (PlaneView) {\n    PlaneView["FRONT"] = "FRONT";\n    PlaneView["SIDE"] = "SIDE";\n    PlaneView["TOP"] = "TOP";\n})(PlaneView || (PlaneView = {}));\nvar Axis;\n(function (Axis) {\n    Axis["RIGHT"] = "RIGHT";\n    Axis["LEFT"] = "LEFT";\n    Axis["TOP"] = "TOP";\n})(Axis || (Axis = {}));\nvar Typeof;\n(function (Typeof) {\n    Typeof["UNDEFINED"] = "undefined";\n    Typeof["NUMBER"] = "number";\n})(Typeof || (Typeof = {}));\nvar EVENTS;\n(function (EVENTS) {\n    EVENTS["MOUSE_MOVE"] = "mousemove";\n    EVENTS["MOUSE_DOWN"] = "mousedown";\n    EVENTS["MOUSE_UP"] = "mouseup";\n    EVENTS["TOUCH_START"] = "touchstart";\n    EVENTS["TOUCH_MOVE"] = "touchmove";\n    EVENTS["TOUCH_END"] = "touchend";\n})(EVENTS || (EVENTS = {}));\nvar ORIGIN;\n(function (ORIGIN) {\n    ORIGIN["CENTER"] = "center";\n    ORIGIN["LEFT"] = "left";\n    ORIGIN["RIGHT"] = "right";\n    ORIGIN["TOP"] = "top";\n    ORIGIN["BOTTOM"] = "bottom";\n})(ORIGIN || (ORIGIN = {}));\n\n;// ./src/@utils/math.ts\n\nvar round = function (n, d) {\n    var exp = Math.pow(10, d);\n    return Math.round(n * exp) / exp;\n};\nvar radian = function (a) { return a * Math.PI / 180; };\nvar sincos = function (r) { return ({\n    sin: round(Math.sin(r), DECIMALS),\n    cos: round(Math.cos(r), DECIMALS)\n}); };\nvar getPointsDiff = function (pointA, pointB) { return ({\n    x: pointA.x - pointB.x,\n    y: pointA.y - pointB.y\n}); };\nvar getPointsDistance = function (pointA, pointB) {\n    var diff = getPointsDiff(pointA, pointB);\n    return Math.sqrt(Math.pow(diff.x, 2) + Math.pow(diff.y, 2));\n};\nvar translatePoint = function (point, angle, distance) { return ({\n    x: point.x + Math.cos(angle) * distance,\n    y: point.y + Math.sin(angle) * distance\n}); };\nvar rotate = function (point, center, angle) {\n    var diff = getPointsDiff(point, center);\n    var x = diff.x * Math.cos(angle) - diff.y * Math.sin(angle);\n    var y = diff.x * Math.sin(angle) + diff.y * Math.cos(angle);\n    return {\n        x: center.x + x,\n        y: center.y + y\n    };\n};\nvar getPointsAngle = function (pointA, pointB) {\n    var diff = getPointsDiff(pointB, pointA);\n    return Math.atan2(diff.y, diff.x);\n};\nvar getOrientation = function (p1, p2, p3) {\n    var value = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y);\n    return value >= 0 ? 0 : 1;\n};\nvar getPointFromIsometricPoint = function (centerX, centerY, point, scale) {\n    return {\n        x: round(centerX + (point.r - point.l) * scale * HSQRT3, DECIMALS),\n        y: round(centerY + ((point.r + point.l) / 2 - point.t) * scale, DECIMALS)\n    };\n};\nvar getTopPlanePointFromCoordinates = function (x, y) {\n    var XHSQRT3 = x / HSQRT3;\n    var right = (y * 2 + XHSQRT3) / 2;\n    var left = right - XHSQRT3;\n    return {\n        right: right,\n        left: left\n    };\n};\nvar getFrontPlanePointFromCoordinates = function (x, y) {\n    var left = -x / HSQRT3;\n    var top = left / 2 - y;\n    return {\n        left: left,\n        top: top\n    };\n};\nvar getSidePlanePointFromCoordinates = function (x, y) {\n    var right = x / HSQRT3;\n    var top = right / 2 - y;\n    return {\n        right: right,\n        top: top\n    };\n};\nvar getEllipsisSpecs = function (pointA, pointB, control) {\n    var diff = getPointsDiff(pointB, pointA);\n    var center = { x: pointA.x + diff.x / 2, y: pointA.y + diff.y / 2 };\n    var P = rotate(pointB, center, Math.PI / 2);\n    var D = { x: P.x + (control.x - P.x) / 2, y: P.y + (control.y - P.y) / 2 };\n    var radius = getPointsDistance(D, center);\n    var U = translatePoint(D, getPointsAngle(D, P), radius);\n    var V = translatePoint(D, getPointsAngle(D, control), radius);\n    return [\n        round(getPointsDistance(control, U), DECIMALS),\n        round(getPointsDistance(control, V), DECIMALS),\n        round(getPointsAngle(center, V) * 180 / Math.PI, DECIMALS)\n    ];\n};\nvar randomId = function () { return Math.random().toString(16).slice(2); };\nvar uuid = function () { return Array.from(Array(3)).map(function () { return randomId(); }).join(\'-\'); };\n\n;// ./src/@utils/matrix.ts\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\nvar multiplyMatrix = function (m1, m2) { return (m1.map(function (row, i) { return (m2[0].map(function (_, j) {\n    return row.reduce(function (acc, _, n) {\n        return acc + m1[i][n] * m2[n][j];\n    }, 0);\n})); })); };\nvar multiplyMatrices = function () {\n    var m = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        m[_i] = arguments[_i];\n    }\n    var matrix = m[0];\n    for (var i = 1; i < m.length; i++) {\n        matrix = multiplyMatrix(matrix, m[i]);\n    }\n    return matrix;\n};\nvar rotateX = function (r) {\n    var sc = sincos(r);\n    return [\n        [1, 0, 0],\n        [0, sc.cos, -sc.sin],\n        [0, sc.sin, sc.cos]\n    ];\n};\nvar rotateY = function (r) {\n    var sc = sincos(r);\n    return [\n        [sc.cos, 0, sc.sin],\n        [0, 1, 0],\n        [-sc.sin, 0, sc.cos]\n    ];\n};\nvar rotateZ = function (r) {\n    var sc = sincos(r);\n    return [\n        [sc.cos, -sc.sin, 0],\n        [sc.sin, sc.cos, 0],\n        [0, 0, 1]\n    ];\n};\nvar topMatrix = multiplyMatrices(rotateX(ROT_CMA), rotateZ(-ROT_45));\nvar frontMatrix = multiplyMatrices(rotateZ(-ROT_60), rotateX(ROT_CMA), rotateZ(ROT_45));\nvar sideMatrix = multiplyMatrices(rotateZ(ROT_60), rotateX(ROT_CMA), rotateZ(-ROT_45));\nvar rotationToRotationMatrix = function (view, rotation) {\n    var value = radian(rotation.value);\n    switch (view) {\n        case PlaneView.TOP: {\n            switch (rotation.axis) {\n                case Axis.TOP:\n                    return rotateZ(value);\n                case Axis.LEFT:\n                    return rotateX(-value);\n                case Axis.RIGHT:\n                    return rotateY(value);\n                default:\n                    return null;\n            }\n        }\n        case PlaneView.FRONT: {\n            switch (rotation.axis) {\n                case Axis.TOP:\n                    return rotateY(value);\n                case Axis.LEFT:\n                    return rotateX(value);\n                case Axis.RIGHT:\n                    return rotateZ(value);\n                default:\n                    return null;\n            }\n        }\n        case PlaneView.SIDE: {\n            switch (rotation.axis) {\n                case Axis.TOP:\n                    return rotateY(value);\n                case Axis.LEFT:\n                    return rotateZ(value);\n                case Axis.RIGHT:\n                    return rotateX(-value);\n                default:\n                    return null;\n            }\n        }\n        default:\n            return null;\n    }\n};\nvar getViewMatrix = function (planeView, rotation) {\n    var rotationMatrices = [];\n    var rotationMatrix = rotation\n        ? rotationToRotationMatrix(planeView, rotation)\n        : null;\n    if (rotationMatrix)\n        rotationMatrices.push(rotationMatrix);\n    switch (planeView) {\n        case PlaneView.TOP: {\n            return multiplyMatrices.apply(void 0, __spreadArray([topMatrix], rotationMatrices, false));\n        }\n        case PlaneView.FRONT: {\n            return multiplyMatrices.apply(void 0, __spreadArray([frontMatrix], rotationMatrices, false));\n        }\n        case PlaneView.SIDE: {\n            return multiplyMatrices.apply(void 0, __spreadArray([sideMatrix], rotationMatrices, false));\n        }\n    }\n    return null;\n};\n\n;// ./src/@utils/svg.ts\nvar svg_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\n\nvar addSVGProperties = function (svg, props) {\n    Object.keys(props).forEach(function (prop) {\n        svg.setAttributeNS(null, prop, props[prop]);\n    });\n};\nvar getCommandsWithStart = function (commands) {\n    return commands.length === 0 || commands[0].command === Command.move\n        ? svg_spreadArray([], commands, true) : svg_spreadArray([\n        {\n            command: Command.move,\n            point: { r: 0, l: 0, t: 0 }\n        }\n    ], commands, true);\n};\nvar getSVGPath = function (commands, centerX, centerY, scale, autoclose) {\n    var drawCommands = getCommandsWithStart(commands);\n    var svgPaths = drawCommands.map(function (c, index) {\n        var point = getPointFromIsometricPoint(centerX, centerY, c.point, scale);\n        switch (c.command) {\n            case Command.move:\n                return "M".concat(point.x, " ").concat(point.y);\n            case Command.line:\n                return "L".concat(point.x, " ").concat(point.y);\n            case Command.curve: {\n                var start = getPointFromIsometricPoint(centerX, centerY, commands[index - 1].point, scale);\n                var control = getPointFromIsometricPoint(centerX, centerY, c.control, scale);\n                var ellipsisSpecs = getEllipsisSpecs(start, point, control);\n                var sweepFlag = getOrientation(start, control, point);\n                return "A ".concat(ellipsisSpecs[0], " ").concat(ellipsisSpecs[1], " ").concat(ellipsisSpecs[2], " 0 ").concat(sweepFlag, " ").concat(point.x, " ").concat(point.y);\n            }\n        }\n    });\n    if (svgPaths.length) {\n        var pathEnd = autoclose ? \'z\' : \'\';\n        return "".concat(svgPaths.join(\' \').trim()).concat(pathEnd);\n    }\n    return \'\';\n};\nvar parseDrawCommands = function (commands) {\n    var commandsArray = [];\n    var array;\n    while ((array = COMMANDS_REGEXP.exec(commands)) !== null) {\n        var command = array[5] || array[1];\n        switch (command) {\n            case \'M\':\n                commandsArray.push({\n                    command: Command.move,\n                    point: { r: +array[2], l: +array[3], t: +array[4] }\n                });\n                break;\n            case \'L\':\n                commandsArray.push({\n                    command: Command.line,\n                    point: { r: +array[2], l: +array[3], t: +array[4] }\n                });\n                break;\n            case \'C\':\n                commandsArray.push({\n                    command: Command.curve,\n                    control: { r: +array[6], l: +array[7], t: +array[8] },\n                    point: { r: +array[9], l: +array[10], t: +array[11] }\n                });\n        }\n    }\n    return commandsArray;\n};\nvar translateCommandPoints = function (commands, right, left, top) {\n    commands.forEach(function (command) {\n        command.point.r += right;\n        command.point.l += left;\n        command.point.t += top;\n        if (command.control) {\n            command.control.r += right;\n            command.control.l += left;\n            command.control.t += top;\n        }\n    });\n};\nvar getTextureCorner = function (commands, centerX, centerY, scale) {\n    var corner = {\n        x: Number.MAX_SAFE_INTEGER,\n        y: Number.MAX_SAFE_INTEGER\n    };\n    getCommandsWithStart(commands)\n        .forEach(function (c) {\n        var point = getPointFromIsometricPoint(centerX, centerY, c.point, scale);\n        if (point.x < corner.x ||\n            (point.x === corner.x &&\n                point.y < corner.y)) {\n            corner.x = point.x;\n            corner.y = point.y;\n        }\n    });\n    return corner;\n};\nvar isSVGProperty = function (property) {\n    return [\n        \'fillColor\',\n        \'fillOpacity\',\n        \'strokeColor\',\n        \'strokeOpacity\',\n        \'strokeWidth\'\n    ].includes(property);\n};\nvar getSVGProperty = function (property) {\n    return {\n        fillColor: \'fill\',\n        fillOpacity: \'fill-opacity\',\n        strokeColor: \'stroke\',\n        strokeOpacity: \'stroke-opacity\',\n        strokeWidth: \'stroke-width\'\n    }[property];\n};\nfunction addEventListenerToElement(element, listeners, event, callback, useCapture) {\n    var listener = {\n        fn: callback,\n        fnBind: callback.bind(this)\n    };\n    listeners.push(listener);\n    element.addEventListener(event, listener.fnBind, useCapture);\n}\nfunction removeEventListenerFromElement(element, listeners, event, callback, useCapture) {\n    var listener;\n    listeners.find(function (ln, index) {\n        if (ln.fn === callback) {\n            listener = listeners.splice(index, 1)[0];\n            return true;\n        }\n    });\n    if (listener) {\n        element.removeEventListener(event, listener.fnBind, useCapture);\n    }\n}\nvar getPatternTransform = function (corner, planeView, scale, rotation) {\n    var matrix = getViewMatrix(planeView, rotation);\n    var transform = "translate(".concat(corner.x, " ").concat(corner.y, ")");\n    if (matrix) {\n        var m1 = round(matrix[0][0], DECIMALS);\n        var m2 = round(matrix[1][0], DECIMALS);\n        var m3 = round(matrix[0][1], DECIMALS);\n        var m4 = round(matrix[1][1], DECIMALS);\n        transform += " matrix(".concat(m1, ",").concat(m2, ",").concat(m3, ",").concat(m4, ",0,0)");\n        transform += " scale(".concat(round(SCALE * (scale || 1), DECIMALS), ")");\n    }\n    else if (scale) {\n        transform += " scale(".concat(round(scale, DECIMALS), ")");\n    }\n    return transform;\n};\nvar elementHasSVGParent = function (element) {\n    if (element.parentNode) {\n        if (element.parentNode.constructor.name === \'SVGSVGElement\') {\n            return true;\n        }\n        return elementHasSVGParent(element.parentNode);\n    }\n    return false;\n};\n\n;// ./src/@store/index.ts\nvar Store = (function () {\n    function Store(width, height, scale) {\n        this.sizes = {\n            centerX: width / 2,\n            centerY: height / 2,\n            height: height,\n            width: width,\n            scale: scale\n        };\n    }\n    Object.defineProperty(Store.prototype, "width", {\n        get: function () {\n            return this.sizes.width;\n        },\n        set: function (value) {\n            this.sizes.width = value;\n            this.sizes.centerX = value / 2;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Store.prototype, "height", {\n        get: function () {\n            return this.sizes.height;\n        },\n        set: function (value) {\n            this.sizes.height = value;\n            this.sizes.centerY = value / 2;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Store.prototype, "scale", {\n        get: function () {\n            return this.sizes.scale;\n        },\n        set: function (value) {\n            this.sizes.scale = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Store.prototype, "centerX", {\n        get: function () {\n            return this.sizes.centerX;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Store.prototype, "centerY", {\n        get: function () {\n            return this.sizes.centerY;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Store;\n}());\n\n\n;// ./src/@classes/abstract/IsometricStore/IsometricStore.ts\nvar IsometricStore = (function () {\n    function IsometricStore() {\n    }\n    Object.defineProperty(IsometricStore.prototype, "data", {\n        get: function () {\n            return this.dataStore;\n        },\n        set: function (store) {\n            this.dataStore = store;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return IsometricStore;\n}());\n\n\n;// ./src/@classes/abstract/IsometricStore/index.ts\n\n\n;// ./src/@classes/abstract/IsometricElementAbstract/IsometricElementAbstract.ts\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nvar IsometricElementAbstract = (function (_super) {\n    __extends(IsometricElementAbstract, _super);\n    function IsometricElementAbstract(id, svgElement) {\n        var _this = _super.call(this) || this;\n        _this._id = id;\n        _this.listeners = [];\n        _this.element = document.createElementNS(SVG_NAMESPACE, svgElement);\n        addSVGProperties(_this.element, {\n            \'id\': _this._id\n        });\n        return _this;\n    }\n    IsometricElementAbstract.prototype.setId = function (value) {\n        this._id = value;\n        addSVGProperties(this.element, {\n            \'id\': this._id\n        });\n    };\n    IsometricElementAbstract.prototype.getElement = function () {\n        return this.element;\n    };\n    IsometricElementAbstract.prototype.addEventListener = function (event, callback, useCapture) {\n        if (useCapture === void 0) { useCapture = false; }\n        addEventListenerToElement.call(this, this.element, this.listeners, event, callback, useCapture);\n        return this;\n    };\n    IsometricElementAbstract.prototype.removeEventListener = function (event, callback, useCapture) {\n        if (useCapture === void 0) { useCapture = false; }\n        removeEventListenerFromElement(this.element, this.listeners, event, callback, useCapture);\n        return this;\n    };\n    return IsometricElementAbstract;\n}(IsometricStore));\n\n\n;// ./src/@classes/abstract/IsometricElementAbstract/index.ts\n\n\n;// ./src/@classes/abstract/IsometricGraphicAbstract/IsometricGraphicAbstract.ts\nvar IsometricGraphicAbstract_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\nvar defaultObjectProps = {\n    fillColor: Colors.white,\n    fillOpacity: 1,\n    strokeColor: Colors.black,\n    strokeDashArray: [],\n    strokeLinecap: LineCap.butt,\n    strokeLinejoin: LineJoin.round,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar IsometricGraphicAbstract = (function (_super) {\n    IsometricGraphicAbstract_extends(IsometricGraphicAbstract, _super);\n    function IsometricGraphicAbstract(props, svgElement) {\n        var _this = _super.call(this, props.id || uuid(), svgElement) || this;\n        _this.props = __assign(__assign({}, defaultObjectProps), props);\n        _this.animations = [];\n        if (_this.props.texture) {\n            _this.createTexture(_this.props.texture);\n        }\n        addSVGProperties(_this.element, __assign({ \'fill\': _this.props.texture\n                ? "url(#".concat(_this.patternId, ") ").concat(_this.fillColor)\n                : _this.fillColor, \'fill-opacity\': "".concat(_this.fillOpacity), \'stroke\': _this.strokeColor, \'stroke-dasharray\': _this.strokeDashArray.join(\' \'), \'stroke-linecap\': _this.strokeLinecap, \'stroke-linejoin\': _this.strokeLinejoin, \'stroke-opacity\': "".concat(_this.strokeOpacity), \'stroke-width\': "".concat(_this.strokeWidth) }, (_this.props.className && {\n            class: _this.props.className\n        })));\n        return _this;\n    }\n    IsometricGraphicAbstract.prototype.createTexture = function (texture) {\n        this.patternId = "".concat(this.id, "__texture");\n        this.pattern = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.pattern);\n        addSVGProperties(this.pattern, {\n            \'id\': this.patternId,\n            \'preserveAspectRatio\': \'none\',\n            \'patternUnits\': \'userSpaceOnUse\'\n        });\n        var image = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.image);\n        addSVGProperties(image, {\n            \'href\': texture.url,\n            \'x\': \'0\',\n            \'y\': \'0\',\n            \'preserveAspectRatio\': \'none\'\n        });\n        if (texture.pixelated) {\n            addSVGProperties(image, {\n                \'style\': \'image-rendering: pixelated\'\n            });\n        }\n        this.pattern.appendChild(image);\n    };\n    IsometricGraphicAbstract.prototype._updateTexture = function () {\n        var image = this.pattern.firstChild;\n        if (this.props.texture.url &&\n            image.getAttribute(\'href\') !== this.props.texture.url) {\n            addSVGProperties(image, {\n                \'href\': this.props.texture.url\n            });\n        }\n        if (this.props.texture.pixelated) {\n            addSVGProperties(image, {\n                \'style\': \'image-rendering: pixelated\'\n            });\n        }\n        else {\n            image.removeAttribute(\'style\');\n        }\n        this.update();\n    };\n    IsometricGraphicAbstract.prototype.addAnimationBasicProperties = function (attributeName, animation) {\n        addSVGProperties(animation.element, {\n            repeatCount: "".concat(animation.repeat || \'indefinite\'),\n            attributeName: attributeName,\n            dur: "".concat(animation.duration || 1, "s")\n        });\n    };\n    IsometricGraphicAbstract.prototype.updateAnimations = function () {\n        var _this = this;\n        this.animations.forEach(function (animation) {\n            var isNativeSVGProperty = isSVGProperty(animation.property);\n            if (isNativeSVGProperty) {\n                var property = getSVGProperty(animation.property);\n                if (!animation.element) {\n                    animation.element = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.animate);\n                }\n                if (!animation.element.parentNode) {\n                    _this.element.appendChild(animation.element);\n                }\n                _this.addAnimationBasicProperties(property, animation);\n                if (animation.values) {\n                    addSVGProperties(animation.element, {\n                        values: Array.isArray(animation.values)\n                            ? animation.values.map(function (value) { return "".concat(value); }).join(\';\')\n                            : "".concat(animation.values)\n                    });\n                }\n                else {\n                    addSVGProperties(animation.element, {\n                        from: "".concat(animation.from),\n                        to: "".concat(animation.to)\n                    });\n                }\n            }\n        });\n        this.updateSubClassAnimations();\n    };\n    IsometricGraphicAbstract.prototype.updatePatternTransform = function (corner, planeView) {\n        var _a, _b, _c;\n        if (this.props.texture) {\n            var height = this.props.texture.height\n                ? "".concat(this.props.texture.height * this.data.scale)\n                : \'100%\';\n            var width = this.props.texture.width\n                ? "".concat(this.props.texture.width * this.data.scale)\n                : \'100%\';\n            var shift = getPointFromIsometricPoint(0, 0, {\n                r: ((_a = this.props.texture.shift) === null || _a === void 0 ? void 0 : _a.right) || 0,\n                l: ((_b = this.props.texture.shift) === null || _b === void 0 ? void 0 : _b.left) || 0,\n                t: ((_c = this.props.texture.shift) === null || _c === void 0 ? void 0 : _c.top) || 0\n            }, this.data.scale);\n            var transform = getPatternTransform({\n                x: round(corner.x + shift.x, DECIMALS),\n                y: round(corner.y + shift.y, DECIMALS)\n            }, this.props.texture.planeView || planeView, this.props.texture.scale, this.props.texture.rotation);\n            addSVGProperties(this.pattern, {\n                \'patternTransform\': transform,\n                \'height\': height,\n                \'width\': width\n            });\n            addSVGProperties(this.pattern.firstChild, {\n                \'height\': height,\n                \'width\': width\n            });\n        }\n    };\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "id", {\n        get: function () {\n            return this._id;\n        },\n        set: function (value) {\n            this.setId(value);\n            if (this.pattern) {\n                this.patternId = "".concat(this.id, "__texture");\n                addSVGProperties(this.pattern, {\n                    \'id\': this.patternId\n                });\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "fillColor", {\n        get: function () {\n            return this.props.fillColor;\n        },\n        set: function (value) {\n            this.props.fillColor = value;\n            addSVGProperties(this.element, {\n                \'fill\': this.props.texture\n                    ? "url(#".concat(this.patternId, ") ").concat(this.fillColor)\n                    : this.fillColor\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "fillOpacity", {\n        get: function () {\n            return this.props.fillOpacity;\n        },\n        set: function (value) {\n            this.props.fillOpacity = value;\n            addSVGProperties(this.element, { \'fill-opacity\': "".concat(this.fillOpacity) });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "texture", {\n        get: function () {\n            return this.props.texture;\n        },\n        set: function (value) {\n            var hasTexture = !!this.props.texture;\n            this.props.texture = value;\n            if (hasTexture) {\n                this._updateTexture();\n            }\n            else {\n                this.createTexture(this.props.texture);\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "strokeColor", {\n        get: function () {\n            return this.props.strokeColor;\n        },\n        set: function (value) {\n            this.props.strokeColor = value;\n            addSVGProperties(this.element, { \'stroke\': this.strokeColor });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "strokeDashArray", {\n        get: function () {\n            return this.props.strokeDashArray;\n        },\n        set: function (value) {\n            this.props.strokeDashArray = value;\n            addSVGProperties(this.element, { \'stroke-dasharray\': this.strokeDashArray.join(\' \') });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "strokeLinecap", {\n        get: function () {\n            return this.props.strokeLinecap;\n        },\n        set: function (value) {\n            this.props.strokeLinecap = LineCap[value];\n            addSVGProperties(this.element, { \'stroke-linecap\': this.strokeLinecap });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "strokeLinejoin", {\n        get: function () {\n            return this.props.strokeLinejoin;\n        },\n        set: function (value) {\n            this.props.strokeLinejoin = LineJoin[value];\n            addSVGProperties(this.element, { \'stroke-linejoin\': this.strokeLinejoin });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "strokeOpacity", {\n        get: function () {\n            return this.props.strokeOpacity;\n        },\n        set: function (value) {\n            this.props.strokeOpacity = value;\n            addSVGProperties(this.element, { \'stroke-opacity\': "".concat(this.strokeOpacity) });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "strokeWidth", {\n        get: function () {\n            return this.props.strokeWidth;\n        },\n        set: function (value) {\n            this.props.strokeWidth = value;\n            addSVGProperties(this.element, { \'stroke-width\': "".concat(this.strokeWidth) });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricGraphicAbstract.prototype, "className", {\n        get: function () {\n            return this.props.className;\n        },\n        set: function (value) {\n            this.props.className = value;\n            addSVGProperties(this.element, {\n                \'class\': this.props.className\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricGraphicAbstract.prototype.getPattern = function () {\n        return this.pattern;\n    };\n    IsometricGraphicAbstract.prototype.updateTexture = function (value) {\n        var hasTexture = !!this.props.texture;\n        if (hasTexture || value.url) {\n            var shift = value.shift, rotation = value.rotation, newProps = __rest(value, ["shift", "rotation"]);\n            this.props.texture = hasTexture\n                ? __assign(__assign({}, this.props.texture), newProps) : __assign({}, newProps);\n            if (shift) {\n                this.props.texture.shift = __assign(__assign({}, (this.props.texture.shift || {})), shift);\n            }\n            if (rotation) {\n                this.props.texture.rotation = rotation;\n            }\n            if (hasTexture) {\n                this._updateTexture();\n            }\n            else {\n                this.createTexture(this.props.texture);\n                this.update();\n            }\n        }\n        return this;\n    };\n    IsometricGraphicAbstract.prototype.addAnimation = function (animation) {\n        this.animations.push(__assign({}, animation));\n        this.update();\n        return this;\n    };\n    IsometricGraphicAbstract.prototype.removeAnimationByIndex = function (index) {\n        if (index >= 0 && index < this.animations.length) {\n            var animation = this.animations.splice(index, 1)[0];\n            if (animation.element && animation.element.parentNode) {\n                animation.element.parentNode.removeChild(animation.element);\n            }\n        }\n        return this;\n    };\n    IsometricGraphicAbstract.prototype.removeAnimations = function () {\n        var animations = this.animations.splice(0);\n        animations.forEach(function (animation) {\n            if (animation.element && animation.element.parentNode) {\n                animation.element.parentNode.removeChild(animation.element);\n            }\n        });\n        return this;\n    };\n    return IsometricGraphicAbstract;\n}(IsometricElementAbstract));\n\n\n;// ./src/@classes/abstract/IsometricGraphicAbstract/index.ts\n\n\n;// ./src/@classes/abstract/IsometricContainerAbstract/IsometricContainerAbstract.ts\nvar IsometricContainerAbstract_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nvar IsometricContainerAbstract = (function (_super) {\n    IsometricContainerAbstract_extends(IsometricContainerAbstract, _super);\n    function IsometricContainerAbstract(id, svgElement) {\n        var _this = _super.call(this, id, svgElement) || this;\n        _this._children = [];\n        return _this;\n    }\n    IsometricContainerAbstract.prototype.getChildIndex = function (child) {\n        return this._children.indexOf(child);\n    };\n    IsometricContainerAbstract.prototype.throwChildError = function () {\n        throw new Error(\'You cannot provide a child that is not a children of the container\');\n    };\n    IsometricContainerAbstract.prototype.removeSVGChild = function (child) {\n        var svgChild = child.getElement();\n        if (child instanceof IsometricGraphicAbstract) {\n            var svgPatternChild = child.getPattern();\n            if (svgPatternChild && svgPatternChild.parentNode) {\n                this.element.removeChild(svgPatternChild);\n            }\n        }\n        if (svgChild.parentNode) {\n            this.element.removeChild(svgChild);\n        }\n    };\n    IsometricContainerAbstract.prototype.insertPattern = function (pattern) {\n        if (pattern) {\n            this.element.insertBefore(pattern, this.element.firstChild);\n        }\n    };\n    Object.defineProperty(IsometricContainerAbstract.prototype, "id", {\n        get: function () {\n            return this._id;\n        },\n        set: function (value) {\n            this.setId(value);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricContainerAbstract.prototype, "children", {\n        get: function () {\n            return this._children;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricContainerAbstract.prototype.update = function () {\n        var _this = this;\n        if (elementHasSVGParent(this.element)) {\n            this._children.forEach(function (child) {\n                child.data = _this.data;\n                child.update();\n            });\n        }\n        return this;\n    };\n    IsometricContainerAbstract.prototype.clear = function () {\n        var _this = this;\n        var children = this._children.splice(0);\n        children.forEach(function (child) {\n            _this.removeSVGChild(child);\n        });\n        return this;\n    };\n    IsometricContainerAbstract.prototype.addChild = function (child) {\n        child.data = this.data;\n        this._children.push(child);\n        if (child instanceof IsometricGraphicAbstract) {\n            this.insertPattern(child.getPattern());\n        }\n        this.element.appendChild(child.getElement());\n        child.update();\n        return this;\n    };\n    IsometricContainerAbstract.prototype.addChildren = function () {\n        var _this = this;\n        var children = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            children[_i] = arguments[_i];\n        }\n        children.forEach(function (child) { return _this.addChild(child); });\n        return this;\n    };\n    IsometricContainerAbstract.prototype.getChildByIndex = function (index) {\n        return this._children[index] || null;\n    };\n    IsometricContainerAbstract.prototype.getChildById = function (id) {\n        var child = this._children.find(function (child) { return child.id === id; });\n        return child || null;\n    };\n    IsometricContainerAbstract.prototype.removeChild = function (child) {\n        var childIndex = this.getChildIndex(child);\n        if (childIndex > -1) {\n            this._children.splice(childIndex, 1);\n            this.removeSVGChild(child);\n            return this;\n        }\n        this.throwChildError();\n    };\n    IsometricContainerAbstract.prototype.removeChildren = function () {\n        var _this = this;\n        var children = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            children[_i] = arguments[_i];\n        }\n        children.forEach(function (child) {\n            var childIndex = _this.getChildIndex(child);\n            if (childIndex === -1) {\n                _this.throwChildError();\n            }\n            _this.removeChild(child);\n        });\n        return this;\n    };\n    IsometricContainerAbstract.prototype.removeChildByIndex = function (index) {\n        if (index >= 0 && index < this._children.length) {\n            var child = this._children.splice(index, 1)[0];\n            this.removeSVGChild(child);\n        }\n        return this;\n    };\n    IsometricContainerAbstract.prototype.removeChildById = function (id) {\n        var child = this.getChildById(id);\n        if (child) {\n            return this.removeChild(child);\n        }\n    };\n    IsometricContainerAbstract.prototype.setChildIndex = function (child, index) {\n        var childIndex = this.getChildIndex(child);\n        if (childIndex > -1) {\n            index = Math.min(Math.max(0, index), this._children.length - 1);\n            var movedElement = child.getElement();\n            var replacedElement = this._children[index].getElement();\n            if (this._children[index] !== child) {\n                this._children.splice(childIndex, 1);\n                this._children.splice(index, 0, child);\n                if (childIndex > index) {\n                    this.element.insertBefore(movedElement, replacedElement);\n                }\n                else {\n                    if (replacedElement.nextSibling) {\n                        this.element.insertBefore(movedElement, replacedElement.nextSibling);\n                    }\n                    else {\n                        this.element.appendChild(movedElement);\n                    }\n                }\n            }\n            return this;\n        }\n        this.throwChildError();\n    };\n    IsometricContainerAbstract.prototype.bringChildToFront = function (child) {\n        var childIndex = this.getChildIndex(child);\n        if (childIndex > -1) {\n            this.setChildIndex(child, this._children.length - 1);\n            return this;\n        }\n        this.throwChildError();\n    };\n    IsometricContainerAbstract.prototype.bringChildForward = function (child) {\n        var childIndex = this.getChildIndex(child);\n        if (childIndex > -1) {\n            if (childIndex < this._children.length - 1) {\n                this.setChildIndex(child, childIndex + 1);\n            }\n            return this;\n        }\n        this.throwChildError();\n    };\n    IsometricContainerAbstract.prototype.sendChildToBack = function (child) {\n        var childIndex = this.getChildIndex(child);\n        if (childIndex > -1) {\n            this.setChildIndex(child, 0);\n            return this;\n        }\n        this.throwChildError();\n    };\n    IsometricContainerAbstract.prototype.sendChildBackward = function (child) {\n        var childIndex = this.getChildIndex(child);\n        if (childIndex > -1) {\n            if (childIndex > 0) {\n                this.setChildIndex(child, childIndex - 1);\n            }\n            return this;\n        }\n        this.throwChildError();\n    };\n    return IsometricContainerAbstract;\n}(IsometricElementAbstract));\n\n\n;// ./src/@classes/abstract/IsometricContainerAbstract/index.ts\n\n\n;// ./src/@classes/public/IsometricCanvas/IsometricCanvas.ts\nvar IsometricCanvas_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricCanvas_assign = (undefined && undefined.__assign) || function () {\n    IsometricCanvas_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricCanvas_assign.apply(this, arguments);\n};\n\n\n\n\n\nvar defaultProps = {\n    container: \'body\',\n    backgroundColor: Colors.white,\n    scale: 1,\n    height: DEFAULT_HEIGHT,\n    width: DEFAULT_WIDTH\n};\nvar IsometricCanvas = (function (_super) {\n    IsometricCanvas_extends(IsometricCanvas, _super);\n    function IsometricCanvas(props) {\n        var _a;\n        if (props === void 0) { props = {}; }\n        var _this = _super.call(this, props.id || uuid(), SVG_ELEMENTS.svg) || this;\n        _this.props = IsometricCanvas_assign(IsometricCanvas_assign({}, defaultProps), props);\n        _this.isAnimated = true;\n        _this.data = new Store(_this.props.width, _this.props.height, _this.props.scale);\n        addSVGProperties(_this.element, (_a = {},\n            _a[SVG_PROPERTIES.viewBox] = "0 0 ".concat(_this.data.width, " ").concat(_this.data.height),\n            _a.width = "".concat(_this.data.width, "px"),\n            _a.height = "".concat(_this.data.height, "px"),\n            _a));\n        _this.background = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.rect);\n        addSVGProperties(_this.background, {\n            fill: _this.backgroundColor,\n            x: \'0\',\n            y: \'0\',\n            width: "".concat(_this.data.width, "px"),\n            height: "".concat(_this.data.height, "px")\n        });\n        _this.element.appendChild(_this.background);\n        var containerElement = typeof _this.props.container === \'string\'\n            ? document.querySelector(_this.props.container)\n            : _this.props.container;\n        containerElement.appendChild(_this.element);\n        return _this;\n    }\n    Object.defineProperty(IsometricCanvas.prototype, "backgroundColor", {\n        get: function () {\n            return this.props.backgroundColor;\n        },\n        set: function (value) {\n            this.props.backgroundColor = value;\n            addSVGProperties(this.background, { fill: this.backgroundColor });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricCanvas.prototype, "scale", {\n        get: function () {\n            return this.data.scale;\n        },\n        set: function (value) {\n            this.data.scale = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricCanvas.prototype, "height", {\n        get: function () {\n            return this.data.height;\n        },\n        set: function (value) {\n            var _a;\n            this.data.height = value;\n            addSVGProperties(this.element, (_a = {},\n                _a[SVG_PROPERTIES.viewBox] = "0 0 ".concat(this.data.width, " ").concat(this.data.height),\n                _a.height = "".concat(this.data.height, "px"),\n                _a));\n            addSVGProperties(this.background, {\n                height: "".concat(this.data.height, "px")\n            });\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricCanvas.prototype, "width", {\n        get: function () {\n            return this.data.width;\n        },\n        set: function (value) {\n            var _a;\n            this.data.width = value;\n            addSVGProperties(this.element, (_a = {},\n                _a[SVG_PROPERTIES.viewBox] = "0 0 ".concat(this.data.width, " ").concat(this.data.height),\n                _a.width = "".concat(this.data.width, "px"),\n                _a));\n            addSVGProperties(this.background, {\n                width: "".concat(this.data.width, "px")\n            });\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricCanvas.prototype, "animated", {\n        get: function () {\n            return this.isAnimated;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricCanvas.prototype.getSVGCode = function () {\n        return this.element.outerHTML;\n    };\n    IsometricCanvas.prototype.pauseAnimations = function () {\n        var svg = this.element;\n        if (typeof svg.pauseAnimations === \'function\') {\n            svg.pauseAnimations();\n        }\n        this.isAnimated = false;\n        return this;\n    };\n    IsometricCanvas.prototype.resumeAnimations = function () {\n        var svg = this.element;\n        if (typeof svg.unpauseAnimations === \'function\') {\n            svg.unpauseAnimations();\n        }\n        this.isAnimated = true;\n        return this;\n    };\n    return IsometricCanvas;\n}(IsometricContainerAbstract));\n\n\n;// ./src/@classes/public/IsometricCanvas/index.ts\n\n\n\n;// ./src/@utils/other.ts\nvar applyMixins = function (BaseClass, constructor) {\n    Object.getOwnPropertyNames(constructor.prototype).forEach(function (name) {\n        Object.defineProperty(BaseClass.prototype, name, Object.getOwnPropertyDescriptor(constructor.prototype, name));\n    });\n};\n\n;// ./src/@classes/abstract/IsometricDraggableAbstract/constants.ts\nvar NO_LIMITS = [\n    Number.MIN_SAFE_INTEGER,\n    Number.MAX_SAFE_INTEGER\n];\nvar DRAG_EVENT;\n(function (DRAG_EVENT) {\n    DRAG_EVENT["DRAG_START"] = "dragstart";\n    DRAG_EVENT["DRAG"] = "drag";\n    DRAG_EVENT["DRAG_END"] = "dragend";\n})(DRAG_EVENT || (DRAG_EVENT = {}));\n\n;// ./src/@classes/abstract/IsometricDraggableAbstract/IsometricDraggableAbstract.ts\nvar IsometricDraggableAbstract_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricDraggableAbstract_assign = (undefined && undefined.__assign) || function () {\n    IsometricDraggableAbstract_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricDraggableAbstract_assign.apply(this, arguments);\n};\nvar IsometricDraggableAbstract_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\n\n\nvar _isBrowser = typeof window !== Typeof.UNDEFINED;\nvar _requestAnimationFrame = _isBrowser\n    ? (window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.msRequestAnimationFrame)\n    : null;\nvar _dragStoreDefault = {\n    right: 0,\n    left: 0,\n    top: 0,\n    x: 0,\n    y: 0\n};\nvar isMouseEvent = function (event) { return \'clientX\' in event; };\nvar getClientCoords = function (event) {\n    if (event instanceof Event) {\n        if (isMouseEvent(event)) {\n            return {\n                clientX: event.clientX,\n                clientY: event.clientY\n            };\n        }\n        return {\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY\n        };\n    }\n    return event;\n};\nvar IsometricDraggableAbstract = (function (_super) {\n    IsometricDraggableAbstract_extends(IsometricDraggableAbstract, _super);\n    function IsometricDraggableAbstract() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IsometricDraggableAbstract.prototype.setup = function () {\n        this.startDrag = this.startDrag.bind(this);\n        this.stopDrag = this.stopDrag.bind(this);\n        this.moveElement = this.moveElement.bind(this);\n        this.dropElement = this.dropElement.bind(this);\n        this.animate = this.animate.bind(this);\n        if (typeof this._bounds === Typeof.UNDEFINED) {\n            this._bounds = false;\n        }\n        if (typeof this._dragStore === Typeof.UNDEFINED) {\n            this._dragStore = _dragStoreDefault;\n        }\n        if (typeof this._coords === Typeof.UNDEFINED) {\n            this._coords = {};\n        }\n    };\n    IsometricDraggableAbstract.prototype.betweenBounds = function (value, bounds) {\n        var orderedBounds = IsometricDraggableAbstract_spreadArray([], bounds, true).sort();\n        return round(Math.min(Math.max(value, orderedBounds[0]), orderedBounds[1]), DECIMALS);\n    };\n    IsometricDraggableAbstract.prototype.getBoundOrMaximum = function (prop) {\n        var _a;\n        if (this.bounds) {\n            return (_a = this.bounds[prop]) !== null && _a !== void 0 ? _a : IsometricDraggableAbstract_spreadArray([], NO_LIMITS, true);\n        }\n        return IsometricDraggableAbstract_spreadArray([], NO_LIMITS, true);\n    };\n    IsometricDraggableAbstract.prototype.getRight = function (value) {\n        var bounds = this.getBoundOrMaximum(\'right\');\n        return this.betweenBounds(this._dragStore.right + value / this.data.scale, bounds);\n    };\n    IsometricDraggableAbstract.prototype.getLeft = function (value) {\n        var bounds = this.getBoundOrMaximum(\'left\');\n        return this.betweenBounds(this._dragStore.left + value / this.data.scale, bounds);\n    };\n    IsometricDraggableAbstract.prototype.getTop = function (value) {\n        var bounds = this.getBoundOrMaximum(\'top\');\n        return this.betweenBounds(this._dragStore.top + value / this.data.scale, bounds);\n    };\n    IsometricDraggableAbstract.prototype.getFixedCoordinates = function (coords) {\n        var _this = this;\n        return Object.entries(coords).reduce(function (acc, entry) {\n            var fixedCoords = IsometricDraggableAbstract_assign({}, acc);\n            switch (entry[0]) {\n                case \'right\':\n                    fixedCoords.right = _this.getRight(entry[1]);\n                    break;\n                case \'left\':\n                    fixedCoords.left = _this.getLeft(entry[1]);\n                    break;\n                default:\n                    fixedCoords.top = _this.getTop(entry[1]);\n            }\n            return fixedCoords;\n        }, {});\n    };\n    IsometricDraggableAbstract.prototype.dispatchEvent = function (eventType) {\n        var _a, _b, _c;\n        var dragEvent = new CustomEvent(eventType, {\n            cancelable: eventType === DRAG_EVENT.DRAG,\n            detail: {\n                right: (_a = this._coords.right) !== null && _a !== void 0 ? _a : this.right,\n                left: (_b = this._coords.left) !== null && _b !== void 0 ? _b : this.left,\n                top: (_c = this._coords.top) !== null && _c !== void 0 ? _c : this.top\n            }\n        });\n        this.element.dispatchEvent(dragEvent);\n        return dragEvent;\n    };\n    IsometricDraggableAbstract.prototype.animate = function () {\n        if (this._update) {\n            if (!this._prevented) {\n                if (typeof this._coords.right === Typeof.NUMBER) {\n                    this.right = this._coords.right;\n                }\n                if (typeof this._coords.left === Typeof.NUMBER) {\n                    this.left = this._coords.left;\n                }\n                if (typeof this._coords.top === Typeof.NUMBER) {\n                    this.top = this._coords.top;\n                }\n            }\n            _requestAnimationFrame(this.animate);\n        }\n    };\n    IsometricDraggableAbstract.prototype.startDrag = function (event) {\n        event.preventDefault();\n        var _a = getClientCoords(event), clientX = _a.clientX, clientY = _a.clientY;\n        this._dragStore.x = clientX;\n        this._dragStore.y = clientY;\n        this._dragStore.right = this.right;\n        this._dragStore.left = this.left;\n        this._dragStore.top = this.top;\n        this._update = true;\n        this.moveElement({ clientX: clientX, clientY: clientY });\n        this.element.addEventListener(EVENTS.TOUCH_MOVE, this.moveElement, true);\n        this.element.addEventListener(EVENTS.TOUCH_END, this.dropElement, true);\n        document.addEventListener(EVENTS.MOUSE_MOVE, this.moveElement, true);\n        document.addEventListener(EVENTS.MOUSE_UP, this.dropElement, true);\n        _requestAnimationFrame(this.animate);\n    };\n    IsometricDraggableAbstract.prototype.moveElement = function (event) {\n        var _a = getClientCoords(event), clientX = _a.clientX, clientY = _a.clientY;\n        var diffX = clientX - this._dragStore.x;\n        var diffY = clientY - this._dragStore.y;\n        if (this._drag === PlaneView.TOP) {\n            this._coords = this.getFixedCoordinates(getTopPlanePointFromCoordinates(diffX, diffY));\n        }\n        else if (this._drag === PlaneView.FRONT) {\n            this._coords = this.getFixedCoordinates(getFrontPlanePointFromCoordinates(diffX, diffY));\n        }\n        else {\n            this._coords = this.getFixedCoordinates(getSidePlanePointFromCoordinates(diffX, diffY));\n        }\n        var dragEvent;\n        if (event instanceof Event) {\n            event.preventDefault();\n            if (!this._dragging) {\n                this.dispatchEvent(DRAG_EVENT.DRAG_START);\n            }\n            this._dragging = true;\n            dragEvent = this.dispatchEvent(DRAG_EVENT.DRAG);\n        }\n        this._prevented = !!(dragEvent && dragEvent.defaultPrevented);\n    };\n    IsometricDraggableAbstract.prototype.dropElement = function () {\n        this._update = false;\n        this._dragging = false;\n        this.element.removeEventListener(EVENTS.TOUCH_MOVE, this.moveElement, true);\n        this.element.removeEventListener(EVENTS.TOUCH_END, this.dropElement, true);\n        document.removeEventListener(EVENTS.MOUSE_MOVE, this.moveElement, true);\n        document.removeEventListener(EVENTS.MOUSE_UP, this.dropElement, true);\n        this.dispatchEvent(DRAG_EVENT.DRAG_END);\n    };\n    IsometricDraggableAbstract.prototype.beginDrag = function () {\n        this.element.addEventListener(EVENTS.TOUCH_START, this.startDrag, true);\n        this.element.addEventListener(EVENTS.MOUSE_DOWN, this.startDrag, true);\n    };\n    IsometricDraggableAbstract.prototype.stopDrag = function () {\n        this.element.removeEventListener(EVENTS.TOUCH_START, this.startDrag, true);\n        this.element.removeEventListener(EVENTS.TOUCH_MOVE, this.moveElement, true);\n        this.element.removeEventListener(EVENTS.TOUCH_END, this.dropElement, true);\n        this.element.removeEventListener(EVENTS.MOUSE_DOWN, this.startDrag, true);\n        document.removeEventListener(EVENTS.MOUSE_MOVE, this.moveElement, true);\n        document.removeEventListener(EVENTS.MOUSE_UP, this.dropElement, true);\n    };\n    Object.defineProperty(IsometricDraggableAbstract.prototype, "right", {\n        get: function () {\n            return this.props.right;\n        },\n        set: function (value) {\n            if (this.props.right !== value) {\n                this.props.right = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricDraggableAbstract.prototype, "left", {\n        get: function () {\n            return this.props.left;\n        },\n        set: function (value) {\n            if (this.props.left !== value) {\n                this.props.left = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricDraggableAbstract.prototype, "top", {\n        get: function () {\n            return this.props.top;\n        },\n        set: function (value) {\n            if (this.props.top !== value) {\n                this.props.top = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricDraggableAbstract.prototype, "drag", {\n        get: function () {\n            return this._drag || false;\n        },\n        set: function (value) {\n            if (typeof this._drag === Typeof.UNDEFINED) {\n                this.setup();\n            }\n            this._drag = value;\n            if (_isBrowser) {\n                this.stopDrag();\n                this.beginDrag();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricDraggableAbstract.prototype, "bounds", {\n        get: function () {\n            return this._bounds || false;\n        },\n        set: function (value) {\n            this._bounds = value;\n            var boundsRight = this.getBoundOrMaximum(\'right\');\n            var boundsLeft = this.getBoundOrMaximum(\'left\');\n            var boundsTop = this.getBoundOrMaximum(\'top\');\n            this.right = this.betweenBounds(this.right, boundsRight);\n            this.left = this.betweenBounds(this.left, boundsLeft);\n            this.top = this.betweenBounds(this.top, boundsTop);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return IsometricDraggableAbstract;\n}(IsometricElementAbstract));\n\n\n;// ./src/@classes/abstract/IsometricDraggableAbstract/index.ts\n\n\n;// ./src/@classes/public/IsometricGroup/IsometricGroup.ts\nvar IsometricGroup_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricGroup_assign = (undefined && undefined.__assign) || function () {\n    IsometricGroup_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricGroup_assign.apply(this, arguments);\n};\n\n\n\n\n\n\nvar IsometricGroup_defaultProps = {\n    right: 0,\n    left: 0,\n    top: 0,\n};\nvar IsometricGroup = (function (_super) {\n    IsometricGroup_extends(IsometricGroup, _super);\n    function IsometricGroup(props) {\n        if (props === void 0) { props = {}; }\n        var _this = _super.call(this, props.id || uuid(), SVG_ELEMENTS.group) || this;\n        _this.props = IsometricGroup_assign(IsometricGroup_assign({}, IsometricGroup_defaultProps), props);\n        return _this;\n    }\n    IsometricGroup.prototype.update = function () {\n        if (elementHasSVGParent(this.element)) {\n            var point = getPointFromIsometricPoint(0, 0, {\n                r: this.props.right,\n                l: this.props.left,\n                t: this.props.top\n            }, this.data.scale);\n            addSVGProperties(this.element, {\n                transform: "translate(".concat(point.x, ", ").concat(point.y, ")")\n            });\n        }\n        return _super.prototype.update.call(this);\n    };\n    return IsometricGroup;\n}(IsometricContainerAbstract));\n\napplyMixins(IsometricGroup, IsometricDraggableAbstract);\n\n;// ./src/@classes/public/IsometricGroup/index.ts\n\n\n;// ./src/@classes/abstract/IsometricPathAbstract/IsometricPathAbstract.ts\nvar IsometricPathAbstract_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar IsometricPathAbstract = (function (_super) {\n    IsometricPathAbstract_extends(IsometricPathAbstract, _super);\n    function IsometricPathAbstract(props, svgElement) {\n        return _super.call(this, props, svgElement) || this;\n    }\n    IsometricPathAbstract.prototype.updateGraphic = function (planeView, autoclose) {\n        if (autoclose === void 0) { autoclose = true; }\n        if (elementHasSVGParent(this.element)) {\n            var commands = this.getCommands();\n            var corner = getTextureCorner(commands, this.data.centerX, this.data.centerY, this.data.scale);\n            addSVGProperties(this.element, {\n                d: getSVGPath(commands, this.data.centerX, this.data.centerY, this.data.scale, autoclose)\n            });\n            this.updatePatternTransform(corner, planeView);\n            this.updateAnimations();\n        }\n    };\n    return IsometricPathAbstract;\n}(IsometricGraphicAbstract));\n\n\n;// ./src/@classes/abstract/IsometricPathAbstract/index.ts\n\n\n;// ./src/@classes/abstract/IsometricShapeAbstract/IsometricShapeAbstract.ts\nvar IsometricShapeAbstract_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricShapeAbstract_assign = (undefined && undefined.__assign) || function () {\n    IsometricShapeAbstract_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricShapeAbstract_assign.apply(this, arguments);\n};\n\n\n\n\n\nvar IsometricShapeAbstract_defaultProps = {\n    right: 0,\n    left: 0,\n    top: 0,\n};\nvar IsometricShapeAbstract = (function (_super) {\n    IsometricShapeAbstract_extends(IsometricShapeAbstract, _super);\n    function IsometricShapeAbstract(props) {\n        return _super.call(this, IsometricShapeAbstract_assign(IsometricShapeAbstract_assign({}, IsometricShapeAbstract_defaultProps), props), SVG_ELEMENTS.path) || this;\n    }\n    IsometricShapeAbstract.prototype.update = function () {\n        this.updateGraphic(this.planeView);\n        return this;\n    };\n    IsometricShapeAbstract.prototype.clear = function () {\n        addSVGProperties(this.element, {\n            d: \'\'\n        });\n        return this;\n    };\n    Object.defineProperty(IsometricShapeAbstract.prototype, "planeView", {\n        get: function () {\n            return this.props.planeView;\n        },\n        set: function (value) {\n            this.props.planeView = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return IsometricShapeAbstract;\n}(IsometricPathAbstract));\n\napplyMixins(IsometricShapeAbstract, IsometricDraggableAbstract);\n\n;// ./src/@classes/abstract/IsometricShapeAbstract/index.ts\n\n\n;// ./src/@classes/public/IsometricRectangle/IsometricRectangle.ts\nvar IsometricRectangle_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricRectangle_assign = (undefined && undefined.__assign) || function () {\n    IsometricRectangle_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricRectangle_assign.apply(this, arguments);\n};\nvar IsometricRectangle_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nvar IsometricRectangle = (function (_super) {\n    IsometricRectangle_extends(IsometricRectangle, _super);\n    function IsometricRectangle(props) {\n        var _this = this;\n        var height = props.height, width = props.width, rest = IsometricRectangle_rest(props, ["height", "width"]);\n        _this = _super.call(this, rest) || this;\n        _this._width = width;\n        _this._height = height;\n        return _this;\n    }\n    IsometricRectangle.prototype.getCommands = function (args) {\n        var _a, _b, _c, _d, _e;\n        var right = (_a = args === null || args === void 0 ? void 0 : args.right) !== null && _a !== void 0 ? _a : this.right;\n        var left = (_b = args === null || args === void 0 ? void 0 : args.left) !== null && _b !== void 0 ? _b : this.left;\n        var top = (_c = args === null || args === void 0 ? void 0 : args.top) !== null && _c !== void 0 ? _c : this.top;\n        var width = (_d = args === null || args === void 0 ? void 0 : args.width) !== null && _d !== void 0 ? _d : this.width;\n        var height = (_e = args === null || args === void 0 ? void 0 : args.height) !== null && _e !== void 0 ? _e : this.height;\n        var commands = [{ command: Command.move, point: { r: 0, l: 0, t: 0 } }];\n        switch (this.planeView) {\n            case PlaneView.FRONT:\n                commands.push({ command: Command.line, point: { r: 0, l: width, t: 0 } }, { command: Command.line, point: { r: 0, l: width, t: height } }, { command: Command.line, point: { r: 0, l: 0, t: height } });\n                break;\n            case PlaneView.SIDE:\n                commands.push({ command: Command.line, point: { r: width, l: 0, t: 0 } }, { command: Command.line, point: { r: width, l: 0, t: height } }, { command: Command.line, point: { r: 0, l: 0, t: height } });\n                break;\n            case PlaneView.TOP:\n                commands.push({ command: Command.line, point: { r: width, l: 0, t: 0 } }, { command: Command.line, point: { r: width, l: height, t: 0 } }, { command: Command.line, point: { r: 0, l: height, t: 0 } });\n                break;\n        }\n        translateCommandPoints(commands, right, left, top);\n        return commands;\n    };\n    IsometricRectangle.prototype.getRectanglePath = function (args) {\n        var commands = this.getCommands(args);\n        return getSVGPath(commands, this.data.centerX, this.data.centerY, this.data.scale, true);\n    };\n    IsometricRectangle.prototype.updateSubClassAnimations = function () {\n        var _this = this;\n        this.animations.forEach(function (animation) {\n            var isNativeSVGProperty = isSVGProperty(animation.property);\n            if (!isNativeSVGProperty) {\n                var props_1 = {\n                    right: _this.right,\n                    left: _this.left,\n                    top: _this.top,\n                    width: _this.width,\n                    height: _this.height\n                };\n                if (Object.prototype.hasOwnProperty.call(props_1, animation.property)) {\n                    var property_1 = animation.property;\n                    var properties = void 0;\n                    if (animation.values) {\n                        if (Array.isArray(animation.values)) {\n                            properties = {\n                                values: animation.values.map(function (value) {\n                                    var modifiedArgs = IsometricRectangle_assign({}, props_1);\n                                    modifiedArgs[property_1] = +value;\n                                    return _this.getRectanglePath(modifiedArgs);\n                                }).join(\';\')\n                            };\n                        }\n                        else {\n                            var modifiedArgs = IsometricRectangle_assign({}, props_1);\n                            modifiedArgs[property_1] = +animation.values;\n                            properties = {\n                                values: _this.getRectanglePath(modifiedArgs)\n                            };\n                        }\n                    }\n                    else {\n                        var fromArgs = IsometricRectangle_assign({}, props_1);\n                        var toArgs = IsometricRectangle_assign({}, props_1);\n                        fromArgs[property_1] = +animation.from;\n                        toArgs[property_1] = +animation.to;\n                        properties = {\n                            from: _this.getRectanglePath(fromArgs),\n                            to: _this.getRectanglePath(toArgs)\n                        };\n                    }\n                    if (!animation.element) {\n                        animation.element = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.animate);\n                    }\n                    if (!animation.element.parentNode) {\n                        _this.element.appendChild(animation.element);\n                    }\n                    _this.addAnimationBasicProperties(\'d\', animation);\n                    addSVGProperties(animation.element, properties);\n                }\n            }\n        });\n    };\n    Object.defineProperty(IsometricRectangle.prototype, "width", {\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            this._width = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricRectangle.prototype, "height", {\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            this._height = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricRectangle.prototype.addAnimation = function (animation) {\n        return _super.prototype.addAnimation.call(this, animation);\n    };\n    return IsometricRectangle;\n}(IsometricShapeAbstract));\n\n\n;// ./src/@classes/public/IsometricRectangle/index.ts\n\n\n;// ./src/@classes/public/IsometricCircle/IsometricCircle.ts\nvar IsometricCircle_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricCircle_assign = (undefined && undefined.__assign) || function () {\n    IsometricCircle_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricCircle_assign.apply(this, arguments);\n};\nvar IsometricCircle_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nvar IsometricCircle = (function (_super) {\n    IsometricCircle_extends(IsometricCircle, _super);\n    function IsometricCircle(props) {\n        var _this = this;\n        var radius = props.radius, rest = IsometricCircle_rest(props, ["radius"]);\n        _this = _super.call(this, rest) || this;\n        _this._radius = radius;\n        return _this;\n    }\n    IsometricCircle.prototype.getCommands = function (args) {\n        var _a, _b, _c, _d;\n        var right = (_a = args === null || args === void 0 ? void 0 : args.right) !== null && _a !== void 0 ? _a : this.right;\n        var left = (_b = args === null || args === void 0 ? void 0 : args.left) !== null && _b !== void 0 ? _b : this.left;\n        var top = (_c = args === null || args === void 0 ? void 0 : args.top) !== null && _c !== void 0 ? _c : this.top;\n        var radius = (_d = args === null || args === void 0 ? void 0 : args.radius) !== null && _d !== void 0 ? _d : this.radius;\n        var commands = [];\n        switch (this.planeView) {\n            case PlaneView.FRONT:\n                commands.push({\n                    command: Command.move,\n                    point: { r: 0, l: radius, t: 0 }\n                }, {\n                    command: Command.curve,\n                    point: { r: 0, l: -radius, t: 0 },\n                    control: { r: 0, l: 0, t: -radius }\n                }, {\n                    command: Command.curve,\n                    point: { r: 0, l: radius, t: 0 },\n                    control: { r: 0, l: 0, t: radius }\n                });\n                break;\n            case PlaneView.SIDE:\n                commands.push({\n                    command: Command.move,\n                    point: { r: -radius, l: 0, t: 0 }\n                }, {\n                    command: Command.curve,\n                    point: { r: radius, l: 0, t: 0 },\n                    control: { r: 0, l: 0, t: -radius }\n                }, {\n                    command: Command.curve,\n                    point: { r: -radius, l: 0, t: 0 },\n                    control: { r: 0, l: 0, t: radius }\n                });\n                break;\n            case PlaneView.TOP:\n                commands.push({\n                    command: Command.move,\n                    point: { r: 0, l: radius, t: 0 }\n                }, {\n                    command: Command.curve,\n                    point: { r: 0, l: -radius, t: 0 },\n                    control: { r: radius, l: 0, t: 0 }\n                }, {\n                    command: Command.curve,\n                    point: { r: 0, l: radius, t: 0 },\n                    control: { r: -radius, l: 0, t: 0 }\n                });\n                break;\n        }\n        translateCommandPoints(commands, right, left, top);\n        return commands;\n    };\n    IsometricCircle.prototype.getCirclePath = function (args) {\n        var commands = this.getCommands(args);\n        return getSVGPath(commands, this.data.centerX, this.data.centerY, this.data.scale, true);\n    };\n    IsometricCircle.prototype.updateSubClassAnimations = function () {\n        var _this = this;\n        this.animations.forEach(function (animation) {\n            var isNativeSVGProperty = isSVGProperty(animation.property);\n            if (!isNativeSVGProperty) {\n                var props_1 = {\n                    right: _this.right,\n                    left: _this.left,\n                    top: _this.top,\n                    radius: _this.radius\n                };\n                if (Object.prototype.hasOwnProperty.call(props_1, animation.property)) {\n                    var property_1 = animation.property;\n                    var properties = void 0;\n                    if (animation.values) {\n                        if (Array.isArray(animation.values)) {\n                            properties = {\n                                values: animation.values.map(function (value) {\n                                    var modifiedArgs = IsometricCircle_assign({}, props_1);\n                                    modifiedArgs[property_1] = +value;\n                                    return _this.getCirclePath(modifiedArgs);\n                                }).join(\';\')\n                            };\n                        }\n                        else {\n                            var modifiedArgs = IsometricCircle_assign({}, props_1);\n                            modifiedArgs[property_1] = +animation.values;\n                            properties = {\n                                values: _this.getCirclePath(modifiedArgs)\n                            };\n                        }\n                    }\n                    else {\n                        var fromArgs = IsometricCircle_assign({}, props_1);\n                        var toArgs = IsometricCircle_assign({}, props_1);\n                        fromArgs[property_1] = +animation.from;\n                        toArgs[property_1] = +animation.to;\n                        properties = {\n                            from: _this.getCirclePath(fromArgs),\n                            to: _this.getCirclePath(toArgs)\n                        };\n                    }\n                    if (!animation.element) {\n                        animation.element = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.animate);\n                    }\n                    if (!animation.element.parentNode) {\n                        _this.element.appendChild(animation.element);\n                    }\n                    _this.addAnimationBasicProperties(\'d\', animation);\n                    addSVGProperties(animation.element, properties);\n                }\n            }\n        });\n    };\n    Object.defineProperty(IsometricCircle.prototype, "radius", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (value) {\n            this._radius = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricCircle.prototype.addAnimation = function (animation) {\n        return _super.prototype.addAnimation.call(this, animation);\n    };\n    return IsometricCircle;\n}(IsometricShapeAbstract));\n\n\n;// ./src/@classes/public/IsometricCircle/index.ts\n\n\n;// ./src/@classes/abstract/IsometricStarPolygonAbstract/IsometricStarPolygonAbstract.ts\nvar IsometricStarPolygonAbstract_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricStarPolygonAbstract_assign = (undefined && undefined.__assign) || function () {\n    IsometricStarPolygonAbstract_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricStarPolygonAbstract_assign.apply(this, arguments);\n};\nvar IsometricStarPolygonAbstract_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar IsometricStarPolygonAbstract_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\n\nvar IsometricStarPolygonAbstract = (function (_super) {\n    IsometricStarPolygonAbstract_extends(IsometricStarPolygonAbstract, _super);\n    function IsometricStarPolygonAbstract(props) {\n        var _this = this;\n        var radius = props.radius, points = props.points, density = props.density, _a = props.rotation, rotation = _a === void 0 ? 0 : _a, rest = IsometricStarPolygonAbstract_rest(props, ["radius", "points", "density", "rotation"]);\n        _this = _super.call(this, rest) || this;\n        _this._radius = radius;\n        _this._points = points;\n        _this._density = density;\n        _this._rotation = rotation;\n        _this._sector = 2 * Math.PI / _this._points;\n        _this._halfSector = _this._sector / 2;\n        return _this;\n    }\n    IsometricStarPolygonAbstract.prototype.getCommands = function (args) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        var right = (_a = args === null || args === void 0 ? void 0 : args.right) !== null && _a !== void 0 ? _a : this.right;\n        var left = (_b = args === null || args === void 0 ? void 0 : args.left) !== null && _b !== void 0 ? _b : this.left;\n        var top = (_c = args === null || args === void 0 ? void 0 : args.top) !== null && _c !== void 0 ? _c : this.top;\n        var radius = (_d = args === null || args === void 0 ? void 0 : args.radius) !== null && _d !== void 0 ? _d : this.radius;\n        var points = (_e = args === null || args === void 0 ? void 0 : args.points) !== null && _e !== void 0 ? _e : this._points;\n        var density = (_f = args === null || args === void 0 ? void 0 : args.density) !== null && _f !== void 0 ? _f : this._density;\n        var rotation = (_g = args === null || args === void 0 ? void 0 : args.rotation) !== null && _g !== void 0 ? _g : this.rotation;\n        var coordinates = this.get2DCoordinates(radius, points, density, rotation);\n        var commands = [];\n        switch (this.planeView) {\n            case PlaneView.FRONT:\n                coordinates.forEach(function (point, index) {\n                    commands.push({\n                        command: index === 0\n                            ? Command.move\n                            : Command.line,\n                        point: {\n                            r: 0,\n                            l: point.x,\n                            t: point.y\n                        }\n                    });\n                });\n                break;\n            case PlaneView.SIDE:\n                coordinates.forEach(function (point, index) {\n                    commands.push({\n                        command: index === 0\n                            ? Command.move\n                            : Command.line,\n                        point: {\n                            r: point.x,\n                            l: 0,\n                            t: point.y\n                        }\n                    });\n                });\n                break;\n            case PlaneView.TOP:\n                coordinates.forEach(function (point, index) {\n                    commands.push({\n                        command: index === 0\n                            ? Command.move\n                            : Command.line,\n                        point: {\n                            r: -point.x,\n                            l: -point.y,\n                            t: 0\n                        }\n                    });\n                });\n                break;\n        }\n        translateCommandPoints(commands, right, left, top);\n        return commands;\n    };\n    IsometricStarPolygonAbstract.prototype._getRadianAngle = function (angle) {\n        return angle * Math.PI / 180;\n    };\n    IsometricStarPolygonAbstract.prototype._getInnerRadius = function (radius, points, density) {\n        return radius * Math.cos(Math.PI * density / points) / Math.cos(Math.PI * (density - 1) / points);\n    };\n    IsometricStarPolygonAbstract.prototype.get2DCoordinates = function (radius, points, density, rotation) {\n        var _this = this;\n        var innerRadius = this._getInnerRadius(radius, points, density);\n        return IsometricStarPolygonAbstract_spreadArray([], Array(this._points), true).reduce(function (points, _undefined, index) {\n            var angle = index * _this._sector + 2 * Math.PI - _this._getRadianAngle(rotation);\n            var innerAngle = angle + _this._halfSector;\n            var oX = Math.sin(angle) * radius;\n            var oY = Math.cos(angle) * radius;\n            var iX = Math.sin(innerAngle) * innerRadius;\n            var iY = Math.cos(innerAngle) * innerRadius;\n            return IsometricStarPolygonAbstract_spreadArray(IsometricStarPolygonAbstract_spreadArray([], points, true), [\n                { x: oX, y: oY },\n                { x: iX, y: iY }\n            ], false);\n        }, []);\n    };\n    IsometricStarPolygonAbstract.prototype.getPentagramPath = function (args) {\n        var commands = this.getCommands(args);\n        return getSVGPath(commands, this.data.centerX, this.data.centerY, this.data.scale, true);\n    };\n    IsometricStarPolygonAbstract.prototype.updateSubClassAnimations = function () {\n        var _this = this;\n        this.animations.forEach(function (animation) {\n            var isNativeSVGProperty = isSVGProperty(animation.property);\n            if (!isNativeSVGProperty) {\n                var props_1 = {\n                    right: _this.right,\n                    left: _this.left,\n                    top: _this.top,\n                    radius: _this.radius,\n                    points: _this._points,\n                    density: _this._density,\n                    rotation: _this.rotation\n                };\n                if (Object.prototype.hasOwnProperty.call(props_1, animation.property)) {\n                    var property_1 = animation.property;\n                    var properties = void 0;\n                    if (animation.values) {\n                        if (Array.isArray(animation.values)) {\n                            properties = {\n                                values: animation.values.map(function (value) {\n                                    var modifiedArgs = IsometricStarPolygonAbstract_assign({}, props_1);\n                                    modifiedArgs[property_1] = +value;\n                                    return _this.getPentagramPath(modifiedArgs);\n                                }).join(\';\')\n                            };\n                        }\n                        else {\n                            var modifiedArgs = IsometricStarPolygonAbstract_assign({}, props_1);\n                            modifiedArgs[property_1] = +animation.values;\n                            properties = {\n                                values: _this.getPentagramPath(modifiedArgs)\n                            };\n                        }\n                    }\n                    else {\n                        var fromArgs = IsometricStarPolygonAbstract_assign({}, props_1);\n                        var toArgs = IsometricStarPolygonAbstract_assign({}, props_1);\n                        fromArgs[property_1] = +animation.from;\n                        toArgs[property_1] = +animation.to;\n                        properties = {\n                            from: _this.getPentagramPath(fromArgs),\n                            to: _this.getPentagramPath(toArgs)\n                        };\n                    }\n                    if (!animation.element) {\n                        animation.element = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.animate);\n                    }\n                    if (!animation.element.parentNode) {\n                        _this.element.appendChild(animation.element);\n                    }\n                    _this.addAnimationBasicProperties(\'d\', animation);\n                    addSVGProperties(animation.element, properties);\n                }\n            }\n        });\n    };\n    Object.defineProperty(IsometricStarPolygonAbstract.prototype, "radius", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (value) {\n            this._radius = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricStarPolygonAbstract.prototype, "rotation", {\n        get: function () {\n            return this._rotation;\n        },\n        set: function (value) {\n            this._rotation = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricStarPolygonAbstract.prototype.addAnimation = function (animation) {\n        return _super.prototype.addAnimation.call(this, animation);\n    };\n    return IsometricStarPolygonAbstract;\n}(IsometricShapeAbstract));\n\n\n;// ./src/@classes/abstract/IsometricStarPolygonAbstract/index.ts\n\n\n\n;// ./src/@classes/public/IsometricPentagram/IsometricPentagram.ts\nvar IsometricPentagram_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricPentagram_assign = (undefined && undefined.__assign) || function () {\n    IsometricPentagram_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricPentagram_assign.apply(this, arguments);\n};\n\nvar IsometricPentagram = (function (_super) {\n    IsometricPentagram_extends(IsometricPentagram, _super);\n    function IsometricPentagram(props) {\n        return _super.call(this, IsometricPentagram_assign(IsometricPentagram_assign({}, props), { points: 5, density: 2 })) || this;\n    }\n    return IsometricPentagram;\n}(IsometricStarPolygonAbstract));\n\n\n;// ./src/@classes/public/IsometricPentagram/index.ts\n\n\n;// ./src/@classes/public/IsometricStarPolygon/IsometricStarPolygon.ts\nvar IsometricStarPolygon_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar IsometricStarPolygon = (function (_super) {\n    IsometricStarPolygon_extends(IsometricStarPolygon, _super);\n    function IsometricStarPolygon(props) {\n        return _super.call(this, props) || this;\n    }\n    Object.defineProperty(IsometricStarPolygon.prototype, "points", {\n        get: function () {\n            return this._points;\n        },\n        set: function (value) {\n            this._points = value;\n            this._sector = 2 * Math.PI / this._points;\n            this._halfSector = this._sector / 2;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricStarPolygon.prototype, "density", {\n        get: function () {\n            return this._density;\n        },\n        set: function (value) {\n            this._density = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return IsometricStarPolygon;\n}(IsometricStarPolygonAbstract));\n\n\n;// ./src/@classes/public/IsometricStarPolygon/index.ts\n\n\n;// ./src/@classes/public/IsometricPath/IsometricPath.ts\nvar IsometricPath_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nvar IsometricPath = (function (_super) {\n    IsometricPath_extends(IsometricPath, _super);\n    function IsometricPath(props) {\n        if (props === void 0) { props = {}; }\n        var _this = _super.call(this, props, SVG_ELEMENTS.path) || this;\n        _this.getPathFromCommands = function (commands) { return getSVGPath(parseDrawCommands(commands), _this.data.centerX, _this.data.centerY, _this.data.scale, _this._autoclose); };\n        _this.commands = [];\n        _this._autoclose = \'autoclose\' in props\n            ? props.autoclose\n            : true;\n        return _this;\n    }\n    IsometricPath.prototype.updateSubClassAnimations = function () {\n        var _this = this;\n        this.animations.forEach(function (animation) {\n            if (animation.property === \'path\') {\n                var properties = void 0;\n                if (animation.values) {\n                    properties = {\n                        values: Array.isArray(animation.values)\n                            ? animation.values.map(function (value) {\n                                return _this.getPathFromCommands("".concat(value));\n                            }).join(\';\')\n                            : _this.getPathFromCommands("".concat(animation.values))\n                    };\n                }\n                else {\n                    properties = {\n                        from: _this.getPathFromCommands("".concat(animation.from)),\n                        to: _this.getPathFromCommands("".concat(animation.to))\n                    };\n                }\n                if (!animation.element) {\n                    animation.element = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.animate);\n                }\n                if (!animation.element.parentNode) {\n                    _this.element.appendChild(animation.element);\n                }\n                _this.addAnimationBasicProperties(\'d\', animation);\n                addSVGProperties(animation.element, properties);\n            }\n        });\n    };\n    IsometricPath.prototype.getCommands = function () {\n        return this.commands;\n    };\n    Object.defineProperty(IsometricPath.prototype, "autoclose", {\n        get: function () {\n            return this._autoclose;\n        },\n        set: function (value) {\n            this._autoclose = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IsometricPath.prototype.update = function () {\n        this.updateGraphic(undefined, this.autoclose);\n        return this;\n    };\n    IsometricPath.prototype.clear = function () {\n        this.commands.splice(0);\n        addSVGProperties(this.element, {\n            d: \'\'\n        });\n        return this;\n    };\n    IsometricPath.prototype.moveTo = function (right, left, top) {\n        this.commands.push({\n            command: Command.move,\n            point: { r: right, l: left, t: top }\n        });\n        this.update();\n        return this;\n    };\n    IsometricPath.prototype.lineTo = function (right, left, top) {\n        this.commands.push({\n            command: Command.line,\n            point: { r: right, l: left, t: top }\n        });\n        this.update();\n        return this;\n    };\n    IsometricPath.prototype.curveTo = function (controlRight, controlLeft, controlTop, right, left, top) {\n        this.commands.push({\n            command: Command.curve,\n            control: { r: controlRight, l: controlLeft, t: controlTop },\n            point: { r: right, l: left, t: top }\n        });\n        this.update();\n        return this;\n    };\n    IsometricPath.prototype.mt = function (right, left, top) {\n        return this.moveTo(right, left, top);\n    };\n    IsometricPath.prototype.lt = function (right, left, top) {\n        return this.lineTo(right, left, top);\n    };\n    IsometricPath.prototype.ct = function (controlRight, controlLeft, controlTop, right, left, top) {\n        return this.curveTo(controlRight, controlLeft, controlTop, right, left, top);\n    };\n    IsometricPath.prototype.draw = function (commands) {\n        this.commands = parseDrawCommands(commands);\n        this.update();\n        return this;\n    };\n    IsometricPath.prototype.addAnimation = function (animation) {\n        return _super.prototype.addAnimation.call(this, animation);\n    };\n    return IsometricPath;\n}(IsometricPathAbstract));\n\n\n;// ./src/@classes/public/IsometricPath/index.ts\n\n\n;// ./src/@classes/public/IsometricText/IsometricText.ts\nvar IsometricText_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar IsometricText_assign = (undefined && undefined.__assign) || function () {\n    IsometricText_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return IsometricText_assign.apply(this, arguments);\n};\nvar IsometricText_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\nvar IsometricText = (function (_super) {\n    IsometricText_extends(IsometricText, _super);\n    function IsometricText(props) {\n        var _a;\n        var _this = this;\n        var planeView = props.planeView, _b = props.text, text = _b === void 0 ? \'\' : _b, _c = props.fontFamily, fontFamily = _c === void 0 ? \'Arial\' : _c, _d = props.fontSize, fontSize = _d === void 0 ? 12 : _d, _e = props.fontStyle, fontStyle = _e === void 0 ? \'normal\' : _e, _f = props.fontWeight, fontWeight = _f === void 0 ? \'normal\' : _f, _g = props.origin, origin = _g === void 0 ? [\'center\', \'center\'] : _g, _h = props.right, right = _h === void 0 ? 0 : _h, _j = props.left, left = _j === void 0 ? 0 : _j, _k = props.top, top = _k === void 0 ? 0 : _k, _l = props.rotation, rotation = _l === void 0 ? 0 : _l, _m = props.selectable, selectable = _m === void 0 ? true : _m, rest = IsometricText_rest(props, ["planeView", "text", "fontFamily", "fontSize", "fontStyle", "fontWeight", "origin", "right", "left", "top", "rotation", "selectable"]);\n        _this = _super.call(this, rest, SVG_ELEMENTS.group) || this;\n        _this._originHash = (_a = {},\n            _a[ORIGIN.CENTER] = \'middle\',\n            _a[ORIGIN.LEFT] = \'start\',\n            _a[ORIGIN.RIGHT] = \'end\',\n            _a[ORIGIN.TOP] = \'hanging\',\n            _a[ORIGIN.BOTTOM] = \'baseline\',\n            _a);\n        _this.commonAnimationAttributes = {\n            attributeName: \'transform\',\n            attributeType: \'XML\',\n            additive: \'sum\',\n            fill: \'freeze\'\n        };\n        _this.getMatrixTransform = function (props) {\n            var transformMatrix = getPatternTransform(_this.getPositionTransform(props), _this.planeView, 1);\n            return "".concat(transformMatrix, " rotate(").concat(_this.rotation, ")");\n        };\n        _this._textElement = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.text);\n        _this._tspan = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.tspan);\n        _this._textElement.appendChild(_this._tspan);\n        _this.element.appendChild(_this._textElement);\n        _this.planeView = planeView;\n        _this.fontFamily = fontFamily;\n        _this.fontSize = fontSize;\n        _this.fontStyle = fontStyle;\n        _this.fontWeight = fontWeight;\n        _this.selectable = selectable;\n        _this.origin = origin;\n        _this.right = right;\n        _this.left = left;\n        _this.top = top;\n        _this.rotation = rotation;\n        _this.text = text;\n        return _this;\n    }\n    IsometricText.prototype.getPositionTransform = function (props, fromCenter) {\n        if (fromCenter === void 0) { fromCenter = true; }\n        return getPointFromIsometricPoint(fromCenter\n            ? this.data.centerX\n            : 0, fromCenter\n            ? this.data.centerY\n            : 0, {\n            r: props.right,\n            l: props.left,\n            t: props.top\n        }, this.data.scale);\n    };\n    IsometricText.prototype.updateSubClassAnimations = function () {\n        var _this = this;\n        var props = {\n            right: 0,\n            left: 0,\n            top: 0,\n            rotation: 0,\n        };\n        this.animations.forEach(function (animation) {\n            var isNativeSVGProperty = isSVGProperty(animation.property);\n            if (!isNativeSVGProperty) {\n                if (Object.prototype.hasOwnProperty.call(props, animation.property)) {\n                    var property_1 = animation.property;\n                    var isRotation_1 = property_1 === \'rotation\';\n                    var commonProps = IsometricText_assign(IsometricText_assign({}, _this.commonAnimationAttributes), { type: isRotation_1\n                            ? \'rotate\'\n                            : \'translate\', begin: \'indefinite\' });\n                    var properties = void 0;\n                    if (animation.values) {\n                        if (Array.isArray(animation.values)) {\n                            properties = IsometricText_assign({ values: animation.values.map(function (value) {\n                                    if (isRotation_1) {\n                                        return "".concat(value);\n                                    }\n                                    else {\n                                        var modifiedArgs = IsometricText_assign({}, props);\n                                        modifiedArgs[property_1] = +value - _this[property_1];\n                                        var coords = _this.getPositionTransform(modifiedArgs, false);\n                                        return "".concat(coords.x, ",").concat(coords.y);\n                                    }\n                                }).join(\';\') }, commonProps);\n                        }\n                        else {\n                            if (isRotation_1) {\n                                properties = IsometricText_assign({ values: "".concat(animation.values) }, commonProps);\n                            }\n                            else {\n                                var modifiedArgs = IsometricText_assign({}, props);\n                                modifiedArgs[property_1] = +animation.values - _this[property_1];\n                                var coords = _this.getPositionTransform(modifiedArgs, false);\n                                properties = IsometricText_assign({ values: "".concat(coords.x, ",").concat(coords.y) }, commonProps);\n                            }\n                        }\n                    }\n                    else {\n                        if (isRotation_1) {\n                            properties = IsometricText_assign({ from: "".concat(animation.from), to: "".concat(animation.to) }, commonProps);\n                        }\n                        else {\n                            var fromArgs = IsometricText_assign({}, props);\n                            var toArgs = IsometricText_assign({}, props);\n                            fromArgs[property_1] = +animation.from - _this[property_1];\n                            toArgs[property_1] = +animation.to - _this[property_1];\n                            var coordsFrom = _this.getPositionTransform(fromArgs, false);\n                            var coordsTo = _this.getPositionTransform(toArgs, false);\n                            properties = IsometricText_assign({ from: "".concat(coordsFrom.x, ",").concat(coordsFrom.y), to: "".concat(coordsTo.x, ",").concat(coordsTo.y) }, commonProps);\n                        }\n                    }\n                    if (!animation.element) {\n                        animation.element = document.createElementNS(SVG_NAMESPACE, SVG_ELEMENTS.animateTransform);\n                    }\n                    _this.addAnimationBasicProperties(\'transform\', animation);\n                    addSVGProperties(animation.element, properties);\n                    if (!animation.element.parentNode) {\n                        if (isRotation_1) {\n                            _this._textElement.appendChild(animation.element);\n                        }\n                        else {\n                            _this.element.appendChild(animation.element);\n                        }\n                    }\n                    window.requestAnimationFrame(function () {\n                        animation.element.beginElement();\n                    });\n                }\n            }\n        });\n    };\n    IsometricText.prototype.update = function () {\n        if (elementHasSVGParent(this.element)) {\n            var transform = this.getMatrixTransform({\n                right: this.right,\n                left: this.left,\n                top: this.top\n            });\n            addSVGProperties(this._textElement, { transform: transform });\n            this._tspan.textContent = this._text;\n            this.updatePatternTransform({ x: 0, y: 0 }, this.planeView);\n            this.updateAnimations();\n        }\n        return this;\n    };\n    IsometricText.prototype.clear = function () {\n        this.text = \'\';\n        this.update();\n        return this;\n    };\n    Object.defineProperty(IsometricText.prototype, "text", {\n        get: function () {\n            return this._text;\n        },\n        set: function (value) {\n            this._text = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "planeView", {\n        get: function () {\n            return this._planeView;\n        },\n        set: function (value) {\n            this._planeView = value;\n            this.update();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "fontFamily", {\n        get: function () {\n            return this._fontFamily;\n        },\n        set: function (value) {\n            this._fontFamily = value;\n            addSVGProperties(this._tspan, {\n                \'font-family\': this._fontFamily\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "fontSize", {\n        get: function () {\n            return this._fontSize;\n        },\n        set: function (value) {\n            this._fontSize = value;\n            addSVGProperties(this._tspan, {\n                \'font-size\': "".concat(this._fontSize, "px")\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "fontStyle", {\n        get: function () {\n            return this._fontStyle;\n        },\n        set: function (value) {\n            this._fontStyle = value;\n            addSVGProperties(this._tspan, {\n                \'font-style\': "".concat(this._fontStyle)\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "fontWeight", {\n        get: function () {\n            return this._fontWeight;\n        },\n        set: function (value) {\n            this._fontWeight = value;\n            addSVGProperties(this._tspan, {\n                \'font-weight\': "".concat(this._fontWeight)\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "selectable", {\n        get: function () {\n            return this._selectable;\n        },\n        set: function (value) {\n            this._selectable = value;\n            if (this._selectable) {\n                this._textElement.removeAttribute(\'style\');\n            }\n            else {\n                addSVGProperties(this._textElement, {\n                    style: [\n                        \'-webkit-user-select\',\n                        \'-moz-user-select\',\n                        \'-ms-user-select\',\n                        \'user-select\',\n                        \'pointer-events\'\n                    ].map(function (decl) { return "".concat(decl, ": none"); }).join(\';\')\n                });\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "origin", {\n        get: function () {\n            return this._origin;\n        },\n        set: function (value) {\n            this._origin = value;\n            var _a = this._origin, textAnchor = _a[0], alignmentBaseline = _a[1];\n            addSVGProperties(this._tspan, {\n                \'text-anchor\': this._originHash[textAnchor],\n                \'alignment-baseline\': this._originHash[alignmentBaseline]\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "right", {\n        get: function () {\n            return this._right;\n        },\n        set: function (value) {\n            if (this._right !== value) {\n                this._right = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "left", {\n        get: function () {\n            return this._left;\n        },\n        set: function (value) {\n            if (this._left !== value) {\n                this._left = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "top", {\n        get: function () {\n            return this._top;\n        },\n        set: function (value) {\n            if (this._top !== value) {\n                this._top = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsometricText.prototype, "rotation", {\n        get: function () {\n            return this._rotation;\n        },\n        set: function (value) {\n            if (this._rotation !== value) {\n                this._rotation = value;\n                this.update();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return IsometricText;\n}(IsometricGraphicAbstract));\n\n\n;// ./src/@classes/public/IsometricText/index.ts\n\n\n;// ./src/index.ts\n\n\n\n\n\n\n\n\n\n\n;// ./demo/demo1/index.js\n/* harmony default export */ const demo1 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricRectangle, PlaneView } = IsometricModule;\n\n    function toggleColor() {\n        this.fillColor = this.fillColor === \'white\' ? \'#EEE\' : \'white\';\n    }\n\n    const cube = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const commonProps = {height: 1, width: 1};\n    const topPiece = new IsometricRectangle({...commonProps, planeView: PlaneView.TOP});\n    const rightPiece = new IsometricRectangle({...commonProps, planeView: PlaneView.FRONT});\n    const leftPiece = new IsometricRectangle({...commonProps, planeView: PlaneView.SIDE});\n\n    topPiece.top = 1;\n    topPiece.addEventListener(\'click\', toggleColor, true);\n\n    rightPiece.right = 1;\n    rightPiece.addEventListener(\'click\', toggleColor, true);\n\n    leftPiece.left = 1;\n    leftPiece.addEventListener(\'click\', toggleColor, true);\n\n    cube\n        .addChild(topPiece)\n        .addChild(rightPiece)\n        .addChild(leftPiece);\n\n});\n;// ./demo/demo2/index.js\n/* harmony default export */ const demo2 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricPath, IsometricRectangle, IsometricPentagram, PlaneView } = IsometricModule;\n\n    const cube = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const commonProps = {height: 1, width: 1};\n\n    const duration = 3;\n\n    const rectangleAnimationProps = {\n        property: \'height\',\n        duration,\n        values: [1, 0.5, 1]\n    };\n\n    const colorAnimationProps = {\n        property: \'fillColor\',\n        duration,\n        values: [\'#FFF\', \'#DDD\', \'#FFF\']\n    };\n\n    const topPiece = new IsometricPath();\n    const star = new IsometricPentagram({ radius: 0.35, planeView: PlaneView.TOP, right: 0.5, left: 0.5, top: 1});\n    const rightPiece = new IsometricRectangle({...commonProps, planeView: PlaneView.FRONT, right: 1});\n    const leftPiece = new IsometricRectangle({...commonProps, planeView: PlaneView.SIDE, left: 1});\n\n    topPiece\n        .moveTo(0, 0, 1)\n        .lineTo(1, 0, 1)\n        .lineTo(1, 1, 1)\n        .lineTo(0, 1, 1);\n\n    topPiece\n        .addAnimation({\n            property: \'path\',\n            duration,\n            values: [\n                \'M0 0 1 L1 0 1 L1 1 1 L0 1 1\',\n                \'M0 0 0.5 L1 0 0.5 L1 1 0.5 L0 1 0.5\',\n                \'M0 0 1 L1 0 1 L1 1 1 L0 1 1\'\n            ]\n        })\n        .addAnimation(colorAnimationProps);\n\n    star\n        .addAnimation({\n            property: \'top\',\n            duration,\n            values: [1, 0.5, 1]\n        });\n\n    rightPiece\n        .addAnimation(rectangleAnimationProps)\n        .addAnimation(colorAnimationProps);\n\n    leftPiece\n        .addAnimation(rectangleAnimationProps)\n        .addAnimation(colorAnimationProps);\n\n    cube.addEventListener(\'click\', function() {\n        if (this.animated) {\n            this.pauseAnimations();\n        } else {\n            this.resumeAnimations();\n        }\n    });\n\n    cube.addChildren(topPiece, rightPiece, leftPiece, star);\n\n});\n;// ./demo/images/block_side.png\nconst block_side_namespaceObject = __webpack_require__.p + "images/block_side.png";\n;// ./demo/images/block_top.png\nconst block_top_namespaceObject = __webpack_require__.p + "images/block_top.png";\n;// ./demo/demo3/index.js\n\n\n\n/* harmony default export */ const demo3 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricRectangle, IsometricText, PlaneView } = IsometricModule;\n\n    const cube = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const rectangleCommonProps = { height: 1, width: 1 };\n\n    const textCommonProps = {\n        fontSize: 15,\n        fillColor: \'#666\',\n        strokeWidth: 0,\n        right: 0.5,\n        left: 0.5,\n        top: 0.5,\n        selectable: false\n    };\n\n    const pieces = [PlaneView.TOP, PlaneView.FRONT, PlaneView.SIDE].map((view, index) => {\n        return {\n            face: new IsometricRectangle({...rectangleCommonProps, planeView: view}),\n            label: new IsometricText({...textCommonProps, planeView: view}),\n            property: [\'top\', \'right\', \'left\'][index]\n        };\n    });\n\n    pieces.forEach((piece) => {\n\n        const { face, label, property } = piece;\n\n        face[property] = 1;\n        label[property] = 1;\n        label.text = `${property.toUpperCase()} 0`;\n\n        face.addEventListener(\'click\', () => {\n            const rotation = label.rotation + 45;\n            label.rotation = rotation === 360 ? 0 : rotation;\n            label.text = label.text.replace(/\\d+/, label.rotation);\n        });\n\n        cube.addChild(piece.face);\n        cube.addChild(piece.label);\n    });\n\n});\n;// ./demo/demo4/index.js\n/* harmony default export */ const demo4 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricGroup, IsometricPath } = IsometricModule;\n\n    const isometric = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const bottomT = new IsometricPath();\n    const bottomR = new IsometricPath();\n    const bottomL = new IsometricPath();\n\n    const topT = new IsometricPath();\n    const topR = new IsometricPath();\n    const topL = new IsometricPath();\n\n    bottomT.mt(0, 0, .5).lt(1, 0, .5).lt(1, 1, .5).lt(0, 1, .5);\n    bottomR.mt(1, 0, .5).lt(1, 0, 0).lt(1, 1, 0).lt(1, 1, .5);\n    bottomL.mt(1, 1, .5).lt(1, 1, 0).lt(0, 1, 0).lt(0, 1, .5);\n\n    topT.mt(.25, .25, 1).lt(.75, .25, 1).lt(.75, .75, .75).lt(.25, .75, .75);\n    topR.mt(.75, .25, 1).lt(.75, .75, .75).lt(.75, .75, .25).lt(.75, .25, .25);\n    topL.mt(.75, .75, .75).lt(.25, .75, .75).lt(.25, .75, .25).lt(.75, .75, .25);\n\n    const bottomPiece = new IsometricGroup();\n    const topPiece = new IsometricGroup();\n    topPiece.top = .25;\n\n    bottomPiece.addChildren(bottomT, bottomR, bottomL);\n    topPiece.addChildren(topT, topR, topL);\n\n    let flip = true;\n\n    topPiece.addEventListener(\'click\', function() {\n        if (this.right) {\n            this.right = 0;\n            return;\n        }\n        this.right = flip ? 0.25 : -0.25;\n        flip = !flip;\n    });\n\n    isometric.addChildren(bottomPiece, topPiece);\n\n});\n;// ./demo/demo5/index.js\n/* harmony default export */ const demo5 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricPath } = IsometricModule;\n\n    const isometric = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const right = new IsometricPath();\n    const top1 = new IsometricPath();\n    const top2 = new IsometricPath();\n    const top3 = new IsometricPath();\n    const top4 = new IsometricPath();\n    const left1 = new IsometricPath();\n    const left2 = new IsometricPath();\n\n    // M r l t (Move to right left top)\n    // L r l t (Line to right left top)\n    // C cr cl ct r l t (Curve to control-right control-left control-top right left top)\n    right.draw(\'M1 0 0 L1 1 0 L1 1 0.25 L1 0.5 0.25 L1 0.5 1 L1 0 1\');\n    top1.draw(\'M0.25 0.5 1 C0.5 0.5 0.75 0.75 0.5 1 L0.75 0 1 C0.5 0 0.75 0.25 0 1 L0.25 0.5 1\');\n    top2.draw(\'M1 0 1 L0.75 0 1 L0.75 0.5 1 L1 0.5 1 L1 0 1 M0 0 1 L0.25 0 1 L0.25 0.5 1 L0 0.5 1 L0 0 1\');\n    top3.draw(\'M0 0.5 0.5 L0.5 0.5 0.5 L0.5 1 0.5 L0 1 0.5\');\n    top4.draw(\'M0.5 0.5 0.5 L1 0.5 0.25 L1 1 0.25 L0.5 1 0.5\');\n    left1.draw(\'M0 0.5 1 L0 0.5 0.5 L0.5 0.5 0.5 L1 0.5 0.25 L1 0.5 1 L0.75 0.5 1 C0.5 0.5 0.75 0.25 0.5 1 L0 0.5 1\');\n    left2.draw(\'M0 1 0.5 L0.5 1 0.5 L1 1 0.25 L1 1 0 L0 1 0\');\n\n    isometric.addChildren(right, top1, top2, top3, top4, left1, left2);\n\n});\n;// ./demo/demo6/index.js\n/* harmony default export */ const demo6 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricPath } = IsometricModule;\n\n    const cube = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const under = new IsometricPath({ fillColor: \'#EEE\' });\n    const top = new IsometricPath();\n    const right = new IsometricPath();\n    const left = new IsometricPath();\n\n    under\n        .mt(0, 0, 1)\n        .mt(0.25, 0, 1).ct(0.5, 0, 0.75, 0.75, 0, 1).lt(1, 0, 1)\n        .lt(1, 0, 0.75).ct(0.75, 0, 0.5, 1, 0, 0.25).lt(1, 0, 0)\n        .lt(1, 0.25, 0).ct(0.75, 0.5, 0, 1, 0.75, 0).lt(1, 1, 0)\n        .lt(0.75, 1, 0).ct(0.5, 0.75, 0, 0.25, 1, 0).lt(0, 1, 0)\n        .lt(0, 1, 0.25).ct(0, 0.75, 0.5, 0, 1, 0.75).lt(0, 1, 1)\n        .lt(0, 0.75, 1).ct(0, 0.5, 0.75, 0, 0.25, 1).lt(0, 0, 1);\n\n    top\n        .mt(0, 0, 1)\n        .lt(0.25, 0, 1).ct(0.5, 0.25, 1, 0.75, 0, 1).lt(1, 0, 1)\n        .lt(1, 0.25, 1).ct(0.75, 0.5, 1, 1, 0.75, 1).lt(1, 1, 1)\n        .lt(0.75, 1, 1).ct(0.5, 0.75, 1, 0.25, 1, 1).lt(0, 1, 1)\n        .lt(0, 0.75, 1).ct(0.25, 0.5, 1, 0, 0.25, 1).lt(0, 0, 1);\n\n    right\n        .mt(1, 0, 1)\n        .lt(1, 0, 0.75).ct(1, 0.25, 0.5, 1, 0, 0.25).lt(1, 0, 0)\n        .lt(1, 0.25, 0).ct(1, 0.5, 0.25, 1, 0.75, 0).lt(1, 1, 0)\n        .lt(1, 1, 0.25).ct(1, 0.75, 0.5, 1, 1, 0.75).lt(1, 1, 1)\n        .lt(1, 0.75, 1).ct(1, 0.5, 0.75, 1, 0.25, 1).lt(1, 0, 1);\n\n    left\n        .mt(1, 1, 1)\n        .lt(1, 1, 0.75).ct(0.75, 1, 0.5, 1, 1, 0.25).lt(1, 1, 0)\n        .lt(0.75, 1, 0).ct(0.5, 1, 0.25, 0.25, 1, 0).lt(0, 1, 0)\n        .lt(0, 1, 0.25).ct(0.25, 1, 0.5, 0, 1, 0.75).lt(0, 1, 1)\n        .lt(0.25, 1, 1).ct(0.5, 1, 0.75, 0.75, 1, 1).lt(1, 1, 1);\n\n    cube.addChildren(under, top, right, left);\n\n});\n;// ./demo/demo7/index.js\n/* harmony default export */ const demo7 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricStarPolygon, PlaneView } = IsometricModule;\n\n    const cube = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const commonProps = {\n        radius: 0.5,\n        points: 8,\n        density: 2,\n        right: 0.5,\n        left: 0.5,\n        top: 0.5\n    };\n\n    const planes = [PlaneView.SIDE, PlaneView.FRONT, PlaneView.TOP];\n\n    const planePropsHash = {\n        [PlaneView.TOP]: \'top\',\n        [PlaneView.FRONT]: \'right\',\n        [PlaneView.SIDE]: \'left\'\n    };\n\n    planes.forEach((planeView) => {\n        const props = { ...commonProps, planeView };\n        const coord = planePropsHash[planeView];\n        const starPolygonBack = new IsometricStarPolygon({...props, id: `${coord}-back`, fillColor: \'#EEE\'});\n        const starPolygonFront = new IsometricStarPolygon({...props, id: `${coord}-front`});\n        starPolygonBack[coord] = 0;\n        starPolygonFront[coord] = 1;\n        cube.addChildren(starPolygonBack, starPolygonFront);\n    });\n\n    planes.forEach((planeView) => {\n        const coord = planePropsHash[planeView];\n        const starPolygonBack = cube.getChildById(`${coord}-back`);\n        const starPolygonFront = cube.getChildById(`${coord}-front`);\n        cube.sendChildToBack(starPolygonBack);\n        cube.bringChildToFront(starPolygonFront);\n    });\n\n});\n;// ./demo/demo8/index.js\n/* harmony default export */ const demo8 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricGroup, IsometricRectangle, PlaneView } = IsometricModule;\n\n    const canvas = new IsometricCanvas({\n        container,\n        backgroundColor: \'#CCC\',\n        scale: 20,\n        width: 500,\n        height: 320\n    });\n\n    function resetPlanes() {\n        cube.right = cube.left = cube.top = 0;\n        planeTop.fillOpacity = planeRight.fillOpacity = planeLeft.fillOpacity = 0.25;\n    }\n\n    function changePlane() {\n        resetPlanes();\n        this.fillOpacity = 1;\n        cube.drag = this.planeView;\n    }\n\n    const planeProps = { height: 6, width: 6, fillOpacity: 0.25 };\n    const planeTop = new IsometricRectangle({ ...planeProps, planeView: PlaneView.TOP, fillOpacity: 1 });\n    const planeRight = new IsometricRectangle({ ...planeProps, planeView: PlaneView.FRONT });\n    const planeLeft = new IsometricRectangle({ ...planeProps, planeView: PlaneView.SIDE });\n\n    const cubeProps = { height: 1, width: 1 };\n    const cubeTop = new IsometricRectangle({ ...cubeProps, planeView: PlaneView.TOP, top: 1 });\n    const cubeRight = new IsometricRectangle({ ...cubeProps, planeView: PlaneView.FRONT, right: 1 });\n    const cubeLeft = new IsometricRectangle({ ...cubeProps, planeView: PlaneView.SIDE, left: 1 });\n\n    const cube = new IsometricGroup();\n\n    const bounds = [0, 5];\n    cube.drag = \'TOP\';\n    cube.bounds = { top: bounds, right: bounds, left: bounds };\n\n    planeTop.addEventListener(\'click\', changePlane, true);\n    planeRight.addEventListener(\'click\', changePlane, true);\n    planeLeft.addEventListener(\'click\', changePlane, true);\n\n    cube.addChildren(cubeTop, cubeRight, cubeLeft);\n    canvas.addChildren(planeTop, planeRight, planeLeft, cube);\n\n});\n;// ./demo/demo9/index.js\n\n\n\n/* harmony default export */ const demo9 = (( IsometricModule, container ) => {\n\n    const { IsometricCanvas, IsometricPath, IsometricRectangle, PlaneView, Axis } = IsometricModule;\n\n    const isometric = new IsometricCanvas({\n        container,\n        backgroundColor: \'#8AAA3F\',\n        scale: 120,\n        width: 500,\n        height: 320\n    });\n\n    const commonTextureProps = {\n        height: 1,\n        width: 1,\n        pixelated: true\n    };\n\n    const textureSides = {\n        url: \'images/block_side.png\',\n        ...commonTextureProps\n    };\n\n    const textureTop = {\n        url: \'images/block_top.png\',\n        planeView: PlaneView.TOP,\n        rotation: {\n            axis: Axis.LEFT,\n            value: 26.5650\n        },\n        ...commonTextureProps\n    };\n\n    const side = new IsometricPath({\n        texture: {\n            planeView: PlaneView.SIDE,\n            ...textureSides\n        }\n    });\n\n    const front = new IsometricRectangle({\n        planeView: PlaneView.FRONT,\n        height: 0.5,\n        width: 1,\n        texture: textureSides\n    });\n\n    const chop = new IsometricPath({\n        texture: textureTop\n    });\n\n    side.draw(\'M1 1 0 L1 1 0.5 L0 1 1 L0 1 0\');\n    chop.draw(\'M1 1 0.5 L0 1 1 L0 0 1 L1 0 0.5\');\n\n    side.left = 1;\n    front.right = 1;\n\n    isometric.addChildren(side, front, chop);\n\n});\n;// ./demo/demo.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst functioToString = (fn) => {\n    const article = document.createElement(\'article\');\n    const pre = document.createElement(\'pre\');\n    article.classList.add(\'function-container\');\n    pre.classList.add(\'prettyprint\');\n    article.appendChild(pre);\n    pre.innerHTML = fn.toString();\n    return article;\n};\n\nconst demos = new Map([\n    [\'demo1\', demo1],\n    [\'demo2\', demo2],\n    [\'demo3\', demo3],\n    [\'demo4\', demo4],\n    [\'demo5\', demo5],\n    [\'demo6\', demo6],\n    [\'demo7\', demo7],\n    [\'demo8\', demo8],\n    [\'demo9\', demo9],\n]);\n\ndocument.addEventListener(\'DOMContentLoaded\', function () {\n\n    demos.forEach((module, div) => {\n        const demo = document.getElementById(div);\n        const container = document.createElement(\'div\');\n        const wrapper = document.createElement(\'div\');\n\n        container.classList.add(\'demo-container\');\n        wrapper.classList.add(\'demo-wrapper\');\n\n        module(src_namespaceObject, wrapper);\n        container.appendChild(wrapper);\n        demo.appendChild(container);\n        demo.appendChild(functioToString(module));\n    });\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFOztBQzlEa0Q7QUFDZ0I7QUFDdkM7QUFDTDtBQUNtQjtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLG1CQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY29uc3RhbnRzL2luZGV4LnRzPzdkZTgiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0B1dGlscy9tYXRoLnRzP2UzNjgiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0B1dGlscy9tYXRyaXgudHM/ZjhjYiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQHV0aWxzL3N2Zy50cz9kMDY0Iiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9Ac3RvcmUvaW5kZXgudHM/ZDY1MiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljU3RvcmUvSXNvbWV0cmljU3RvcmUudHM/ODI5MCIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljU3RvcmUvaW5kZXgudHM/NzE2YyIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljRWxlbWVudEFic3RyYWN0L0lzb21ldHJpY0VsZW1lbnRBYnN0cmFjdC50cz8zZDUyIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNFbGVtZW50QWJzdHJhY3QvaW5kZXgudHM/ZmU2MiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0L0lzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC50cz9mYzUzIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNHcmFwaGljQWJzdHJhY3QvaW5kZXgudHM/NTkzMiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QvSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QudHM/ZDIwNyIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QvaW5kZXgudHM/ZDQwNiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY0NhbnZhcy9Jc29tZXRyaWNDYW52YXMudHM/ZGUxMyIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY0NhbnZhcy9pbmRleC50cz9jOWJiIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AdXRpbHMvb3RoZXIudHM/OTVjNCIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QvY29uc3RhbnRzLnRzPzg4MzMiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0L0lzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnRzPzVkZmYiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0L2luZGV4LnRzP2JkNjciLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNHcm91cC9Jc29tZXRyaWNHcm91cC50cz84ZmZmIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9wdWJsaWMvSXNvbWV0cmljR3JvdXAvaW5kZXgudHM/M2NkYiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljUGF0aEFic3RyYWN0L0lzb21ldHJpY1BhdGhBYnN0cmFjdC50cz8yYWQwIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNQYXRoQWJzdHJhY3QvaW5kZXgudHM/YmI3YiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljU2hhcGVBYnN0cmFjdC9Jc29tZXRyaWNTaGFwZUFic3RyYWN0LnRzPzVlMmUiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY1NoYXBlQWJzdHJhY3QvaW5kZXgudHM/MmUyMSIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY1JlY3RhbmdsZS9Jc29tZXRyaWNSZWN0YW5nbGUudHM/NzMzNyIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY1JlY3RhbmdsZS9pbmRleC50cz9mZWZjIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9wdWJsaWMvSXNvbWV0cmljQ2lyY2xlL0lzb21ldHJpY0NpcmNsZS50cz8zOTljIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9wdWJsaWMvSXNvbWV0cmljQ2lyY2xlL2luZGV4LnRzP2Y2YjEiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QvSXNvbWV0cmljU3RhclBvbHlnb25BYnN0cmFjdC50cz83ZTU5Iiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0L2luZGV4LnRzPzNkZmEiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNQZW50YWdyYW0vSXNvbWV0cmljUGVudGFncmFtLnRzPzY5OTkiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNQZW50YWdyYW0vaW5kZXgudHM/MDFmNiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY1N0YXJQb2x5Z29uL0lzb21ldHJpY1N0YXJQb2x5Z29uLnRzPzNhNDQiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNTdGFyUG9seWdvbi9pbmRleC50cz82MTNjIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL3NyYy9AY2xhc3Nlcy9wdWJsaWMvSXNvbWV0cmljUGF0aC9Jc29tZXRyaWNQYXRoLnRzP2U4MDYiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNQYXRoL2luZGV4LnRzP2YxNzMiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vc3JjL0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNUZXh0L0lzb21ldHJpY1RleHQudHM/MzE2ZiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY1RleHQvaW5kZXgudHM/OTY1YyIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9zcmMvaW5kZXgudHM/YjRjYiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9kZW1vL2RlbW8xL2luZGV4LmpzPzhlMTMiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vZGVtby9kZW1vMi9pbmRleC5qcz83YjZkIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL2RlbW8vZGVtbzMvaW5kZXguanM/NmQ4NyIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9kZW1vL2RlbW80L2luZGV4LmpzPzQ1YWQiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vZGVtby9kZW1vNS9pbmRleC5qcz9iNGIxIiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL2RlbW8vZGVtbzYvaW5kZXguanM/ZmRhNSIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9kZW1vL2RlbW83L2luZGV4LmpzPzBhZmIiLCJ3ZWJwYWNrOi8vQGVsY2hpbmluZXQvaXNvbWV0cmljLy4vZGVtby9kZW1vOC9pbmRleC5qcz80YzA3Iiwid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL2RlbW8vZGVtbzkvaW5kZXguanM/MjE3NiIsIndlYnBhY2s6Ly9AZWxjaGluaW5ldC9pc29tZXRyaWMvLi9kZW1vL2RlbW8uanM/ZmNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuZXhwb3J0IHZhciBTVkdfRUxFTUVOVFM7XG4oZnVuY3Rpb24gKFNWR19FTEVNRU5UUykge1xuICAgIFNWR19FTEVNRU5UU1tcInN2Z1wiXSA9IFwic3ZnXCI7XG4gICAgU1ZHX0VMRU1FTlRTW1wiZ3JvdXBcIl0gPSBcImdcIjtcbiAgICBTVkdfRUxFTUVOVFNbXCJwYXRoXCJdID0gXCJwYXRoXCI7XG4gICAgU1ZHX0VMRU1FTlRTW1wicmVjdFwiXSA9IFwicmVjdFwiO1xuICAgIFNWR19FTEVNRU5UU1tcInRleHRcIl0gPSBcInRleHRcIjtcbiAgICBTVkdfRUxFTUVOVFNbXCJ0c3BhblwiXSA9IFwidHNwYW5cIjtcbiAgICBTVkdfRUxFTUVOVFNbXCJwYXR0ZXJuXCJdID0gXCJwYXR0ZXJuXCI7XG4gICAgU1ZHX0VMRU1FTlRTW1wiaW1hZ2VcIl0gPSBcImltYWdlXCI7XG4gICAgU1ZHX0VMRU1FTlRTW1wiYW5pbWF0ZVwiXSA9IFwiYW5pbWF0ZVwiO1xuICAgIFNWR19FTEVNRU5UU1tcImFuaW1hdGVUcmFuc2Zvcm1cIl0gPSBcImFuaW1hdGVUcmFuc2Zvcm1cIjtcbn0pKFNWR19FTEVNRU5UUyB8fCAoU1ZHX0VMRU1FTlRTID0ge30pKTtcbmV4cG9ydCB2YXIgU1ZHX1BST1BFUlRJRVM7XG4oZnVuY3Rpb24gKFNWR19QUk9QRVJUSUVTKSB7XG4gICAgU1ZHX1BST1BFUlRJRVNbXCJ2aWV3Qm94XCJdID0gXCJ2aWV3Qm94XCI7XG59KShTVkdfUFJPUEVSVElFUyB8fCAoU1ZHX1BST1BFUlRJRVMgPSB7fSkpO1xuZXhwb3J0IHZhciBERUNJTUFMUyA9IDY7XG5leHBvcnQgdmFyIFNRUlQzID0gKyhNYXRoLnNxcnQoMykudG9GaXhlZChERUNJTUFMUykpO1xuZXhwb3J0IHZhciBIU1FSVDMgPSArKChNYXRoLnNxcnQoMykgLyAyKS50b0ZpeGVkKERFQ0lNQUxTKSk7XG5leHBvcnQgdmFyIERFRkFVTFRfV0lEVEggPSA2NDA7XG5leHBvcnQgdmFyIERFRkFVTFRfSEVJR0hUID0gNDgwO1xudmFyIE4gPSAnKC0/XFxcXGQrKD86XFxcXC5cXFxcZCspP3wtP1xcXFwuXFxcXGQrKSc7XG52YXIgUyA9ICdcXFxccyonO1xudmFyIFNTID0gJ1xcXFxzKyc7XG52YXIgUE9JTlQgPSBcIlwiLmNvbmNhdChOKS5jb25jYXQoU1MpLmNvbmNhdChOKS5jb25jYXQoU1MpLmNvbmNhdChOKTtcbnZhciBDVVJWRSA9IFwiXCIuY29uY2F0KFBPSU5UKS5jb25jYXQoU1MpLmNvbmNhdChQT0lOVCk7XG5leHBvcnQgdmFyIENPTU1BTkRTX1JFR0VYUCA9IG5ldyBSZWdFeHAoXCIoPzooTXxMKVwiLmNvbmNhdChTKS5jb25jYXQoUE9JTlQpLmNvbmNhdChTLCBcInwoQylcIikuY29uY2F0KFMpLmNvbmNhdChDVVJWRSwgXCIpXCIpLmNvbmNhdChTKSwgJ2cnKTtcbmV4cG9ydCB2YXIgU0NBTEUgPSBNYXRoLnNxcnQoMyAvIDIpO1xuZXhwb3J0IHZhciBST1RfNjAgPSBNYXRoLlBJIC8gMztcbmV4cG9ydCB2YXIgUk9UXzQ1ID0gTWF0aC5QSSAvIDQ7XG5leHBvcnQgdmFyIFJPVF9DTUEgPSBNYXRoLmF0YW4oTWF0aC5TUVJUMik7XG5leHBvcnQgdmFyIENvbG9ycztcbihmdW5jdGlvbiAoQ29sb3JzKSB7XG4gICAgQ29sb3JzW1wid2hpdGVcIl0gPSBcIndoaXRlXCI7XG4gICAgQ29sb3JzW1wiYmxhY2tcIl0gPSBcImJsYWNrXCI7XG59KShDb2xvcnMgfHwgKENvbG9ycyA9IHt9KSk7XG5leHBvcnQgdmFyIExpbmVDYXA7XG4oZnVuY3Rpb24gKExpbmVDYXApIHtcbiAgICBMaW5lQ2FwW1wiYnV0dFwiXSA9IFwiYnV0dFwiO1xuICAgIExpbmVDYXBbXCJzcXVhcmVcIl0gPSBcInNxdWFyZVwiO1xuICAgIExpbmVDYXBbXCJyb3VuZFwiXSA9IFwicm91bmRcIjtcbn0pKExpbmVDYXAgfHwgKExpbmVDYXAgPSB7fSkpO1xuZXhwb3J0IHZhciBMaW5lSm9pbjtcbihmdW5jdGlvbiAoTGluZUpvaW4pIHtcbiAgICBMaW5lSm9pbltcIm1pdGVyXCJdID0gXCJtaXRlclwiO1xuICAgIExpbmVKb2luW1wicm91bmRcIl0gPSBcInJvdW5kXCI7XG4gICAgTGluZUpvaW5bXCJiZXZlbFwiXSA9IFwiYmV2ZWxcIjtcbn0pKExpbmVKb2luIHx8IChMaW5lSm9pbiA9IHt9KSk7XG5leHBvcnQgdmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICBDb21tYW5kW1wibW92ZVwiXSA9IFwibW92ZVwiO1xuICAgIENvbW1hbmRbXCJsaW5lXCJdID0gXCJsaW5lXCI7XG4gICAgQ29tbWFuZFtcImN1cnZlXCJdID0gXCJjdXJ2ZVwiO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG5leHBvcnQgdmFyIFBsYW5lVmlldztcbihmdW5jdGlvbiAoUGxhbmVWaWV3KSB7XG4gICAgUGxhbmVWaWV3W1wiRlJPTlRcIl0gPSBcIkZST05UXCI7XG4gICAgUGxhbmVWaWV3W1wiU0lERVwiXSA9IFwiU0lERVwiO1xuICAgIFBsYW5lVmlld1tcIlRPUFwiXSA9IFwiVE9QXCI7XG59KShQbGFuZVZpZXcgfHwgKFBsYW5lVmlldyA9IHt9KSk7XG5leHBvcnQgdmFyIEF4aXM7XG4oZnVuY3Rpb24gKEF4aXMpIHtcbiAgICBBeGlzW1wiUklHSFRcIl0gPSBcIlJJR0hUXCI7XG4gICAgQXhpc1tcIkxFRlRcIl0gPSBcIkxFRlRcIjtcbiAgICBBeGlzW1wiVE9QXCJdID0gXCJUT1BcIjtcbn0pKEF4aXMgfHwgKEF4aXMgPSB7fSkpO1xuZXhwb3J0IHZhciBUeXBlb2Y7XG4oZnVuY3Rpb24gKFR5cGVvZikge1xuICAgIFR5cGVvZltcIlVOREVGSU5FRFwiXSA9IFwidW5kZWZpbmVkXCI7XG4gICAgVHlwZW9mW1wiTlVNQkVSXCJdID0gXCJudW1iZXJcIjtcbn0pKFR5cGVvZiB8fCAoVHlwZW9mID0ge30pKTtcbmV4cG9ydCB2YXIgRVZFTlRTO1xuKGZ1bmN0aW9uIChFVkVOVFMpIHtcbiAgICBFVkVOVFNbXCJNT1VTRV9NT1ZFXCJdID0gXCJtb3VzZW1vdmVcIjtcbiAgICBFVkVOVFNbXCJNT1VTRV9ET1dOXCJdID0gXCJtb3VzZWRvd25cIjtcbiAgICBFVkVOVFNbXCJNT1VTRV9VUFwiXSA9IFwibW91c2V1cFwiO1xuICAgIEVWRU5UU1tcIlRPVUNIX1NUQVJUXCJdID0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgRVZFTlRTW1wiVE9VQ0hfTU9WRVwiXSA9IFwidG91Y2htb3ZlXCI7XG4gICAgRVZFTlRTW1wiVE9VQ0hfRU5EXCJdID0gXCJ0b3VjaGVuZFwiO1xufSkoRVZFTlRTIHx8IChFVkVOVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBPUklHSU47XG4oZnVuY3Rpb24gKE9SSUdJTikge1xuICAgIE9SSUdJTltcIkNFTlRFUlwiXSA9IFwiY2VudGVyXCI7XG4gICAgT1JJR0lOW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICAgIE9SSUdJTltcIlJJR0hUXCJdID0gXCJyaWdodFwiO1xuICAgIE9SSUdJTltcIlRPUFwiXSA9IFwidG9wXCI7XG4gICAgT1JJR0lOW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbn0pKE9SSUdJTiB8fCAoT1JJR0lOID0ge30pKTtcbiIsImltcG9ydCB7IEhTUVJUMywgREVDSU1BTFMgfSBmcm9tICdAY29uc3RhbnRzJztcbmV4cG9ydCB2YXIgcm91bmQgPSBmdW5jdGlvbiAobiwgZCkge1xuICAgIHZhciBleHAgPSBNYXRoLnBvdygxMCwgZCk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobiAqIGV4cCkgLyBleHA7XG59O1xuZXhwb3J0IHZhciByYWRpYW4gPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSAqIE1hdGguUEkgLyAxODA7IH07XG5leHBvcnQgdmFyIHNpbmNvcyA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiAoe1xuICAgIHNpbjogcm91bmQoTWF0aC5zaW4ociksIERFQ0lNQUxTKSxcbiAgICBjb3M6IHJvdW5kKE1hdGguY29zKHIpLCBERUNJTUFMUylcbn0pOyB9O1xudmFyIGdldFBvaW50c0RpZmYgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpIHsgcmV0dXJuICh7XG4gICAgeDogcG9pbnRBLnggLSBwb2ludEIueCxcbiAgICB5OiBwb2ludEEueSAtIHBvaW50Qi55XG59KTsgfTtcbnZhciBnZXRQb2ludHNEaXN0YW5jZSA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qikge1xuICAgIHZhciBkaWZmID0gZ2V0UG9pbnRzRGlmZihwb2ludEEsIHBvaW50Qik7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkaWZmLngsIDIpICsgTWF0aC5wb3coZGlmZi55LCAyKSk7XG59O1xudmFyIHRyYW5zbGF0ZVBvaW50ID0gZnVuY3Rpb24gKHBvaW50LCBhbmdsZSwgZGlzdGFuY2UpIHsgcmV0dXJuICh7XG4gICAgeDogcG9pbnQueCArIE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlLFxuICAgIHk6IHBvaW50LnkgKyBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZVxufSk7IH07XG52YXIgcm90YXRlID0gZnVuY3Rpb24gKHBvaW50LCBjZW50ZXIsIGFuZ2xlKSB7XG4gICAgdmFyIGRpZmYgPSBnZXRQb2ludHNEaWZmKHBvaW50LCBjZW50ZXIpO1xuICAgIHZhciB4ID0gZGlmZi54ICogTWF0aC5jb3MoYW5nbGUpIC0gZGlmZi55ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5ID0gZGlmZi54ICogTWF0aC5zaW4oYW5nbGUpICsgZGlmZi55ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgeCxcbiAgICAgICAgeTogY2VudGVyLnkgKyB5XG4gICAgfTtcbn07XG52YXIgZ2V0UG9pbnRzQW5nbGUgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpIHtcbiAgICB2YXIgZGlmZiA9IGdldFBvaW50c0RpZmYocG9pbnRCLCBwb2ludEEpO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKGRpZmYueSwgZGlmZi54KTtcbn07XG5leHBvcnQgdmFyIGdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgdmFsdWUgPSAocDIueSAtIHAxLnkpICogKHAzLnggLSBwMi54KSAtIChwMi54IC0gcDEueCkgKiAocDMueSAtIHAyLnkpO1xuICAgIHJldHVybiB2YWx1ZSA+PSAwID8gMCA6IDE7XG59O1xuZXhwb3J0IHZhciBnZXRQb2ludEZyb21Jc29tZXRyaWNQb2ludCA9IGZ1bmN0aW9uIChjZW50ZXJYLCBjZW50ZXJZLCBwb2ludCwgc2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZChjZW50ZXJYICsgKHBvaW50LnIgLSBwb2ludC5sKSAqIHNjYWxlICogSFNRUlQzLCBERUNJTUFMUyksXG4gICAgICAgIHk6IHJvdW5kKGNlbnRlclkgKyAoKHBvaW50LnIgKyBwb2ludC5sKSAvIDIgLSBwb2ludC50KSAqIHNjYWxlLCBERUNJTUFMUylcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgZ2V0VG9wUGxhbmVQb2ludEZyb21Db29yZGluYXRlcyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIFhIU1FSVDMgPSB4IC8gSFNRUlQzO1xuICAgIHZhciByaWdodCA9ICh5ICogMiArIFhIU1FSVDMpIC8gMjtcbiAgICB2YXIgbGVmdCA9IHJpZ2h0IC0gWEhTUVJUMztcbiAgICByZXR1cm4ge1xuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGxlZnQ6IGxlZnRcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgZ2V0RnJvbnRQbGFuZVBvaW50RnJvbUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgbGVmdCA9IC14IC8gSFNRUlQzO1xuICAgIHZhciB0b3AgPSBsZWZ0IC8gMiAtIHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3BcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgZ2V0U2lkZVBsYW5lUG9pbnRGcm9tQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByaWdodCA9IHggLyBIU1FSVDM7XG4gICAgdmFyIHRvcCA9IHJpZ2h0IC8gMiAtIHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB0b3A6IHRvcFxuICAgIH07XG59O1xuZXhwb3J0IHZhciBnZXRFbGxpcHNpc1NwZWNzID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCBjb250cm9sKSB7XG4gICAgdmFyIGRpZmYgPSBnZXRQb2ludHNEaWZmKHBvaW50QiwgcG9pbnRBKTtcbiAgICB2YXIgY2VudGVyID0geyB4OiBwb2ludEEueCArIGRpZmYueCAvIDIsIHk6IHBvaW50QS55ICsgZGlmZi55IC8gMiB9O1xuICAgIHZhciBQID0gcm90YXRlKHBvaW50QiwgY2VudGVyLCBNYXRoLlBJIC8gMik7XG4gICAgdmFyIEQgPSB7IHg6IFAueCArIChjb250cm9sLnggLSBQLngpIC8gMiwgeTogUC55ICsgKGNvbnRyb2wueSAtIFAueSkgLyAyIH07XG4gICAgdmFyIHJhZGl1cyA9IGdldFBvaW50c0Rpc3RhbmNlKEQsIGNlbnRlcik7XG4gICAgdmFyIFUgPSB0cmFuc2xhdGVQb2ludChELCBnZXRQb2ludHNBbmdsZShELCBQKSwgcmFkaXVzKTtcbiAgICB2YXIgViA9IHRyYW5zbGF0ZVBvaW50KEQsIGdldFBvaW50c0FuZ2xlKEQsIGNvbnRyb2wpLCByYWRpdXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHJvdW5kKGdldFBvaW50c0Rpc3RhbmNlKGNvbnRyb2wsIFUpLCBERUNJTUFMUyksXG4gICAgICAgIHJvdW5kKGdldFBvaW50c0Rpc3RhbmNlKGNvbnRyb2wsIFYpLCBERUNJTUFMUyksXG4gICAgICAgIHJvdW5kKGdldFBvaW50c0FuZ2xlKGNlbnRlciwgVikgKiAxODAgLyBNYXRoLlBJLCBERUNJTUFMUylcbiAgICBdO1xufTtcbnZhciByYW5kb21JZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIpOyB9O1xuZXhwb3J0IHZhciB1dWlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbShBcnJheSgzKSkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmRvbUlkKCk7IH0pLmpvaW4oJy0nKTsgfTtcbiIsInZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbmltcG9ydCB7IFBsYW5lVmlldywgQXhpcywgUk9UXzQ1LCBST1RfNjAsIFJPVF9DTUEgfSBmcm9tICdAY29uc3RhbnRzJztcbmltcG9ydCB7IHNpbmNvcywgcmFkaWFuIH0gZnJvbSAnQHV0aWxzL21hdGgnO1xudmFyIG11bHRpcGx5TWF0cml4ID0gZnVuY3Rpb24gKG0xLCBtMikgeyByZXR1cm4gKG0xLm1hcChmdW5jdGlvbiAocm93LCBpKSB7IHJldHVybiAobTJbMF0ubWFwKGZ1bmN0aW9uIChfLCBqKSB7XG4gICAgcmV0dXJuIHJvdy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgXywgbikge1xuICAgICAgICByZXR1cm4gYWNjICsgbTFbaV1bbl0gKiBtMltuXVtqXTtcbiAgICB9LCAwKTtcbn0pKTsgfSkpOyB9O1xudmFyIG11bHRpcGx5TWF0cmljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG0gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBtYXRyaXggPSBtWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpeChtYXRyaXgsIG1baV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufTtcbnZhciByb3RhdGVYID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgc2MgPSBzaW5jb3Mocik7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgWzEsIDAsIDBdLFxuICAgICAgICBbMCwgc2MuY29zLCAtc2Muc2luXSxcbiAgICAgICAgWzAsIHNjLnNpbiwgc2MuY29zXVxuICAgIF07XG59O1xudmFyIHJvdGF0ZVkgPSBmdW5jdGlvbiAocikge1xuICAgIHZhciBzYyA9IHNpbmNvcyhyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBbc2MuY29zLCAwLCBzYy5zaW5dLFxuICAgICAgICBbMCwgMSwgMF0sXG4gICAgICAgIFstc2Muc2luLCAwLCBzYy5jb3NdXG4gICAgXTtcbn07XG52YXIgcm90YXRlWiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgdmFyIHNjID0gc2luY29zKHIpO1xuICAgIHJldHVybiBbXG4gICAgICAgIFtzYy5jb3MsIC1zYy5zaW4sIDBdLFxuICAgICAgICBbc2Muc2luLCBzYy5jb3MsIDBdLFxuICAgICAgICBbMCwgMCwgMV1cbiAgICBdO1xufTtcbnZhciB0b3BNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHJvdGF0ZVgoUk9UX0NNQSksIHJvdGF0ZVooLVJPVF80NSkpO1xudmFyIGZyb250TWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhyb3RhdGVaKC1ST1RfNjApLCByb3RhdGVYKFJPVF9DTUEpLCByb3RhdGVaKFJPVF80NSkpO1xudmFyIHNpZGVNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHJvdGF0ZVooUk9UXzYwKSwgcm90YXRlWChST1RfQ01BKSwgcm90YXRlWigtUk9UXzQ1KSk7XG52YXIgcm90YXRpb25Ub1JvdGF0aW9uTWF0cml4ID0gZnVuY3Rpb24gKHZpZXcsIHJvdGF0aW9uKSB7XG4gICAgdmFyIHZhbHVlID0gcmFkaWFuKHJvdGF0aW9uLnZhbHVlKTtcbiAgICBzd2l0Y2ggKHZpZXcpIHtcbiAgICAgICAgY2FzZSBQbGFuZVZpZXcuVE9QOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJvdGF0aW9uLmF4aXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF4aXMuVE9QOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm90YXRlWih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY2FzZSBBeGlzLkxFRlQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3RhdGVYKC12YWx1ZSk7XG4gICAgICAgICAgICAgICAgY2FzZSBBeGlzLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm90YXRlWSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFuZVZpZXcuRlJPTlQ6IHtcbiAgICAgICAgICAgIHN3aXRjaCAocm90YXRpb24uYXhpcykge1xuICAgICAgICAgICAgICAgIGNhc2UgQXhpcy5UT1A6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3RhdGVZKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIEF4aXMuTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVgodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgQXhpcy5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVoodmFsdWUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhbmVWaWV3LlNJREU6IHtcbiAgICAgICAgICAgIHN3aXRjaCAocm90YXRpb24uYXhpcykge1xuICAgICAgICAgICAgICAgIGNhc2UgQXhpcy5UT1A6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3RhdGVZKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIEF4aXMuTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVoodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgQXhpcy5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVgoLXZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgZ2V0Vmlld01hdHJpeCA9IGZ1bmN0aW9uIChwbGFuZVZpZXcsIHJvdGF0aW9uKSB7XG4gICAgdmFyIHJvdGF0aW9uTWF0cmljZXMgPSBbXTtcbiAgICB2YXIgcm90YXRpb25NYXRyaXggPSByb3RhdGlvblxuICAgICAgICA/IHJvdGF0aW9uVG9Sb3RhdGlvbk1hdHJpeChwbGFuZVZpZXcsIHJvdGF0aW9uKVxuICAgICAgICA6IG51bGw7XG4gICAgaWYgKHJvdGF0aW9uTWF0cml4KVxuICAgICAgICByb3RhdGlvbk1hdHJpY2VzLnB1c2gocm90YXRpb25NYXRyaXgpO1xuICAgIHN3aXRjaCAocGxhbmVWaWV3KSB7XG4gICAgICAgIGNhc2UgUGxhbmVWaWV3LlRPUDoge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGx5TWF0cmljZXMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFt0b3BNYXRyaXhdLCByb3RhdGlvbk1hdHJpY2VzLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhbmVWaWV3LkZST05UOiB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbHlNYXRyaWNlcy5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2Zyb250TWF0cml4XSwgcm90YXRpb25NYXRyaWNlcywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFBsYW5lVmlldy5TSURFOiB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbHlNYXRyaWNlcy5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW3NpZGVNYXRyaXhdLCByb3RhdGlvbk1hdHJpY2VzLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbiIsInZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbmltcG9ydCB7IENPTU1BTkRTX1JFR0VYUCwgQ29tbWFuZCwgREVDSU1BTFMsIFNDQUxFIH0gZnJvbSAnQGNvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRQb2ludEZyb21Jc29tZXRyaWNQb2ludCwgZ2V0RWxsaXBzaXNTcGVjcywgZ2V0T3JpZW50YXRpb24sIHJvdW5kIH0gZnJvbSAnQHV0aWxzL21hdGgnO1xuaW1wb3J0IHsgZ2V0Vmlld01hdHJpeCB9IGZyb20gJ0B1dGlscy9tYXRyaXgnO1xuZXhwb3J0IHZhciBhZGRTVkdQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHN2ZywgcHJvcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICAgIH0pO1xufTtcbnZhciBnZXRDb21tYW5kc1dpdGhTdGFydCA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgIHJldHVybiBjb21tYW5kcy5sZW5ndGggPT09IDAgfHwgY29tbWFuZHNbMF0uY29tbWFuZCA9PT0gQ29tbWFuZC5tb3ZlXG4gICAgICAgID8gX19zcHJlYWRBcnJheShbXSwgY29tbWFuZHMsIHRydWUpIDogX19zcHJlYWRBcnJheShbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQubW92ZSxcbiAgICAgICAgICAgIHBvaW50OiB7IHI6IDAsIGw6IDAsIHQ6IDAgfVxuICAgICAgICB9XG4gICAgXSwgY29tbWFuZHMsIHRydWUpO1xufTtcbmV4cG9ydCB2YXIgZ2V0U1ZHUGF0aCA9IGZ1bmN0aW9uIChjb21tYW5kcywgY2VudGVyWCwgY2VudGVyWSwgc2NhbGUsIGF1dG9jbG9zZSkge1xuICAgIHZhciBkcmF3Q29tbWFuZHMgPSBnZXRDb21tYW5kc1dpdGhTdGFydChjb21tYW5kcyk7XG4gICAgdmFyIHN2Z1BhdGhzID0gZHJhd0NvbW1hbmRzLm1hcChmdW5jdGlvbiAoYywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQoY2VudGVyWCwgY2VudGVyWSwgYy5wb2ludCwgc2NhbGUpO1xuICAgICAgICBzd2l0Y2ggKGMuY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kLm1vdmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTVwiLmNvbmNhdChwb2ludC54LCBcIiBcIikuY29uY2F0KHBvaW50LnkpO1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kLmxpbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTFwiLmNvbmNhdChwb2ludC54LCBcIiBcIikuY29uY2F0KHBvaW50LnkpO1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kLmN1cnZlOiB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQoY2VudGVyWCwgY2VudGVyWSwgY29tbWFuZHNbaW5kZXggLSAxXS5wb2ludCwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQoY2VudGVyWCwgY2VudGVyWSwgYy5jb250cm9sLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVsbGlwc2lzU3BlY3MgPSBnZXRFbGxpcHNpc1NwZWNzKHN0YXJ0LCBwb2ludCwgY29udHJvbCk7XG4gICAgICAgICAgICAgICAgdmFyIHN3ZWVwRmxhZyA9IGdldE9yaWVudGF0aW9uKHN0YXJ0LCBjb250cm9sLCBwb2ludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQSBcIi5jb25jYXQoZWxsaXBzaXNTcGVjc1swXSwgXCIgXCIpLmNvbmNhdChlbGxpcHNpc1NwZWNzWzFdLCBcIiBcIikuY29uY2F0KGVsbGlwc2lzU3BlY3NbMl0sIFwiIDAgXCIpLmNvbmNhdChzd2VlcEZsYWcsIFwiIFwiKS5jb25jYXQocG9pbnQueCwgXCIgXCIpLmNvbmNhdChwb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdmdQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGhFbmQgPSBhdXRvY2xvc2UgPyAneicgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHN2Z1BhdGhzLmpvaW4oJyAnKS50cmltKCkpLmNvbmNhdChwYXRoRW5kKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcbmV4cG9ydCB2YXIgcGFyc2VEcmF3Q29tbWFuZHMgPSBmdW5jdGlvbiAoY29tbWFuZHMpIHtcbiAgICB2YXIgY29tbWFuZHNBcnJheSA9IFtdO1xuICAgIHZhciBhcnJheTtcbiAgICB3aGlsZSAoKGFycmF5ID0gQ09NTUFORFNfUkVHRVhQLmV4ZWMoY29tbWFuZHMpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGFycmF5WzVdIHx8IGFycmF5WzFdO1xuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGNvbW1hbmRzQXJyYXkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQubW92ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHsgcjogK2FycmF5WzJdLCBsOiArYXJyYXlbM10sIHQ6ICthcnJheVs0XSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICBjb21tYW5kc0FycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBDb21tYW5kLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB7IHI6ICthcnJheVsyXSwgbDogK2FycmF5WzNdLCB0OiArYXJyYXlbNF0gfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgY29tbWFuZHNBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogQ29tbWFuZC5jdXJ2ZSxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogeyByOiArYXJyYXlbNl0sIGw6ICthcnJheVs3XSwgdDogK2FycmF5WzhdIH0sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB7IHI6ICthcnJheVs5XSwgbDogK2FycmF5WzEwXSwgdDogK2FycmF5WzExXSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzQXJyYXk7XG59O1xuZXhwb3J0IHZhciB0cmFuc2xhdGVDb21tYW5kUG9pbnRzID0gZnVuY3Rpb24gKGNvbW1hbmRzLCByaWdodCwgbGVmdCwgdG9wKSB7XG4gICAgY29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICBjb21tYW5kLnBvaW50LnIgKz0gcmlnaHQ7XG4gICAgICAgIGNvbW1hbmQucG9pbnQubCArPSBsZWZ0O1xuICAgICAgICBjb21tYW5kLnBvaW50LnQgKz0gdG9wO1xuICAgICAgICBpZiAoY29tbWFuZC5jb250cm9sKSB7XG4gICAgICAgICAgICBjb21tYW5kLmNvbnRyb2wuciArPSByaWdodDtcbiAgICAgICAgICAgIGNvbW1hbmQuY29udHJvbC5sICs9IGxlZnQ7XG4gICAgICAgICAgICBjb21tYW5kLmNvbnRyb2wudCArPSB0b3A7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnQgdmFyIGdldFRleHR1cmVDb3JuZXIgPSBmdW5jdGlvbiAoY29tbWFuZHMsIGNlbnRlclgsIGNlbnRlclksIHNjYWxlKSB7XG4gICAgdmFyIGNvcm5lciA9IHtcbiAgICAgICAgeDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIHk6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgfTtcbiAgICBnZXRDb21tYW5kc1dpdGhTdGFydChjb21tYW5kcylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQoY2VudGVyWCwgY2VudGVyWSwgYy5wb2ludCwgc2NhbGUpO1xuICAgICAgICBpZiAocG9pbnQueCA8IGNvcm5lci54IHx8XG4gICAgICAgICAgICAocG9pbnQueCA9PT0gY29ybmVyLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludC55IDwgY29ybmVyLnkpKSB7XG4gICAgICAgICAgICBjb3JuZXIueCA9IHBvaW50Lng7XG4gICAgICAgICAgICBjb3JuZXIueSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29ybmVyO1xufTtcbmV4cG9ydCB2YXIgaXNTVkdQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdmaWxsQ29sb3InLFxuICAgICAgICAnZmlsbE9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlQ29sb3InLFxuICAgICAgICAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgICdzdHJva2VXaWR0aCdcbiAgICBdLmluY2x1ZGVzKHByb3BlcnR5KTtcbn07XG5leHBvcnQgdmFyIGdldFNWR1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsbENvbG9yOiAnZmlsbCcsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgICAgICAgc3Ryb2tlQ29sb3I6ICdzdHJva2UnLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCdcbiAgICB9W3Byb3BlcnR5XTtcbn07XG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lclRvRWxlbWVudChlbGVtZW50LCBsaXN0ZW5lcnMsIGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgIHZhciBsaXN0ZW5lciA9IHtcbiAgICAgICAgZm46IGNhbGxiYWNrLFxuICAgICAgICBmbkJpbmQ6IGNhbGxiYWNrLmJpbmQodGhpcylcbiAgICB9O1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLmZuQmluZCwgdXNlQ2FwdHVyZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21FbGVtZW50KGVsZW1lbnQsIGxpc3RlbmVycywgZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgdmFyIGxpc3RlbmVyO1xuICAgIGxpc3RlbmVycy5maW5kKGZ1bmN0aW9uIChsbiwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGxuLmZuID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIuZm5CaW5kLCB1c2VDYXB0dXJlKTtcbiAgICB9XG59XG5leHBvcnQgdmFyIGdldFBhdHRlcm5UcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY29ybmVyLCBwbGFuZVZpZXcsIHNjYWxlLCByb3RhdGlvbikge1xuICAgIHZhciBtYXRyaXggPSBnZXRWaWV3TWF0cml4KHBsYW5lVmlldywgcm90YXRpb24pO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoY29ybmVyLngsIFwiIFwiKS5jb25jYXQoY29ybmVyLnksIFwiKVwiKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIHZhciBtMSA9IHJvdW5kKG1hdHJpeFswXVswXSwgREVDSU1BTFMpO1xuICAgICAgICB2YXIgbTIgPSByb3VuZChtYXRyaXhbMV1bMF0sIERFQ0lNQUxTKTtcbiAgICAgICAgdmFyIG0zID0gcm91bmQobWF0cml4WzBdWzFdLCBERUNJTUFMUyk7XG4gICAgICAgIHZhciBtNCA9IHJvdW5kKG1hdHJpeFsxXVsxXSwgREVDSU1BTFMpO1xuICAgICAgICB0cmFuc2Zvcm0gKz0gXCIgbWF0cml4KFwiLmNvbmNhdChtMSwgXCIsXCIpLmNvbmNhdChtMiwgXCIsXCIpLmNvbmNhdChtMywgXCIsXCIpLmNvbmNhdChtNCwgXCIsMCwwKVwiKTtcbiAgICAgICAgdHJhbnNmb3JtICs9IFwiIHNjYWxlKFwiLmNvbmNhdChyb3VuZChTQ0FMRSAqIChzY2FsZSB8fCAxKSwgREVDSU1BTFMpLCBcIilcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjYWxlKSB7XG4gICAgICAgIHRyYW5zZm9ybSArPSBcIiBzY2FsZShcIi5jb25jYXQocm91bmQoc2NhbGUsIERFQ0lNQUxTKSwgXCIpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtO1xufTtcbmV4cG9ydCB2YXIgZWxlbWVudEhhc1NWR1BhcmVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTVkdTVkdFbGVtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRIYXNTVkdQYXJlbnQoZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbiIsInZhciBTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmUod2lkdGgsIGhlaWdodCwgc2NhbGUpIHtcbiAgICAgICAgdGhpcy5zaXplcyA9IHtcbiAgICAgICAgICAgIGNlbnRlclg6IHdpZHRoIC8gMixcbiAgICAgICAgICAgIGNlbnRlclk6IGhlaWdodCAvIDIsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplcy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZXMud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZXMuY2VudGVyWCA9IHZhbHVlIC8gMjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplcy5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNpemVzLmhlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zaXplcy5jZW50ZXJZID0gdmFsdWUgLyAyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3JlLnByb3RvdHlwZSwgXCJzY2FsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXMuc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNpemVzLnNjYWxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcImNlbnRlclhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemVzLmNlbnRlclg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcImNlbnRlcllcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemVzLmNlbnRlclk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gU3RvcmU7XG59KCkpO1xuZXhwb3J0IHsgU3RvcmUgfTtcbiIsInZhciBJc29tZXRyaWNTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljU3RvcmUoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNTdG9yZS5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVN0b3JlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU3RvcmUgPSBzdG9yZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBJc29tZXRyaWNTdG9yZTtcbn0oKSk7XG5leHBvcnQgeyBJc29tZXRyaWNTdG9yZSB9O1xuIiwiZXhwb3J0IHsgSXNvbWV0cmljU3RvcmUgfSBmcm9tICcuL0lzb21ldHJpY1N0b3JlJztcbiIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBTVkdfTkFNRVNQQUNFIH0gZnJvbSAnQGNvbnN0YW50cyc7XG5pbXBvcnQgeyBJc29tZXRyaWNTdG9yZSB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY1N0b3JlJztcbmltcG9ydCB7IGFkZFNWR1Byb3BlcnRpZXMsIGFkZEV2ZW50TGlzdGVuZXJUb0VsZW1lbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXJGcm9tRWxlbWVudCB9IGZyb20gJ0B1dGlscy9zdmcnO1xudmFyIElzb21ldHJpY0VsZW1lbnRBYnN0cmFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY0VsZW1lbnRBYnN0cmFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJc29tZXRyaWNFbGVtZW50QWJzdHJhY3QoaWQsIHN2Z0VsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2lkID0gaWQ7XG4gICAgICAgIF90aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICBfdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIHN2Z0VsZW1lbnQpO1xuICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKF90aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICAgICdpZCc6IF90aGlzLl9pZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJc29tZXRyaWNFbGVtZW50QWJzdHJhY3QucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5lbGVtZW50LCB7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLl9pZFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIElzb21ldHJpY0VsZW1lbnRBYnN0cmFjdC5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9O1xuICAgIElzb21ldHJpY0VsZW1lbnRBYnN0cmFjdC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgaWYgKHVzZUNhcHR1cmUgPT09IHZvaWQgMCkgeyB1c2VDYXB0dXJlID0gZmFsc2U7IH1cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lclRvRWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudCwgdGhpcy5saXN0ZW5lcnMsIGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljRWxlbWVudEFic3RyYWN0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdm9pZCAwKSB7IHVzZUNhcHR1cmUgPSBmYWxzZTsgfVxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyRnJvbUVsZW1lbnQodGhpcy5lbGVtZW50LCB0aGlzLmxpc3RlbmVycywgZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gSXNvbWV0cmljRWxlbWVudEFic3RyYWN0O1xufShJc29tZXRyaWNTdG9yZSkpO1xuZXhwb3J0IHsgSXNvbWV0cmljRWxlbWVudEFic3RyYWN0IH07XG4iLCJleHBvcnQgeyBJc29tZXRyaWNFbGVtZW50QWJzdHJhY3QgfSBmcm9tICcuL0lzb21ldHJpY0VsZW1lbnRBYnN0cmFjdCc7XG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IENvbG9ycywgTGluZUNhcCwgTGluZUpvaW4sIERFQ0lNQUxTLCBTVkdfTkFNRVNQQUNFLCBTVkdfRUxFTUVOVFMgfSBmcm9tICdAY29uc3RhbnRzJztcbmltcG9ydCB7IGFkZFNWR1Byb3BlcnRpZXMsIGdldFNWR1Byb3BlcnR5LCBnZXRQYXR0ZXJuVHJhbnNmb3JtLCBpc1NWR1Byb3BlcnR5IH0gZnJvbSAnQHV0aWxzL3N2Zyc7XG5pbXBvcnQgeyB1dWlkLCByb3VuZCwgZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQgfSBmcm9tICdAdXRpbHMvbWF0aCc7XG5pbXBvcnQgeyBJc29tZXRyaWNFbGVtZW50QWJzdHJhY3QgfSBmcm9tICcuLi9Jc29tZXRyaWNFbGVtZW50QWJzdHJhY3QnO1xudmFyIGRlZmF1bHRPYmplY3RQcm9wcyA9IHtcbiAgICBmaWxsQ29sb3I6IENvbG9ycy53aGl0ZSxcbiAgICBmaWxsT3BhY2l0eTogMSxcbiAgICBzdHJva2VDb2xvcjogQ29sb3JzLmJsYWNrLFxuICAgIHN0cm9rZURhc2hBcnJheTogW10sXG4gICAgc3Ryb2tlTGluZWNhcDogTGluZUNhcC5idXR0LFxuICAgIHN0cm9rZUxpbmVqb2luOiBMaW5lSm9pbi5yb3VuZCxcbiAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgIHN0cm9rZVdpZHRoOiAxXG59O1xudmFyIElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QocHJvcHMsIHN2Z0VsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMuaWQgfHwgdXVpZCgpLCBzdmdFbGVtZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0T2JqZWN0UHJvcHMpLCBwcm9wcyk7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIF90aGlzLmNyZWF0ZVRleHR1cmUoX3RoaXMucHJvcHMudGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhfdGhpcy5lbGVtZW50LCBfX2Fzc2lnbih7ICdmaWxsJzogX3RoaXMucHJvcHMudGV4dHVyZVxuICAgICAgICAgICAgICAgID8gXCJ1cmwoI1wiLmNvbmNhdChfdGhpcy5wYXR0ZXJuSWQsIFwiKSBcIikuY29uY2F0KF90aGlzLmZpbGxDb2xvcilcbiAgICAgICAgICAgICAgICA6IF90aGlzLmZpbGxDb2xvciwgJ2ZpbGwtb3BhY2l0eSc6IFwiXCIuY29uY2F0KF90aGlzLmZpbGxPcGFjaXR5KSwgJ3N0cm9rZSc6IF90aGlzLnN0cm9rZUNvbG9yLCAnc3Ryb2tlLWRhc2hhcnJheSc6IF90aGlzLnN0cm9rZURhc2hBcnJheS5qb2luKCcgJyksICdzdHJva2UtbGluZWNhcCc6IF90aGlzLnN0cm9rZUxpbmVjYXAsICdzdHJva2UtbGluZWpvaW4nOiBfdGhpcy5zdHJva2VMaW5lam9pbiwgJ3N0cm9rZS1vcGFjaXR5JzogXCJcIi5jb25jYXQoX3RoaXMuc3Ryb2tlT3BhY2l0eSksICdzdHJva2Utd2lkdGgnOiBcIlwiLmNvbmNhdChfdGhpcy5zdHJva2VXaWR0aCkgfSwgKF90aGlzLnByb3BzLmNsYXNzTmFtZSAmJiB7XG4gICAgICAgICAgICBjbGFzczogX3RoaXMucHJvcHMuY2xhc3NOYW1lXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0LnByb3RvdHlwZS5jcmVhdGVUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuSWQgPSBcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIl9fdGV4dHVyZVwiKTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIFNWR19FTEVNRU5UUy5wYXR0ZXJuKTtcbiAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLnBhdHRlcm4sIHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMucGF0dGVybklkLFxuICAgICAgICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZScsXG4gICAgICAgICAgICAncGF0dGVyblVuaXRzJzogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIFNWR19FTEVNRU5UUy5pbWFnZSk7XG4gICAgICAgIGFkZFNWR1Byb3BlcnRpZXMoaW1hZ2UsIHtcbiAgICAgICAgICAgICdocmVmJzogdGV4dHVyZS51cmwsXG4gICAgICAgICAgICAneCc6ICcwJyxcbiAgICAgICAgICAgICd5JzogJzAnLFxuICAgICAgICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZXh0dXJlLnBpeGVsYXRlZCkge1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhpbWFnZSwge1xuICAgICAgICAgICAgICAgICdzdHlsZSc6ICdpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0dGVybi5hcHBlbmRDaGlsZChpbWFnZSk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLl91cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLnBhdHRlcm4uZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudGV4dHVyZS51cmwgJiZcbiAgICAgICAgICAgIGltYWdlLmdldEF0dHJpYnV0ZSgnaHJlZicpICE9PSB0aGlzLnByb3BzLnRleHR1cmUudXJsKSB7XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKGltYWdlLCB7XG4gICAgICAgICAgICAgICAgJ2hyZWYnOiB0aGlzLnByb3BzLnRleHR1cmUudXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy50ZXh0dXJlLnBpeGVsYXRlZCkge1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhpbWFnZSwge1xuICAgICAgICAgICAgICAgICdzdHlsZSc6ICdpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLmFkZEFuaW1hdGlvbkJhc2ljUHJvcGVydGllcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lLCBhbmltYXRpb24pIHtcbiAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhhbmltYXRpb24uZWxlbWVudCwge1xuICAgICAgICAgICAgcmVwZWF0Q291bnQ6IFwiXCIuY29uY2F0KGFuaW1hdGlvbi5yZXBlYXQgfHwgJ2luZGVmaW5pdGUnKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICBkdXI6IFwiXCIuY29uY2F0KGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAxLCBcInNcIilcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBpc05hdGl2ZVNWR1Byb3BlcnR5ID0gaXNTVkdQcm9wZXJ0eShhbmltYXRpb24ucHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGlzTmF0aXZlU1ZHUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBnZXRTVkdQcm9wZXJ0eShhbmltYXRpb24ucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgU1ZHX0VMRU1FTlRTLmFuaW1hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChhbmltYXRpb24uZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmFkZEFuaW1hdGlvbkJhc2ljUHJvcGVydGllcyhwcm9wZXJ0eSwgYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKGFuaW1hdGlvbi5lbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IEFycmF5LmlzQXJyYXkoYW5pbWF0aW9uLnZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFuaW1hdGlvbi52YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpOyB9KS5qb2luKCc7JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIuY29uY2F0KGFuaW1hdGlvbi52YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhhbmltYXRpb24uZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogXCJcIi5jb25jYXQoYW5pbWF0aW9uLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IFwiXCIuY29uY2F0KGFuaW1hdGlvbi50bylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVTdWJDbGFzc0FuaW1hdGlvbnMoKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUudXBkYXRlUGF0dGVyblRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjb3JuZXIsIHBsYW5lVmlldykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMucHJvcHMudGV4dHVyZS5oZWlnaHRcbiAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KHRoaXMucHJvcHMudGV4dHVyZS5oZWlnaHQgKiB0aGlzLmRhdGEuc2NhbGUpXG4gICAgICAgICAgICAgICAgOiAnMTAwJSc7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnByb3BzLnRleHR1cmUud2lkdGhcbiAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KHRoaXMucHJvcHMudGV4dHVyZS53aWR0aCAqIHRoaXMuZGF0YS5zY2FsZSlcbiAgICAgICAgICAgICAgICA6ICcxMDAlJztcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IGdldFBvaW50RnJvbUlzb21ldHJpY1BvaW50KDAsIDAsIHtcbiAgICAgICAgICAgICAgICByOiAoKF9hID0gdGhpcy5wcm9wcy50ZXh0dXJlLnNoaWZ0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmlnaHQpIHx8IDAsXG4gICAgICAgICAgICAgICAgbDogKChfYiA9IHRoaXMucHJvcHMudGV4dHVyZS5zaGlmdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlZnQpIHx8IDAsXG4gICAgICAgICAgICAgICAgdDogKChfYyA9IHRoaXMucHJvcHMudGV4dHVyZS5zaGlmdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvcCkgfHwgMFxuICAgICAgICAgICAgfSwgdGhpcy5kYXRhLnNjYWxlKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRQYXR0ZXJuVHJhbnNmb3JtKHtcbiAgICAgICAgICAgICAgICB4OiByb3VuZChjb3JuZXIueCArIHNoaWZ0LngsIERFQ0lNQUxTKSxcbiAgICAgICAgICAgICAgICB5OiByb3VuZChjb3JuZXIueSArIHNoaWZ0LnksIERFQ0lNQUxTKVxuICAgICAgICAgICAgfSwgdGhpcy5wcm9wcy50ZXh0dXJlLnBsYW5lVmlldyB8fCBwbGFuZVZpZXcsIHRoaXMucHJvcHMudGV4dHVyZS5zY2FsZSwgdGhpcy5wcm9wcy50ZXh0dXJlLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5wYXR0ZXJuLCB7XG4gICAgICAgICAgICAgICAgJ3BhdHRlcm5UcmFuc2Zvcm0nOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKHRoaXMucGF0dGVybi5maXJzdENoaWxkLCB7XG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldElkKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdHRlcm5JZCA9IFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiX190ZXh0dXJlXCIpO1xuICAgICAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5wYXR0ZXJuLCB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IHRoaXMucGF0dGVybklkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0LnByb3RvdHlwZSwgXCJmaWxsQ29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmZpbGxDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZmlsbENvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKHRoaXMuZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICdmaWxsJzogdGhpcy5wcm9wcy50ZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1cmwoI1wiLmNvbmNhdCh0aGlzLnBhdHRlcm5JZCwgXCIpIFwiKS5jb25jYXQodGhpcy5maWxsQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5maWxsQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmZpbGxPcGFjaXR5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5maWxsT3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIHsgJ2ZpbGwtb3BhY2l0eSc6IFwiXCIuY29uY2F0KHRoaXMuZmlsbE9wYWNpdHkpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUsIFwidGV4dHVyZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudGV4dHVyZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBoYXNUZXh0dXJlID0gISF0aGlzLnByb3BzLnRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnRleHR1cmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChoYXNUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKHRoaXMucHJvcHMudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLCBcInN0cm9rZUNvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHJva2VDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc3Ryb2tlQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5lbGVtZW50LCB7ICdzdHJva2UnOiB0aGlzLnN0cm9rZUNvbG9yIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUsIFwic3Ryb2tlRGFzaEFycmF5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHJva2VEYXNoQXJyYXk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0cm9rZURhc2hBcnJheSA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIHsgJ3N0cm9rZS1kYXNoYXJyYXknOiB0aGlzLnN0cm9rZURhc2hBcnJheS5qb2luKCcgJykgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0LnByb3RvdHlwZSwgXCJzdHJva2VMaW5lY2FwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHJva2VMaW5lY2FwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5zdHJva2VMaW5lY2FwID0gTGluZUNhcFt2YWx1ZV07XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKHRoaXMuZWxlbWVudCwgeyAnc3Ryb2tlLWxpbmVjYXAnOiB0aGlzLnN0cm9rZUxpbmVjYXAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0LnByb3RvdHlwZSwgXCJzdHJva2VMaW5lam9pblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3Ryb2tlTGluZWpvaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0cm9rZUxpbmVqb2luID0gTGluZUpvaW5bdmFsdWVdO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIHsgJ3N0cm9rZS1saW5lam9pbic6IHRoaXMuc3Ryb2tlTGluZWpvaW4gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0LnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHJva2VPcGFjaXR5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5zdHJva2VPcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKHRoaXMuZWxlbWVudCwgeyAnc3Ryb2tlLW9wYWNpdHknOiBcIlwiLmNvbmNhdCh0aGlzLnN0cm9rZU9wYWNpdHkpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5zdHJva2VXaWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIHsgJ3N0cm9rZS13aWR0aCc6IFwiXCIuY29uY2F0KHRoaXMuc3Ryb2tlV2lkdGgpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUsIFwiY2xhc3NOYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jbGFzc05hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmNsYXNzTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB0aGlzLnByb3BzLmNsYXNzTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLmdldFBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gICAgfTtcbiAgICBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGhhc1RleHR1cmUgPSAhIXRoaXMucHJvcHMudGV4dHVyZTtcbiAgICAgICAgaWYgKGhhc1RleHR1cmUgfHwgdmFsdWUudXJsKSB7XG4gICAgICAgICAgICB2YXIgc2hpZnQgPSB2YWx1ZS5zaGlmdCwgcm90YXRpb24gPSB2YWx1ZS5yb3RhdGlvbiwgbmV3UHJvcHMgPSBfX3Jlc3QodmFsdWUsIFtcInNoaWZ0XCIsIFwicm90YXRpb25cIl0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy50ZXh0dXJlID0gaGFzVGV4dHVyZVxuICAgICAgICAgICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMucHJvcHMudGV4dHVyZSksIG5ld1Byb3BzKSA6IF9fYXNzaWduKHt9LCBuZXdQcm9wcyk7XG4gICAgICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnRleHR1cmUuc2hpZnQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMudGV4dHVyZS5zaGlmdCB8fCB7fSkpLCBzaGlmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnRleHR1cmUucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKHRoaXMucHJvcHMudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChfX2Fzc2lnbih7fSwgYW5pbWF0aW9uKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0LnByb3RvdHlwZS5yZW1vdmVBbmltYXRpb25CeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5lbGVtZW50ICYmIGFuaW1hdGlvbi5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFuaW1hdGlvbi5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdC5wcm90b3R5cGUucmVtb3ZlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKDApO1xuICAgICAgICBhbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5lbGVtZW50ICYmIGFuaW1hdGlvbi5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFuaW1hdGlvbi5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdDtcbn0oSXNvbWV0cmljRWxlbWVudEFic3RyYWN0KSk7XG5leHBvcnQgeyBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QgfTtcbiIsImV4cG9ydCB7IElzb21ldHJpY0dyYXBoaWNBYnN0cmFjdCB9IGZyb20gJy4vSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0JztcbiIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBlbGVtZW50SGFzU1ZHUGFyZW50IH0gZnJvbSAnQHV0aWxzL3N2Zyc7XG5pbXBvcnQgeyBJc29tZXRyaWNFbGVtZW50QWJzdHJhY3QgfSBmcm9tICdAY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNFbGVtZW50QWJzdHJhY3QnO1xuaW1wb3J0IHsgSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0IH0gZnJvbSAnQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0JztcbnZhciBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0KGlkLCBzdmdFbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCBzdmdFbGVtZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUudGhyb3dDaGlsZEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcHJvdmlkZSBhIGNoaWxkIHRoYXQgaXMgbm90IGEgY2hpbGRyZW4gb2YgdGhlIGNvbnRhaW5lcicpO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLnJlbW92ZVNWR0NoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBzdmdDaGlsZCA9IGNoaWxkLmdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSXNvbWV0cmljR3JhcGhpY0Fic3RyYWN0KSB7XG4gICAgICAgICAgICB2YXIgc3ZnUGF0dGVybkNoaWxkID0gY2hpbGQuZ2V0UGF0dGVybigpO1xuICAgICAgICAgICAgaWYgKHN2Z1BhdHRlcm5DaGlsZCAmJiBzdmdQYXR0ZXJuQ2hpbGQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZChzdmdQYXR0ZXJuQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdmdDaGlsZC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuaW5zZXJ0UGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHBhdHRlcm4sIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0LnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRJZCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudEhhc1NWR1BhcmVudCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmRhdGEgPSBfdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLnNwbGljZSgwKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZVNWR0NoaWxkKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0UGF0dGVybihjaGlsZC5nZXRQYXR0ZXJuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZC5nZXRFbGVtZW50KCkpO1xuICAgICAgICBjaGlsZC51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuYWRkQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2hpbGRyZW5bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gX3RoaXMuYWRkQ2hpbGQoY2hpbGQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuZ2V0Q2hpbGRCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpbmRleF0gfHwgbnVsbDtcbiAgICB9O1xuICAgIElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0LnByb3RvdHlwZS5nZXRDaGlsZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW4uZmluZChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmlkID09PSBpZDsgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBudWxsO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZEluZGV4ID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTVkdDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93Q2hpbGRFcnJvcigpO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLnJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEluZGV4ID0gX3RoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50aHJvd0NoaWxkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLnJlbW92ZUNoaWxkQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU1ZHQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QucHJvdG90eXBlLnJlbW92ZUNoaWxkQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQnlJZChpZCk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuc2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNoaWxkSW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGluZGV4KSwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB2YXIgbW92ZWRFbGVtZW50ID0gY2hpbGQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VkRWxlbWVudCA9IHRoaXMuX2NoaWxkcmVuW2luZGV4XS5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baW5kZXhdICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJbmRleCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUobW92ZWRFbGVtZW50LCByZXBsYWNlZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VkRWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZShtb3ZlZEVsZW1lbnQsIHJlcGxhY2VkRWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQobW92ZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dDaGlsZEVycm9yKCk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdC5wcm90b3R5cGUuYnJpbmdDaGlsZFRvRnJvbnQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkSW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNldENoaWxkSW5kZXgoY2hpbGQsIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0NoaWxkRXJyb3IoKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0LnByb3RvdHlwZS5icmluZ0NoaWxkRm9yd2FyZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJbmRleCA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZEluZGV4IDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2hpbGRJbmRleChjaGlsZCwgY2hpbGRJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0NoaWxkRXJyb3IoKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0LnByb3RvdHlwZS5zZW5kQ2hpbGRUb0JhY2sgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkSW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNldENoaWxkSW5kZXgoY2hpbGQsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0NoaWxkRXJyb3IoKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0LnByb3RvdHlwZS5zZW5kQ2hpbGRCYWNrd2FyZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJbmRleCA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2hpbGRJbmRleChjaGlsZCwgY2hpbGRJbmRleCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0NoaWxkRXJyb3IoKTtcbiAgICB9O1xuICAgIHJldHVybiBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdDtcbn0oSXNvbWV0cmljRWxlbWVudEFic3RyYWN0KSk7XG5leHBvcnQgeyBJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdCB9O1xuIiwiZXhwb3J0IHsgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QgfSBmcm9tICcuL0lzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0JztcbiIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IHsgU1ZHX05BTUVTUEFDRSwgU1ZHX0VMRU1FTlRTLCBTVkdfUFJPUEVSVElFUywgREVGQVVMVF9XSURUSCwgREVGQVVMVF9IRUlHSFQsIENvbG9ycyB9IGZyb20gJ0Bjb25zdGFudHMnO1xuaW1wb3J0IHsgYWRkU1ZHUHJvcGVydGllcyB9IGZyb20gJ0B1dGlscy9zdmcnO1xuaW1wb3J0IHsgdXVpZCB9IGZyb20gJ0B1dGlscy9tYXRoJztcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQHN0b3JlJztcbmltcG9ydCB7IElzb21ldHJpY0NvbnRhaW5lckFic3RyYWN0IH0gZnJvbSAnQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb250YWluZXI6ICdib2R5JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9ycy53aGl0ZSxcbiAgICBzY2FsZTogMSxcbiAgICBoZWlnaHQ6IERFRkFVTFRfSEVJR0hULFxuICAgIHdpZHRoOiBERUZBVUxUX1dJRFRIXG59O1xudmFyIElzb21ldHJpY0NhbnZhcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY0NhbnZhcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJc29tZXRyaWNDYW52YXMocHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgeyBwcm9wcyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzLmlkIHx8IHV1aWQoKSwgU1ZHX0VMRU1FTlRTLnN2ZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdFByb3BzKSwgcHJvcHMpO1xuICAgICAgICBfdGhpcy5pc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuZGF0YSA9IG5ldyBTdG9yZShfdGhpcy5wcm9wcy53aWR0aCwgX3RoaXMucHJvcHMuaGVpZ2h0LCBfdGhpcy5wcm9wcy5zY2FsZSk7XG4gICAgICAgIGFkZFNWR1Byb3BlcnRpZXMoX3RoaXMuZWxlbWVudCwgKF9hID0ge30sXG4gICAgICAgICAgICBfYVtTVkdfUFJPUEVSVElFUy52aWV3Qm94XSA9IFwiMCAwIFwiLmNvbmNhdChfdGhpcy5kYXRhLndpZHRoLCBcIiBcIikuY29uY2F0KF90aGlzLmRhdGEuaGVpZ2h0KSxcbiAgICAgICAgICAgIF9hLndpZHRoID0gXCJcIi5jb25jYXQoX3RoaXMuZGF0YS53aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgIF9hLmhlaWdodCA9IFwiXCIuY29uY2F0KF90aGlzLmRhdGEuaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTkFNRVNQQUNFLCBTVkdfRUxFTUVOVFMucmVjdCk7XG4gICAgICAgIGFkZFNWR1Byb3BlcnRpZXMoX3RoaXMuYmFja2dyb3VuZCwge1xuICAgICAgICAgICAgZmlsbDogX3RoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgeDogJzAnLFxuICAgICAgICAgICAgeTogJzAnLFxuICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KF90aGlzLmRhdGEud2lkdGgsIFwicHhcIiksXG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KF90aGlzLmRhdGEuaGVpZ2h0LCBcInB4XCIpXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKF90aGlzLmJhY2tncm91bmQpO1xuICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHR5cGVvZiBfdGhpcy5wcm9wcy5jb250YWluZXIgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMucHJvcHMuY29udGFpbmVyKVxuICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5jb250YWluZXI7XG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0NhbnZhcy5wcm90b3R5cGUsIFwiYmFja2dyb3VuZENvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmJhY2tncm91bmQsIHsgZmlsbDogdGhpcy5iYWNrZ3JvdW5kQ29sb3IgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljQ2FudmFzLnByb3RvdHlwZSwgXCJzY2FsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zY2FsZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNDYW52YXMucHJvdG90eXBlLCBcImhlaWdodFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKHRoaXMuZWxlbWVudCwgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgX2FbU1ZHX1BST1BFUlRJRVMudmlld0JveF0gPSBcIjAgMCBcIi5jb25jYXQodGhpcy5kYXRhLndpZHRoLCBcIiBcIikuY29uY2F0KHRoaXMuZGF0YS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIF9hLmhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuZGF0YS5oZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5iYWNrZ3JvdW5kLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdCh0aGlzLmRhdGEuaGVpZ2h0LCBcInB4XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljQ2FudmFzLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS53aWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW1NWR19QUk9QRVJUSUVTLnZpZXdCb3hdID0gXCIwIDAgXCIuY29uY2F0KHRoaXMuZGF0YS53aWR0aCwgXCIgXCIpLmNvbmNhdCh0aGlzLmRhdGEuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBfYS53aWR0aCA9IFwiXCIuY29uY2F0KHRoaXMuZGF0YS53aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmJhY2tncm91bmQsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQodGhpcy5kYXRhLndpZHRoLCBcInB4XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljQ2FudmFzLnByb3RvdHlwZSwgXCJhbmltYXRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBbmltYXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIElzb21ldHJpY0NhbnZhcy5wcm90b3R5cGUuZ2V0U1ZHQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vdXRlckhUTUw7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDYW52YXMucHJvdG90eXBlLnBhdXNlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdmcucGF1c2VBbmltYXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdmcucGF1c2VBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljQ2FudmFzLnByb3RvdHlwZS5yZXN1bWVBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ZnID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAodHlwZW9mIHN2Zy51bnBhdXNlQW5pbWF0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3ZnLnVucGF1c2VBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gSXNvbWV0cmljQ2FudmFzO1xufShJc29tZXRyaWNDb250YWluZXJBYnN0cmFjdCkpO1xuZXhwb3J0IHsgSXNvbWV0cmljQ2FudmFzIH07XG4iLCJleHBvcnQgKiBmcm9tICcuL0lzb21ldHJpY0NhbnZhcyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbiIsImV4cG9ydCB2YXIgYXBwbHlNaXhpbnMgPSBmdW5jdGlvbiAoQmFzZUNsYXNzLCBjb25zdHJ1Y3Rvcikge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbnN0cnVjdG9yLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNsYXNzLnByb3RvdHlwZSwgbmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIG5hbWUpKTtcbiAgICB9KTtcbn07XG4iLCJleHBvcnQgdmFyIE5PX0xJTUlUUyA9IFtcbiAgICBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuXTtcbmV4cG9ydCB2YXIgRFJBR19FVkVOVDtcbihmdW5jdGlvbiAoRFJBR19FVkVOVCkge1xuICAgIERSQUdfRVZFTlRbXCJEUkFHX1NUQVJUXCJdID0gXCJkcmFnc3RhcnRcIjtcbiAgICBEUkFHX0VWRU5UW1wiRFJBR1wiXSA9IFwiZHJhZ1wiO1xuICAgIERSQUdfRVZFTlRbXCJEUkFHX0VORFwiXSA9IFwiZHJhZ2VuZFwiO1xufSkoRFJBR19FVkVOVCB8fCAoRFJBR19FVkVOVCA9IHt9KSk7XG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbmltcG9ydCB7IEVWRU5UUywgREVDSU1BTFMsIFBsYW5lVmlldywgVHlwZW9mIH0gZnJvbSAnQGNvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRUb3BQbGFuZVBvaW50RnJvbUNvb3JkaW5hdGVzLCBnZXRGcm9udFBsYW5lUG9pbnRGcm9tQ29vcmRpbmF0ZXMsIGdldFNpZGVQbGFuZVBvaW50RnJvbUNvb3JkaW5hdGVzLCByb3VuZCB9IGZyb20gJ0B1dGlscy9tYXRoJztcbmltcG9ydCB7IElzb21ldHJpY0VsZW1lbnRBYnN0cmFjdCB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY0VsZW1lbnRBYnN0cmFjdCc7XG5pbXBvcnQgeyBOT19MSU1JVFMsIERSQUdfRVZFTlQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG52YXIgX2lzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFR5cGVvZi5VTkRFRklORUQ7XG52YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IF9pc0Jyb3dzZXJcbiAgICA/ICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgOiBudWxsO1xudmFyIF9kcmFnU3RvcmVEZWZhdWx0ID0ge1xuICAgIHJpZ2h0OiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHg6IDAsXG4gICAgeTogMFxufTtcbnZhciBpc01vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuICdjbGllbnRYJyBpbiBldmVudDsgfTtcbnZhciBnZXRDbGllbnRDb29yZHMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG59O1xudmFyIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXJ0RHJhZyA9IHRoaXMuc3RhcnREcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3RvcERyYWcgPSB0aGlzLnN0b3BEcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZUVsZW1lbnQgPSB0aGlzLm1vdmVFbGVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZHJvcEVsZW1lbnQgPSB0aGlzLmRyb3BFbGVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2JvdW5kcyA9PT0gVHlwZW9mLlVOREVGSU5FRCkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kcmFnU3RvcmUgPT09IFR5cGVvZi5VTkRFRklORUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdTdG9yZSA9IF9kcmFnU3RvcmVEZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29vcmRzID09PSBUeXBlb2YuVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9jb29yZHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLmJldHdlZW5Cb3VuZHMgPSBmdW5jdGlvbiAodmFsdWUsIGJvdW5kcykge1xuICAgICAgICB2YXIgb3JkZXJlZEJvdW5kcyA9IF9fc3ByZWFkQXJyYXkoW10sIGJvdW5kcywgdHJ1ZSkuc29ydCgpO1xuICAgICAgICByZXR1cm4gcm91bmQoTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG9yZGVyZWRCb3VuZHNbMF0pLCBvcmRlcmVkQm91bmRzWzFdKSwgREVDSU1BTFMpO1xuICAgIH07XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLmdldEJvdW5kT3JNYXhpbXVtID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5ib3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmJvdW5kc1twcm9wXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX19zcHJlYWRBcnJheShbXSwgTk9fTElNSVRTLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShbXSwgTk9fTElNSVRTLCB0cnVlKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZE9yTWF4aW11bSgncmlnaHQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2VlbkJvdW5kcyh0aGlzLl9kcmFnU3RvcmUucmlnaHQgKyB2YWx1ZSAvIHRoaXMuZGF0YS5zY2FsZSwgYm91bmRzKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kT3JNYXhpbXVtKCdsZWZ0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW5Cb3VuZHModGhpcy5fZHJhZ1N0b3JlLmxlZnQgKyB2YWx1ZSAvIHRoaXMuZGF0YS5zY2FsZSwgYm91bmRzKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRPck1heGltdW0oJ3RvcCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuQm91bmRzKHRoaXMuX2RyYWdTdG9yZS50b3AgKyB2YWx1ZSAvIHRoaXMuZGF0YS5zY2FsZSwgYm91bmRzKTtcbiAgICB9O1xuICAgIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZS5nZXRGaXhlZENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY29vcmRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZENvb3JkcyA9IF9fYXNzaWduKHt9LCBhY2MpO1xuICAgICAgICAgICAgc3dpdGNoIChlbnRyeVswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRDb29yZHMucmlnaHQgPSBfdGhpcy5nZXRSaWdodChlbnRyeVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBmaXhlZENvb3Jkcy5sZWZ0ID0gX3RoaXMuZ2V0TGVmdChlbnRyeVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkQ29vcmRzLnRvcCA9IF90aGlzLmdldFRvcChlbnRyeVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZml4ZWRDb29yZHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIGRyYWdFdmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFR5cGUsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGV2ZW50VHlwZSA9PT0gRFJBR19FVkVOVC5EUkFHLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6IChfYSA9IHRoaXMuX2Nvb3Jkcy5yaWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yaWdodCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAoX2IgPSB0aGlzLl9jb29yZHMubGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogKF9jID0gdGhpcy5fY29vcmRzLnRvcCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy50b3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiBkcmFnRXZlbnQ7XG4gICAgfTtcbiAgICBJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2Nvb3Jkcy5yaWdodCA9PT0gVHlwZW9mLk5VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5fY29vcmRzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2Nvb3Jkcy5sZWZ0ID09PSBUeXBlb2YuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IHRoaXMuX2Nvb3Jkcy5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2Nvb3Jkcy50b3AgPT09IFR5cGVvZi5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLl9jb29yZHMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgX2EgPSBnZXRDbGllbnRDb29yZHMoZXZlbnQpLCBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICAgIHRoaXMuX2RyYWdTdG9yZS54ID0gY2xpZW50WDtcbiAgICAgICAgdGhpcy5fZHJhZ1N0b3JlLnkgPSBjbGllbnRZO1xuICAgICAgICB0aGlzLl9kcmFnU3RvcmUucmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgICAgICB0aGlzLl9kcmFnU3RvcmUubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgdGhpcy5fZHJhZ1N0b3JlLnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLl91cGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1vdmVFbGVtZW50KHsgY2xpZW50WDogY2xpZW50WCwgY2xpZW50WTogY2xpZW50WSB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLlRPVUNIX01PVkUsIHRoaXMubW92ZUVsZW1lbnQsIHRydWUpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMuVE9VQ0hfRU5ELCB0aGlzLmRyb3BFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMuTU9VU0VfTU9WRSwgdGhpcy5tb3ZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLk1PVVNFX1VQLCB0aGlzLmRyb3BFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpO1xuICAgIH07XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLm1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IGdldENsaWVudENvb3JkcyhldmVudCksIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgICAgdmFyIGRpZmZYID0gY2xpZW50WCAtIHRoaXMuX2RyYWdTdG9yZS54O1xuICAgICAgICB2YXIgZGlmZlkgPSBjbGllbnRZIC0gdGhpcy5fZHJhZ1N0b3JlLnk7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnID09PSBQbGFuZVZpZXcuVE9QKSB7XG4gICAgICAgICAgICB0aGlzLl9jb29yZHMgPSB0aGlzLmdldEZpeGVkQ29vcmRpbmF0ZXMoZ2V0VG9wUGxhbmVQb2ludEZyb21Db29yZGluYXRlcyhkaWZmWCwgZGlmZlkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9kcmFnID09PSBQbGFuZVZpZXcuRlJPTlQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvb3JkcyA9IHRoaXMuZ2V0Rml4ZWRDb29yZGluYXRlcyhnZXRGcm9udFBsYW5lUG9pbnRGcm9tQ29vcmRpbmF0ZXMoZGlmZlgsIGRpZmZZKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb29yZHMgPSB0aGlzLmdldEZpeGVkQ29vcmRpbmF0ZXMoZ2V0U2lkZVBsYW5lUG9pbnRGcm9tQ29vcmRpbmF0ZXMoZGlmZlgsIGRpZmZZKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdFdmVudDtcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KERSQUdfRVZFTlQuRFJBR19TVEFSVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICBkcmFnRXZlbnQgPSB0aGlzLmRpc3BhdGNoRXZlbnQoRFJBR19FVkVOVC5EUkFHKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2ZW50ZWQgPSAhIShkcmFnRXZlbnQgJiYgZHJhZ0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpO1xuICAgIH07XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLmRyb3BFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLlRPVUNIX01PVkUsIHRoaXMubW92ZUVsZW1lbnQsIHRydWUpO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuVE9VQ0hfRU5ELCB0aGlzLmRyb3BFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuTU9VU0VfTU9WRSwgdGhpcy5tb3ZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLk1PVVNFX1VQLCB0aGlzLmRyb3BFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KERSQUdfRVZFTlQuRFJBR19FTkQpO1xuICAgIH07XG4gICAgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLmJlZ2luRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLlRPVUNIX1NUQVJULCB0aGlzLnN0YXJ0RHJhZywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUy5NT1VTRV9ET1dOLCB0aGlzLnN0YXJ0RHJhZywgdHJ1ZSk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdC5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5UT1VDSF9TVEFSVCwgdGhpcy5zdGFydERyYWcsIHRydWUpO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuVE9VQ0hfTU9WRSwgdGhpcy5tb3ZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5UT1VDSF9FTkQsIHRoaXMuZHJvcEVsZW1lbnQsIHRydWUpO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuTU9VU0VfRE9XTiwgdGhpcy5zdGFydERyYWcsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5NT1VTRV9NT1ZFLCB0aGlzLm1vdmVFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuTU9VU0VfVVAsIHRoaXMuZHJvcEVsZW1lbnQsIHRydWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZSwgXCJyaWdodFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMucmlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5yaWdodCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdC5wcm90b3R5cGUsIFwibGVmdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMubGVmdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmxlZnQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5sZWZ0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdC5wcm90b3R5cGUsIFwidG9wXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50b3A7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy50b3AgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy50b3AgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0LnByb3RvdHlwZSwgXCJkcmFnXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJhZyB8fCBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZHJhZyA9PT0gVHlwZW9mLlVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RyYWcgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChfaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wRHJhZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5EcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QucHJvdG90eXBlLCBcImJvdW5kc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcyB8fCBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIGJvdW5kc1JpZ2h0ID0gdGhpcy5nZXRCb3VuZE9yTWF4aW11bSgncmlnaHQnKTtcbiAgICAgICAgICAgIHZhciBib3VuZHNMZWZ0ID0gdGhpcy5nZXRCb3VuZE9yTWF4aW11bSgnbGVmdCcpO1xuICAgICAgICAgICAgdmFyIGJvdW5kc1RvcCA9IHRoaXMuZ2V0Qm91bmRPck1heGltdW0oJ3RvcCcpO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMuYmV0d2VlbkJvdW5kcyh0aGlzLnJpZ2h0LCBib3VuZHNSaWdodCk7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLmJldHdlZW5Cb3VuZHModGhpcy5sZWZ0LCBib3VuZHNMZWZ0KTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5iZXR3ZWVuQm91bmRzKHRoaXMudG9wLCBib3VuZHNUb3ApO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0O1xufShJc29tZXRyaWNFbGVtZW50QWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0IH07XG4iLCJleHBvcnQgeyBJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdCB9IGZyb20gJy4vSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QnO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBTVkdfRUxFTUVOVFMgfSBmcm9tICdAY29uc3RhbnRzJztcbmltcG9ydCB7IHV1aWQsIGdldFBvaW50RnJvbUlzb21ldHJpY1BvaW50IH0gZnJvbSAnQHV0aWxzL21hdGgnO1xuaW1wb3J0IHsgZWxlbWVudEhhc1NWR1BhcmVudCwgYWRkU1ZHUHJvcGVydGllcyB9IGZyb20gJ0B1dGlscy9zdmcnO1xuaW1wb3J0IHsgYXBwbHlNaXhpbnMgfSBmcm9tICdAdXRpbHMvb3RoZXInO1xuaW1wb3J0IHsgSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QgfSBmcm9tICdAY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNDb250YWluZXJBYnN0cmFjdCc7XG5pbXBvcnQgeyBJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdCB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0JztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gICAgcmlnaHQ6IDAsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIElzb21ldHJpY0dyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXNvbWV0cmljR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljR3JvdXAocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzID09PSB2b2lkIDApIHsgcHJvcHMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcy5pZCB8fCB1dWlkKCksIFNWR19FTEVNRU5UUy5ncm91cCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdFByb3BzKSwgcHJvcHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElzb21ldHJpY0dyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbGVtZW50SGFzU1ZHUGFyZW50KHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGdldFBvaW50RnJvbUlzb21ldHJpY1BvaW50KDAsIDAsIHtcbiAgICAgICAgICAgICAgICByOiB0aGlzLnByb3BzLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGw6IHRoaXMucHJvcHMubGVmdCxcbiAgICAgICAgICAgICAgICB0OiB0aGlzLnByb3BzLnRvcFxuICAgICAgICAgICAgfSwgdGhpcy5kYXRhLnNjYWxlKTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5lbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQocG9pbnQueCwgXCIsIFwiKS5jb25jYXQocG9pbnQueSwgXCIpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBJc29tZXRyaWNHcm91cDtcbn0oSXNvbWV0cmljQ29udGFpbmVyQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY0dyb3VwIH07XG5hcHBseU1peGlucyhJc29tZXRyaWNHcm91cCwgSXNvbWV0cmljRHJhZ2dhYmxlQWJzdHJhY3QpO1xuIiwiZXhwb3J0IHsgSXNvbWV0cmljR3JvdXAgfSBmcm9tICcuL0lzb21ldHJpY0dyb3VwJztcbiIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBhZGRTVkdQcm9wZXJ0aWVzLCBnZXRTVkdQYXRoLCBnZXRUZXh0dXJlQ29ybmVyLCBlbGVtZW50SGFzU1ZHUGFyZW50IH0gZnJvbSAnQHV0aWxzL3N2Zyc7XG5pbXBvcnQgeyBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QgfSBmcm9tICcuLi9Jc29tZXRyaWNHcmFwaGljQWJzdHJhY3QnO1xudmFyIElzb21ldHJpY1BhdGhBYnN0cmFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY1BhdGhBYnN0cmFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJc29tZXRyaWNQYXRoQWJzdHJhY3QocHJvcHMsIHN2Z0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHByb3BzLCBzdmdFbGVtZW50KSB8fCB0aGlzO1xuICAgIH1cbiAgICBJc29tZXRyaWNQYXRoQWJzdHJhY3QucHJvdG90eXBlLnVwZGF0ZUdyYXBoaWMgPSBmdW5jdGlvbiAocGxhbmVWaWV3LCBhdXRvY2xvc2UpIHtcbiAgICAgICAgaWYgKGF1dG9jbG9zZSA9PT0gdm9pZCAwKSB7IGF1dG9jbG9zZSA9IHRydWU7IH1cbiAgICAgICAgaWYgKGVsZW1lbnRIYXNTVkdQYXJlbnQodGhpcy5lbGVtZW50KSkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmRzID0gdGhpcy5nZXRDb21tYW5kcygpO1xuICAgICAgICAgICAgdmFyIGNvcm5lciA9IGdldFRleHR1cmVDb3JuZXIoY29tbWFuZHMsIHRoaXMuZGF0YS5jZW50ZXJYLCB0aGlzLmRhdGEuY2VudGVyWSwgdGhpcy5kYXRhLnNjYWxlKTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5lbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgZDogZ2V0U1ZHUGF0aChjb21tYW5kcywgdGhpcy5kYXRhLmNlbnRlclgsIHRoaXMuZGF0YS5jZW50ZXJZLCB0aGlzLmRhdGEuc2NhbGUsIGF1dG9jbG9zZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXR0ZXJuVHJhbnNmb3JtKGNvcm5lciwgcGxhbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSXNvbWV0cmljUGF0aEFic3RyYWN0O1xufShJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1BhdGhBYnN0cmFjdCB9O1xuIiwiZXhwb3J0IHsgSXNvbWV0cmljUGF0aEFic3RyYWN0IH0gZnJvbSAnLi9Jc29tZXRyaWNQYXRoQWJzdHJhY3QnO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBTVkdfRUxFTUVOVFMgfSBmcm9tICdAY29uc3RhbnRzJztcbmltcG9ydCB7IGFkZFNWR1Byb3BlcnRpZXMgfSBmcm9tICdAdXRpbHMvc3ZnJztcbmltcG9ydCB7IGFwcGx5TWl4aW5zIH0gZnJvbSAnQHV0aWxzL290aGVyJztcbmltcG9ydCB7IElzb21ldHJpY1BhdGhBYnN0cmFjdCB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY1BhdGhBYnN0cmFjdCc7XG5pbXBvcnQgeyBJc29tZXRyaWNEcmFnZ2FibGVBYnN0cmFjdCB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0JztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gICAgcmlnaHQ6IDAsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIElzb21ldHJpY1NoYXBlQWJzdHJhY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJc29tZXRyaWNTaGFwZUFic3RyYWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzb21ldHJpY1NoYXBlQWJzdHJhY3QocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMpLCBwcm9wcyksIFNWR19FTEVNRU5UUy5wYXRoKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJc29tZXRyaWNTaGFwZUFic3RyYWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JhcGhpYyh0aGlzLnBsYW5lVmlldyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljU2hhcGVBYnN0cmFjdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5lbGVtZW50LCB7XG4gICAgICAgICAgICBkOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljU2hhcGVBYnN0cmFjdC5wcm90b3R5cGUsIFwicGxhbmVWaWV3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5wbGFuZVZpZXc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnBsYW5lVmlldyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBJc29tZXRyaWNTaGFwZUFic3RyYWN0O1xufShJc29tZXRyaWNQYXRoQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1NoYXBlQWJzdHJhY3QgfTtcbmFwcGx5TWl4aW5zKElzb21ldHJpY1NoYXBlQWJzdHJhY3QsIElzb21ldHJpY0RyYWdnYWJsZUFic3RyYWN0KTtcbiIsImV4cG9ydCB7IElzb21ldHJpY1NoYXBlQWJzdHJhY3QgfSBmcm9tICcuL0lzb21ldHJpY1NoYXBlQWJzdHJhY3QnO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgeyBDb21tYW5kLCBQbGFuZVZpZXcsIFNWR19FTEVNRU5UUywgU1ZHX05BTUVTUEFDRSwgfSBmcm9tICdAY29uc3RhbnRzJztcbmltcG9ydCB7IGdldFNWR1BhdGgsIHRyYW5zbGF0ZUNvbW1hbmRQb2ludHMsIGFkZFNWR1Byb3BlcnRpZXMsIGlzU1ZHUHJvcGVydHkgfSBmcm9tICdAdXRpbHMvc3ZnJztcbmltcG9ydCB7IElzb21ldHJpY1NoYXBlQWJzdHJhY3QgfSBmcm9tICdAY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNTaGFwZUFic3RyYWN0JztcbnZhciBJc29tZXRyaWNSZWN0YW5nbGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJc29tZXRyaWNSZWN0YW5nbGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljUmVjdGFuZ2xlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsIHdpZHRoID0gcHJvcHMud2lkdGgsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImhlaWdodFwiLCBcIndpZHRoXCJdKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgX3RoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJc29tZXRyaWNSZWN0YW5nbGUucHJvdG90eXBlLmdldENvbW1hbmRzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gKF9hID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnJpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJpZ2h0O1xuICAgICAgICB2YXIgbGVmdCA9IChfYiA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5sZWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmxlZnQ7XG4gICAgICAgIHZhciB0b3AgPSAoX2MgPSBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MudG9wKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLnRvcDtcbiAgICAgICAgdmFyIHdpZHRoID0gKF9kID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gKF9lID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLmhlaWdodCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IFt7IGNvbW1hbmQ6IENvbW1hbmQubW92ZSwgcG9pbnQ6IHsgcjogMCwgbDogMCwgdDogMCB9IH1dO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGxhbmVWaWV3KSB7XG4gICAgICAgICAgICBjYXNlIFBsYW5lVmlldy5GUk9OVDpcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsgY29tbWFuZDogQ29tbWFuZC5saW5lLCBwb2ludDogeyByOiAwLCBsOiB3aWR0aCwgdDogMCB9IH0sIHsgY29tbWFuZDogQ29tbWFuZC5saW5lLCBwb2ludDogeyByOiAwLCBsOiB3aWR0aCwgdDogaGVpZ2h0IH0gfSwgeyBjb21tYW5kOiBDb21tYW5kLmxpbmUsIHBvaW50OiB7IHI6IDAsIGw6IDAsIHQ6IGhlaWdodCB9IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbGFuZVZpZXcuU0lERTpcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsgY29tbWFuZDogQ29tbWFuZC5saW5lLCBwb2ludDogeyByOiB3aWR0aCwgbDogMCwgdDogMCB9IH0sIHsgY29tbWFuZDogQ29tbWFuZC5saW5lLCBwb2ludDogeyByOiB3aWR0aCwgbDogMCwgdDogaGVpZ2h0IH0gfSwgeyBjb21tYW5kOiBDb21tYW5kLmxpbmUsIHBvaW50OiB7IHI6IDAsIGw6IDAsIHQ6IGhlaWdodCB9IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbGFuZVZpZXcuVE9QOlxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBDb21tYW5kLmxpbmUsIHBvaW50OiB7IHI6IHdpZHRoLCBsOiAwLCB0OiAwIH0gfSwgeyBjb21tYW5kOiBDb21tYW5kLmxpbmUsIHBvaW50OiB7IHI6IHdpZHRoLCBsOiBoZWlnaHQsIHQ6IDAgfSB9LCB7IGNvbW1hbmQ6IENvbW1hbmQubGluZSwgcG9pbnQ6IHsgcjogMCwgbDogaGVpZ2h0LCB0OiAwIH0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNsYXRlQ29tbWFuZFBvaW50cyhjb21tYW5kcywgcmlnaHQsIGxlZnQsIHRvcCk7XG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICB9O1xuICAgIElzb21ldHJpY1JlY3RhbmdsZS5wcm90b3R5cGUuZ2V0UmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IHRoaXMuZ2V0Q29tbWFuZHMoYXJncyk7XG4gICAgICAgIHJldHVybiBnZXRTVkdQYXRoKGNvbW1hbmRzLCB0aGlzLmRhdGEuY2VudGVyWCwgdGhpcy5kYXRhLmNlbnRlclksIHRoaXMuZGF0YS5zY2FsZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNSZWN0YW5nbGUucHJvdG90eXBlLnVwZGF0ZVN1YkNsYXNzQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgdmFyIGlzTmF0aXZlU1ZHUHJvcGVydHkgPSBpc1NWR1Byb3BlcnR5KGFuaW1hdGlvbi5wcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWlzTmF0aXZlU1ZHUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHNfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IF90aGlzLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBfdGhpcy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IF90aGlzLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF90aGlzLmhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wc18xLCBhbmltYXRpb24ucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV8xID0gYW5pbWF0aW9uLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFuaW1hdGlvbi52YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBhbmltYXRpb24udmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZEFyZ3MgPSBfX2Fzc2lnbih7fSwgcHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFyZ3NbcHJvcGVydHlfMV0gPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UmVjdGFuZ2xlUGF0aChtb2RpZmllZEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCc7JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLnZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IF90aGlzLmdldFJlY3RhbmdsZVBhdGgobW9kaWZpZWRBcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbUFyZ3MgPSBfX2Fzc2lnbih7fSwgcHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BcmdzID0gX19hc3NpZ24oe30sIHByb3BzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUFyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBfdGhpcy5nZXRSZWN0YW5nbGVQYXRoKGZyb21BcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogX3RoaXMuZ2V0UmVjdGFuZ2xlUGF0aCh0b0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIFNWR19FTEVNRU5UUy5hbmltYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYW5pbWF0aW9uLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZEFuaW1hdGlvbkJhc2ljUHJvcGVydGllcygnZCcsIGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXMoYW5pbWF0aW9uLmVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljUmVjdGFuZ2xlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljUmVjdGFuZ2xlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJc29tZXRyaWNSZWN0YW5nbGUucHJvdG90eXBlLmFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYWRkQW5pbWF0aW9uLmNhbGwodGhpcywgYW5pbWF0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBJc29tZXRyaWNSZWN0YW5nbGU7XG59KElzb21ldHJpY1NoYXBlQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1JlY3RhbmdsZSB9O1xuIiwiZXhwb3J0IHsgSXNvbWV0cmljUmVjdGFuZ2xlIH0gZnJvbSAnLi9Jc29tZXRyaWNSZWN0YW5nbGUnO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgeyBDb21tYW5kLCBQbGFuZVZpZXcsIFNWR19FTEVNRU5UUywgU1ZHX05BTUVTUEFDRSB9IGZyb20gJ0Bjb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0U1ZHUGF0aCwgdHJhbnNsYXRlQ29tbWFuZFBvaW50cywgYWRkU1ZHUHJvcGVydGllcywgaXNTVkdQcm9wZXJ0eSB9IGZyb20gJ0B1dGlscy9zdmcnO1xuaW1wb3J0IHsgSXNvbWV0cmljU2hhcGVBYnN0cmFjdCB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY1NoYXBlQWJzdHJhY3QnO1xudmFyIElzb21ldHJpY0NpcmNsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY0NpcmNsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJc29tZXRyaWNDaXJjbGUocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJhZGl1cyA9IHByb3BzLnJhZGl1cywgcmVzdCA9IF9fcmVzdChwcm9wcywgW1wicmFkaXVzXCJdKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElzb21ldHJpY0NpcmNsZS5wcm90b3R5cGUuZ2V0Q29tbWFuZHMgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHZhciByaWdodCA9IChfYSA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5yaWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yaWdodDtcbiAgICAgICAgdmFyIGxlZnQgPSAoX2IgPSBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MubGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5sZWZ0O1xuICAgICAgICB2YXIgdG9wID0gKF9jID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnRvcCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy50b3A7XG4gICAgICAgIHZhciByYWRpdXMgPSAoX2QgPSBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MucmFkaXVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLnJhZGl1cztcbiAgICAgICAgdmFyIGNvbW1hbmRzID0gW107XG4gICAgICAgIHN3aXRjaCAodGhpcy5wbGFuZVZpZXcpIHtcbiAgICAgICAgICAgIGNhc2UgUGxhbmVWaWV3LkZST05UOlxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBDb21tYW5kLm1vdmUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB7IHI6IDAsIGw6IHJhZGl1cywgdDogMCB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBDb21tYW5kLmN1cnZlLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogeyByOiAwLCBsOiAtcmFkaXVzLCB0OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IHsgcjogMCwgbDogMCwgdDogLXJhZGl1cyB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBDb21tYW5kLmN1cnZlLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogeyByOiAwLCBsOiByYWRpdXMsIHQ6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogeyByOiAwLCBsOiAwLCB0OiByYWRpdXMgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbGFuZVZpZXcuU0lERTpcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogQ29tbWFuZC5tb3ZlLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogeyByOiAtcmFkaXVzLCBsOiAwLCB0OiAwIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQuY3VydmUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB7IHI6IHJhZGl1cywgbDogMCwgdDogMCB9LFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB7IHI6IDAsIGw6IDAsIHQ6IC1yYWRpdXMgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogQ29tbWFuZC5jdXJ2ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHsgcjogLXJhZGl1cywgbDogMCwgdDogMCB9LFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB7IHI6IDAsIGw6IDAsIHQ6IHJhZGl1cyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBsYW5lVmlldy5UT1A6XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQubW92ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHsgcjogMCwgbDogcmFkaXVzLCB0OiAwIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQuY3VydmUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB7IHI6IDAsIGw6IC1yYWRpdXMsIHQ6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogeyByOiByYWRpdXMsIGw6IDAsIHQ6IDAgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogQ29tbWFuZC5jdXJ2ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHsgcjogMCwgbDogcmFkaXVzLCB0OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IHsgcjogLXJhZGl1cywgbDogMCwgdDogMCB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNsYXRlQ29tbWFuZFBvaW50cyhjb21tYW5kcywgcmlnaHQsIGxlZnQsIHRvcCk7XG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICB9O1xuICAgIElzb21ldHJpY0NpcmNsZS5wcm90b3R5cGUuZ2V0Q2lyY2xlUGF0aCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IHRoaXMuZ2V0Q29tbWFuZHMoYXJncyk7XG4gICAgICAgIHJldHVybiBnZXRTVkdQYXRoKGNvbW1hbmRzLCB0aGlzLmRhdGEuY2VudGVyWCwgdGhpcy5kYXRhLmNlbnRlclksIHRoaXMuZGF0YS5zY2FsZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNDaXJjbGUucHJvdG90eXBlLnVwZGF0ZVN1YkNsYXNzQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgdmFyIGlzTmF0aXZlU1ZHUHJvcGVydHkgPSBpc1NWR1Byb3BlcnR5KGFuaW1hdGlvbi5wcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWlzTmF0aXZlU1ZHUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHNfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IF90aGlzLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBfdGhpcy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IF90aGlzLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBfdGhpcy5yYWRpdXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNfMSwgYW5pbWF0aW9uLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlfMSA9IGFuaW1hdGlvbi5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24udmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbmltYXRpb24udmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogYW5pbWF0aW9uLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRBcmdzID0gX19hc3NpZ24oe30sIHByb3BzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBcmdzW3Byb3BlcnR5XzFdID0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldENpcmNsZVBhdGgobW9kaWZpZWRBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignOycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZEFyZ3MgPSBfX2Fzc2lnbih7fSwgcHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBcmdzW3Byb3BlcnR5XzFdID0gK2FuaW1hdGlvbi52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBfdGhpcy5nZXRDaXJjbGVQYXRoKG1vZGlmaWVkQXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21BcmdzID0gX19hc3NpZ24oe30sIHByb3BzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21BcmdzW3Byb3BlcnR5XzFdID0gK2FuaW1hdGlvbi5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BcmdzW3Byb3BlcnR5XzFdID0gK2FuaW1hdGlvbi50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogX3RoaXMuZ2V0Q2lyY2xlUGF0aChmcm9tQXJncyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IF90aGlzLmdldENpcmNsZVBhdGgodG9BcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTkFNRVNQQUNFLCBTVkdfRUxFTUVOVFMuYW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmltYXRpb24uZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGFuaW1hdGlvbi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRBbmltYXRpb25CYXNpY1Byb3BlcnRpZXMoJ2QnLCBhbmltYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKGFuaW1hdGlvbi5lbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY0NpcmNsZS5wcm90b3R5cGUsIFwicmFkaXVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSXNvbWV0cmljQ2lyY2xlLnByb3RvdHlwZS5hZGRBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFkZEFuaW1hdGlvbi5jYWxsKHRoaXMsIGFuaW1hdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gSXNvbWV0cmljQ2lyY2xlO1xufShJc29tZXRyaWNTaGFwZUFic3RyYWN0KSk7XG5leHBvcnQgeyBJc29tZXRyaWNDaXJjbGUgfTtcbiIsImV4cG9ydCB7IElzb21ldHJpY0NpcmNsZSB9IGZyb20gJy4vSXNvbWV0cmljQ2lyY2xlJztcbiIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuaW1wb3J0IHsgQ29tbWFuZCwgUGxhbmVWaWV3LCBTVkdfRUxFTUVOVFMsIFNWR19OQU1FU1BBQ0UsIH0gZnJvbSAnQGNvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRTVkdQYXRoLCB0cmFuc2xhdGVDb21tYW5kUG9pbnRzLCBhZGRTVkdQcm9wZXJ0aWVzLCBpc1NWR1Byb3BlcnR5IH0gZnJvbSAnQHV0aWxzL3N2Zyc7XG5pbXBvcnQgeyBJc29tZXRyaWNTaGFwZUFic3RyYWN0IH0gZnJvbSAnQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljU2hhcGVBYnN0cmFjdCc7XG52YXIgSXNvbWV0cmljU3RhclBvbHlnb25BYnN0cmFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljU3RhclBvbHlnb25BYnN0cmFjdChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmFkaXVzID0gcHJvcHMucmFkaXVzLCBwb2ludHMgPSBwcm9wcy5wb2ludHMsIGRlbnNpdHkgPSBwcm9wcy5kZW5zaXR5LCBfYSA9IHByb3BzLnJvdGF0aW9uLCByb3RhdGlvbiA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcInJhZGl1c1wiLCBcInBvaW50c1wiLCBcImRlbnNpdHlcIiwgXCJyb3RhdGlvblwiXSk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3JhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgX3RoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICAgICAgX3RoaXMuX2RlbnNpdHkgPSBkZW5zaXR5O1xuICAgICAgICBfdGhpcy5fcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgX3RoaXMuX3NlY3RvciA9IDIgKiBNYXRoLlBJIC8gX3RoaXMuX3BvaW50cztcbiAgICAgICAgX3RoaXMuX2hhbGZTZWN0b3IgPSBfdGhpcy5fc2VjdG9yIC8gMjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0LnByb3RvdHlwZS5nZXRDb21tYW5kcyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdmFyIHJpZ2h0ID0gKF9hID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnJpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJpZ2h0O1xuICAgICAgICB2YXIgbGVmdCA9IChfYiA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5sZWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmxlZnQ7XG4gICAgICAgIHZhciB0b3AgPSAoX2MgPSBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MudG9wKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLnRvcDtcbiAgICAgICAgdmFyIHJhZGl1cyA9IChfZCA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5yYWRpdXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMucmFkaXVzO1xuICAgICAgICB2YXIgcG9pbnRzID0gKF9lID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnBvaW50cykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5fcG9pbnRzO1xuICAgICAgICB2YXIgZGVuc2l0eSA9IChfZiA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5kZW5zaXR5KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLl9kZW5zaXR5O1xuICAgICAgICB2YXIgcm90YXRpb24gPSAoX2cgPSBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3Mucm90YXRpb24pICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHRoaXMucm90YXRpb247XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHRoaXMuZ2V0MkRDb29yZGluYXRlcyhyYWRpdXMsIHBvaW50cywgZGVuc2l0eSwgcm90YXRpb24pO1xuICAgICAgICB2YXIgY29tbWFuZHMgPSBbXTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBsYW5lVmlldykge1xuICAgICAgICAgICAgY2FzZSBQbGFuZVZpZXcuRlJPTlQ6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogaW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IENvbW1hbmQubW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogQ29tbWFuZC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGw6IHBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogcG9pbnQueVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGxhbmVWaWV3LlNJREU6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogaW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IENvbW1hbmQubW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogQ29tbWFuZC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBwb2ludC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogcG9pbnQueVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGxhbmVWaWV3LlRPUDpcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBpbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gQ29tbWFuZC5tb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBDb21tYW5kLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IC1wb2ludC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGw6IC1wb2ludC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNsYXRlQ29tbWFuZFBvaW50cyhjb21tYW5kcywgcmlnaHQsIGxlZnQsIHRvcCk7XG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICB9O1xuICAgIElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QucHJvdG90eXBlLl9nZXRSYWRpYW5BbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH07XG4gICAgSXNvbWV0cmljU3RhclBvbHlnb25BYnN0cmFjdC5wcm90b3R5cGUuX2dldElubmVyUmFkaXVzID0gZnVuY3Rpb24gKHJhZGl1cywgcG9pbnRzLCBkZW5zaXR5KSB7XG4gICAgICAgIHJldHVybiByYWRpdXMgKiBNYXRoLmNvcyhNYXRoLlBJICogZGVuc2l0eSAvIHBvaW50cykgLyBNYXRoLmNvcyhNYXRoLlBJICogKGRlbnNpdHkgLSAxKSAvIHBvaW50cyk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0LnByb3RvdHlwZS5nZXQyRENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHJhZGl1cywgcG9pbnRzLCBkZW5zaXR5LCByb3RhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaW5uZXJSYWRpdXMgPSB0aGlzLl9nZXRJbm5lclJhZGl1cyhyYWRpdXMsIHBvaW50cywgZGVuc2l0eSk7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBBcnJheSh0aGlzLl9wb2ludHMpLCB0cnVlKS5yZWR1Y2UoZnVuY3Rpb24gKHBvaW50cywgX3VuZGVmaW5lZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGluZGV4ICogX3RoaXMuX3NlY3RvciArIDIgKiBNYXRoLlBJIC0gX3RoaXMuX2dldFJhZGlhbkFuZ2xlKHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHZhciBpbm5lckFuZ2xlID0gYW5nbGUgKyBfdGhpcy5faGFsZlNlY3RvcjtcbiAgICAgICAgICAgIHZhciBvWCA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHZhciBvWSA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHZhciBpWCA9IE1hdGguc2luKGlubmVyQW5nbGUpICogaW5uZXJSYWRpdXM7XG4gICAgICAgICAgICB2YXIgaVkgPSBNYXRoLmNvcyhpbm5lckFuZ2xlKSAqIGlubmVyUmFkaXVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcG9pbnRzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgIHsgeDogb1gsIHk6IG9ZIH0sXG4gICAgICAgICAgICAgICAgeyB4OiBpWCwgeTogaVkgfVxuICAgICAgICAgICAgXSwgZmFsc2UpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0LnByb3RvdHlwZS5nZXRQZW50YWdyYW1QYXRoID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbW1hbmRzID0gdGhpcy5nZXRDb21tYW5kcyhhcmdzKTtcbiAgICAgICAgcmV0dXJuIGdldFNWR1BhdGgoY29tbWFuZHMsIHRoaXMuZGF0YS5jZW50ZXJYLCB0aGlzLmRhdGEuY2VudGVyWSwgdGhpcy5kYXRhLnNjYWxlLCB0cnVlKTtcbiAgICB9O1xuICAgIElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QucHJvdG90eXBlLnVwZGF0ZVN1YkNsYXNzQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgdmFyIGlzTmF0aXZlU1ZHUHJvcGVydHkgPSBpc1NWR1Byb3BlcnR5KGFuaW1hdGlvbi5wcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWlzTmF0aXZlU1ZHUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHNfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IF90aGlzLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBfdGhpcy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IF90aGlzLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBfdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogX3RoaXMuX3BvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eTogX3RoaXMuX2RlbnNpdHksXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBfdGhpcy5yb3RhdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wc18xLCBhbmltYXRpb24ucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV8xID0gYW5pbWF0aW9uLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFuaW1hdGlvbi52YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBhbmltYXRpb24udmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZEFyZ3MgPSBfX2Fzc2lnbih7fSwgcHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFyZ3NbcHJvcGVydHlfMV0gPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UGVudGFncmFtUGF0aChtb2RpZmllZEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCc7JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLnZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IF90aGlzLmdldFBlbnRhZ3JhbVBhdGgobW9kaWZpZWRBcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbUFyZ3MgPSBfX2Fzc2lnbih7fSwgcHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BcmdzID0gX19hc3NpZ24oe30sIHByb3BzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUFyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBfdGhpcy5nZXRQZW50YWdyYW1QYXRoKGZyb21BcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogX3RoaXMuZ2V0UGVudGFncmFtUGF0aCh0b0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIFNWR19FTEVNRU5UUy5hbmltYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYW5pbWF0aW9uLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZEFuaW1hdGlvbkJhc2ljUHJvcGVydGllcygnZCcsIGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXMoYW5pbWF0aW9uLmVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljU3RhclBvbHlnb25BYnN0cmFjdC5wcm90b3R5cGUsIFwicmFkaXVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QucHJvdG90eXBlLmFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYWRkQW5pbWF0aW9uLmNhbGwodGhpcywgYW5pbWF0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0O1xufShJc29tZXRyaWNTaGFwZUFic3RyYWN0KSk7XG5leHBvcnQgeyBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0IH07XG4iLCJleHBvcnQgeyBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0IH0gZnJvbSAnLi9Jc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0JztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBJc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0IH0gZnJvbSAnQGNsYXNzZXMvYWJzdHJhY3QvSXNvbWV0cmljU3RhclBvbHlnb25BYnN0cmFjdCc7XG52YXIgSXNvbWV0cmljUGVudGFncmFtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXNvbWV0cmljUGVudGFncmFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzb21ldHJpY1BlbnRhZ3JhbShwcm9wcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzKSwgeyBwb2ludHM6IDUsIGRlbnNpdHk6IDIgfSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJc29tZXRyaWNQZW50YWdyYW07XG59KElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1BlbnRhZ3JhbSB9O1xuIiwiZXhwb3J0IHsgSXNvbWV0cmljUGVudGFncmFtIH0gZnJvbSAnLi9Jc29tZXRyaWNQZW50YWdyYW0nO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QgfSBmcm9tICdAY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNTdGFyUG9seWdvbkFic3RyYWN0JztcbnZhciBJc29tZXRyaWNTdGFyUG9seWdvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY1N0YXJQb2x5Z29uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzb21ldHJpY1N0YXJQb2x5Z29uKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1N0YXJQb2x5Z29uLnByb3RvdHlwZSwgXCJwb2ludHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NlY3RvciA9IDIgKiBNYXRoLlBJIC8gdGhpcy5fcG9pbnRzO1xuICAgICAgICAgICAgdGhpcy5faGFsZlNlY3RvciA9IHRoaXMuX3NlY3RvciAvIDI7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1N0YXJQb2x5Z29uLnByb3RvdHlwZSwgXCJkZW5zaXR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVuc2l0eTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbnNpdHkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSXNvbWV0cmljU3RhclBvbHlnb247XG59KElzb21ldHJpY1N0YXJQb2x5Z29uQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1N0YXJQb2x5Z29uIH07XG4iLCJleHBvcnQgeyBJc29tZXRyaWNTdGFyUG9seWdvbiB9IGZyb20gJy4vSXNvbWV0cmljU3RhclBvbHlnb24nO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IENvbW1hbmQsIFNWR19FTEVNRU5UUywgU1ZHX05BTUVTUEFDRSB9IGZyb20gJ0Bjb25zdGFudHMnO1xuaW1wb3J0IHsgYWRkU1ZHUHJvcGVydGllcywgcGFyc2VEcmF3Q29tbWFuZHMsIGdldFNWR1BhdGggfSBmcm9tICdAdXRpbHMvc3ZnJztcbmltcG9ydCB7IElzb21ldHJpY1BhdGhBYnN0cmFjdCB9IGZyb20gJ0BjbGFzc2VzL2Fic3RyYWN0L0lzb21ldHJpY1BhdGhBYnN0cmFjdCc7XG52YXIgSXNvbWV0cmljUGF0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY1BhdGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljUGF0aChwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgeyBwcm9wcyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzLCBTVkdfRUxFTUVOVFMucGF0aCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZ2V0UGF0aEZyb21Db21tYW5kcyA9IGZ1bmN0aW9uIChjb21tYW5kcykgeyByZXR1cm4gZ2V0U1ZHUGF0aChwYXJzZURyYXdDb21tYW5kcyhjb21tYW5kcyksIF90aGlzLmRhdGEuY2VudGVyWCwgX3RoaXMuZGF0YS5jZW50ZXJZLCBfdGhpcy5kYXRhLnNjYWxlLCBfdGhpcy5fYXV0b2Nsb3NlKTsgfTtcbiAgICAgICAgX3RoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2F1dG9jbG9zZSA9ICdhdXRvY2xvc2UnIGluIHByb3BzXG4gICAgICAgICAgICA/IHByb3BzLmF1dG9jbG9zZVxuICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElzb21ldHJpY1BhdGgucHJvdG90eXBlLnVwZGF0ZVN1YkNsYXNzQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5wcm9wZXJ0eSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogQXJyYXkuaXNBcnJheShhbmltYXRpb24udmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYW5pbWF0aW9uLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRQYXRoRnJvbUNvbW1hbmRzKFwiXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignOycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5nZXRQYXRoRnJvbUNvbW1hbmRzKFwiXCIuY29uY2F0KGFuaW1hdGlvbi52YWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IF90aGlzLmdldFBhdGhGcm9tQ29tbWFuZHMoXCJcIi5jb25jYXQoYW5pbWF0aW9uLmZyb20pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBfdGhpcy5nZXRQYXRoRnJvbUNvbW1hbmRzKFwiXCIuY29uY2F0KGFuaW1hdGlvbi50bykpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgU1ZHX0VMRU1FTlRTLmFuaW1hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChhbmltYXRpb24uZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmFkZEFuaW1hdGlvbkJhc2ljUHJvcGVydGllcygnZCcsIGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhhbmltYXRpb24uZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSXNvbWV0cmljUGF0aC5wcm90b3R5cGUuZ2V0Q29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1BhdGgucHJvdG90eXBlLCBcImF1dG9jbG9zZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9jbG9zZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9jbG9zZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIElzb21ldHJpY1BhdGgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljKHVuZGVmaW5lZCwgdGhpcy5hdXRvY2xvc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIElzb21ldHJpY1BhdGgucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnNwbGljZSgwKTtcbiAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICAgIGQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIElzb21ldHJpY1BhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIChyaWdodCwgbGVmdCwgdG9wKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICBjb21tYW5kOiBDb21tYW5kLm1vdmUsXG4gICAgICAgICAgICBwb2ludDogeyByOiByaWdodCwgbDogbGVmdCwgdDogdG9wIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQubGluZSxcbiAgICAgICAgICAgIHBvaW50OiB7IHI6IHJpZ2h0LCBsOiBsZWZ0LCB0OiB0b3AgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJc29tZXRyaWNQYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gZnVuY3Rpb24gKGNvbnRyb2xSaWdodCwgY29udHJvbExlZnQsIGNvbnRyb2xUb3AsIHJpZ2h0LCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IENvbW1hbmQuY3VydmUsXG4gICAgICAgICAgICBjb250cm9sOiB7IHI6IGNvbnRyb2xSaWdodCwgbDogY29udHJvbExlZnQsIHQ6IGNvbnRyb2xUb3AgfSxcbiAgICAgICAgICAgIHBvaW50OiB7IHI6IHJpZ2h0LCBsOiBsZWZ0LCB0OiB0b3AgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJc29tZXRyaWNQYXRoLnByb3RvdHlwZS5tdCA9IGZ1bmN0aW9uIChyaWdodCwgbGVmdCwgdG9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVUbyhyaWdodCwgbGVmdCwgdG9wKTtcbiAgICB9O1xuICAgIElzb21ldHJpY1BhdGgucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVRvKHJpZ2h0LCBsZWZ0LCB0b3ApO1xuICAgIH07XG4gICAgSXNvbWV0cmljUGF0aC5wcm90b3R5cGUuY3QgPSBmdW5jdGlvbiAoY29udHJvbFJpZ2h0LCBjb250cm9sTGVmdCwgY29udHJvbFRvcCwgcmlnaHQsIGxlZnQsIHRvcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZVRvKGNvbnRyb2xSaWdodCwgY29udHJvbExlZnQsIGNvbnRyb2xUb3AsIHJpZ2h0LCBsZWZ0LCB0b3ApO1xuICAgIH07XG4gICAgSXNvbWV0cmljUGF0aC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gcGFyc2VEcmF3Q29tbWFuZHMoY29tbWFuZHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIElzb21ldHJpY1BhdGgucHJvdG90eXBlLmFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYWRkQW5pbWF0aW9uLmNhbGwodGhpcywgYW5pbWF0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBJc29tZXRyaWNQYXRoO1xufShJc29tZXRyaWNQYXRoQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1BhdGggfTtcbiIsImV4cG9ydCAqIGZyb20gJy4vSXNvbWV0cmljUGF0aCc7XG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IFNWR19OQU1FU1BBQ0UsIFNWR19FTEVNRU5UUywgT1JJR0lOIH0gZnJvbSAnQGNvbnN0YW50cyc7XG5pbXBvcnQgeyBJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QgfSBmcm9tICdAY2xhc3Nlcy9hYnN0cmFjdC9Jc29tZXRyaWNHcmFwaGljQWJzdHJhY3QnO1xuaW1wb3J0IHsgZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQgfSBmcm9tICdAdXRpbHMvbWF0aCc7XG5pbXBvcnQgeyBhZGRTVkdQcm9wZXJ0aWVzLCBlbGVtZW50SGFzU1ZHUGFyZW50LCBnZXRQYXR0ZXJuVHJhbnNmb3JtLCBpc1NWR1Byb3BlcnR5IH0gZnJvbSAnQHV0aWxzL3N2Zyc7XG52YXIgSXNvbWV0cmljVGV4dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzb21ldHJpY1RleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNvbWV0cmljVGV4dChwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwbGFuZVZpZXcgPSBwcm9wcy5wbGFuZVZpZXcsIF9iID0gcHJvcHMudGV4dCwgdGV4dCA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iLCBfYyA9IHByb3BzLmZvbnRGYW1pbHksIGZvbnRGYW1pbHkgPSBfYyA9PT0gdm9pZCAwID8gJ0FyaWFsJyA6IF9jLCBfZCA9IHByb3BzLmZvbnRTaXplLCBmb250U2l6ZSA9IF9kID09PSB2b2lkIDAgPyAxMiA6IF9kLCBfZSA9IHByb3BzLmZvbnRTdHlsZSwgZm9udFN0eWxlID0gX2UgPT09IHZvaWQgMCA/ICdub3JtYWwnIDogX2UsIF9mID0gcHJvcHMuZm9udFdlaWdodCwgZm9udFdlaWdodCA9IF9mID09PSB2b2lkIDAgPyAnbm9ybWFsJyA6IF9mLCBfZyA9IHByb3BzLm9yaWdpbiwgb3JpZ2luID0gX2cgPT09IHZvaWQgMCA/IFsnY2VudGVyJywgJ2NlbnRlciddIDogX2csIF9oID0gcHJvcHMucmlnaHQsIHJpZ2h0ID0gX2ggPT09IHZvaWQgMCA/IDAgOiBfaCwgX2ogPSBwcm9wcy5sZWZ0LCBsZWZ0ID0gX2ogPT09IHZvaWQgMCA/IDAgOiBfaiwgX2sgPSBwcm9wcy50b3AsIHRvcCA9IF9rID09PSB2b2lkIDAgPyAwIDogX2ssIF9sID0gcHJvcHMucm90YXRpb24sIHJvdGF0aW9uID0gX2wgPT09IHZvaWQgMCA/IDAgOiBfbCwgX20gPSBwcm9wcy5zZWxlY3RhYmxlLCBzZWxlY3RhYmxlID0gX20gPT09IHZvaWQgMCA/IHRydWUgOiBfbSwgcmVzdCA9IF9fcmVzdChwcm9wcywgW1wicGxhbmVWaWV3XCIsIFwidGV4dFwiLCBcImZvbnRGYW1pbHlcIiwgXCJmb250U2l6ZVwiLCBcImZvbnRTdHlsZVwiLCBcImZvbnRXZWlnaHRcIiwgXCJvcmlnaW5cIiwgXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJyb3RhdGlvblwiLCBcInNlbGVjdGFibGVcIl0pO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlc3QsIFNWR19FTEVNRU5UUy5ncm91cCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX29yaWdpbkhhc2ggPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW09SSUdJTi5DRU5URVJdID0gJ21pZGRsZScsXG4gICAgICAgICAgICBfYVtPUklHSU4uTEVGVF0gPSAnc3RhcnQnLFxuICAgICAgICAgICAgX2FbT1JJR0lOLlJJR0hUXSA9ICdlbmQnLFxuICAgICAgICAgICAgX2FbT1JJR0lOLlRPUF0gPSAnaGFuZ2luZycsXG4gICAgICAgICAgICBfYVtPUklHSU4uQk9UVE9NXSA9ICdiYXNlbGluZScsXG4gICAgICAgICAgICBfYSk7XG4gICAgICAgIF90aGlzLmNvbW1vbkFuaW1hdGlvbkF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAndHJhbnNmb3JtJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGU6ICdYTUwnLFxuICAgICAgICAgICAgYWRkaXRpdmU6ICdzdW0nLFxuICAgICAgICAgICAgZmlsbDogJ2ZyZWV6ZSdcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TWF0cml4VHJhbnNmb3JtID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtTWF0cml4ID0gZ2V0UGF0dGVyblRyYW5zZm9ybShfdGhpcy5nZXRQb3NpdGlvblRyYW5zZm9ybShwcm9wcyksIF90aGlzLnBsYW5lVmlldywgMSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodHJhbnNmb3JtTWF0cml4LCBcIiByb3RhdGUoXCIpLmNvbmNhdChfdGhpcy5yb3RhdGlvbiwgXCIpXCIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fdGV4dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgU1ZHX0VMRU1FTlRTLnRleHQpO1xuICAgICAgICBfdGhpcy5fdHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgU1ZHX0VMRU1FTlRTLnRzcGFuKTtcbiAgICAgICAgX3RoaXMuX3RleHRFbGVtZW50LmFwcGVuZENoaWxkKF90aGlzLl90c3Bhbik7XG4gICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuX3RleHRFbGVtZW50KTtcbiAgICAgICAgX3RoaXMucGxhbmVWaWV3ID0gcGxhbmVWaWV3O1xuICAgICAgICBfdGhpcy5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgX3RoaXMuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgX3RoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICBfdGhpcy5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgX3RoaXMuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGU7XG4gICAgICAgIF90aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgX3RoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgX3RoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIF90aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgX3RoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgX3RoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSXNvbWV0cmljVGV4dC5wcm90b3R5cGUuZ2V0UG9zaXRpb25UcmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMsIGZyb21DZW50ZXIpIHtcbiAgICAgICAgaWYgKGZyb21DZW50ZXIgPT09IHZvaWQgMCkgeyBmcm9tQ2VudGVyID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gZ2V0UG9pbnRGcm9tSXNvbWV0cmljUG9pbnQoZnJvbUNlbnRlclxuICAgICAgICAgICAgPyB0aGlzLmRhdGEuY2VudGVyWFxuICAgICAgICAgICAgOiAwLCBmcm9tQ2VudGVyXG4gICAgICAgICAgICA/IHRoaXMuZGF0YS5jZW50ZXJZXG4gICAgICAgICAgICA6IDAsIHtcbiAgICAgICAgICAgIHI6IHByb3BzLnJpZ2h0LFxuICAgICAgICAgICAgbDogcHJvcHMubGVmdCxcbiAgICAgICAgICAgIHQ6IHByb3BzLnRvcFxuICAgICAgICB9LCB0aGlzLmRhdGEuc2NhbGUpO1xuICAgIH07XG4gICAgSXNvbWV0cmljVGV4dC5wcm90b3R5cGUudXBkYXRlU3ViQ2xhc3NBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgdmFyIGlzTmF0aXZlU1ZHUHJvcGVydHkgPSBpc1NWR1Byb3BlcnR5KGFuaW1hdGlvbi5wcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWlzTmF0aXZlU1ZHUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBhbmltYXRpb24ucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV8xID0gYW5pbWF0aW9uLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSb3RhdGlvbl8xID0gcHJvcGVydHlfMSA9PT0gJ3JvdGF0aW9uJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1vblByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLmNvbW1vbkFuaW1hdGlvbkF0dHJpYnV0ZXMpLCB7IHR5cGU6IGlzUm90YXRpb25fMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JvdGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICd0cmFuc2xhdGUnLCBiZWdpbjogJ2luZGVmaW5pdGUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFuaW1hdGlvbi52YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IF9fYXNzaWduKHsgdmFsdWVzOiBhbmltYXRpb24udmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JvdGF0aW9uXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBcmdzW3Byb3BlcnR5XzFdID0gK3ZhbHVlIC0gX3RoaXNbcHJvcGVydHlfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IF90aGlzLmdldFBvc2l0aW9uVHJhbnNmb3JtKG1vZGlmaWVkQXJncywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjb29yZHMueCwgXCIsXCIpLmNvbmNhdChjb29yZHMueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJzsnKSB9LCBjb21tb25Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSb3RhdGlvbl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBfX2Fzc2lnbih7IHZhbHVlczogXCJcIi5jb25jYXQoYW5pbWF0aW9uLnZhbHVlcykgfSwgY29tbW9uUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkQXJnc1twcm9wZXJ0eV8xXSA9ICthbmltYXRpb24udmFsdWVzIC0gX3RoaXNbcHJvcGVydHlfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBfdGhpcy5nZXRQb3NpdGlvblRyYW5zZm9ybShtb2RpZmllZEFyZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IF9fYXNzaWduKHsgdmFsdWVzOiBcIlwiLmNvbmNhdChjb29yZHMueCwgXCIsXCIpLmNvbmNhdChjb29yZHMueSkgfSwgY29tbW9uUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JvdGF0aW9uXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gX19hc3NpZ24oeyBmcm9tOiBcIlwiLmNvbmNhdChhbmltYXRpb24uZnJvbSksIHRvOiBcIlwiLmNvbmNhdChhbmltYXRpb24udG8pIH0sIGNvbW1vblByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQXJncyA9IF9fYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUFyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLmZyb20gLSBfdGhpc1twcm9wZXJ0eV8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0FyZ3NbcHJvcGVydHlfMV0gPSArYW5pbWF0aW9uLnRvIC0gX3RoaXNbcHJvcGVydHlfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3Jkc0Zyb20gPSBfdGhpcy5nZXRQb3NpdGlvblRyYW5zZm9ybShmcm9tQXJncywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHNUbyA9IF90aGlzLmdldFBvc2l0aW9uVHJhbnNmb3JtKHRvQXJncywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBfX2Fzc2lnbih7IGZyb206IFwiXCIuY29uY2F0KGNvb3Jkc0Zyb20ueCwgXCIsXCIpLmNvbmNhdChjb29yZHNGcm9tLnkpLCB0bzogXCJcIi5jb25jYXQoY29vcmRzVG8ueCwgXCIsXCIpLmNvbmNhdChjb29yZHNUby55KSB9LCBjb21tb25Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmltYXRpb24uZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgU1ZHX0VMRU1FTlRTLmFuaW1hdGVUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZEFuaW1hdGlvbkJhc2ljUHJvcGVydGllcygndHJhbnNmb3JtJywgYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyhhbmltYXRpb24uZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUm90YXRpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWxlbWVudC5hcHBlbmRDaGlsZChhbmltYXRpb24uZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGFuaW1hdGlvbi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5lbGVtZW50LmJlZ2luRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSXNvbWV0cmljVGV4dC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZWxlbWVudEhhc1NWR1BhcmVudCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRNYXRyaXhUcmFuc2Zvcm0oe1xuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5fdGV4dEVsZW1lbnQsIHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSk7XG4gICAgICAgICAgICB0aGlzLl90c3Bhbi50ZXh0Q29udGVudCA9IHRoaXMuX3RleHQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhdHRlcm5UcmFuc2Zvcm0oeyB4OiAwLCB5OiAwIH0sIHRoaXMucGxhbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSXNvbWV0cmljVGV4dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNUZXh0LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljVGV4dC5wcm90b3R5cGUsIFwicGxhbmVWaWV3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhbmVWaWV3O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGxhbmVWaWV3ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1RleHQucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb250RmFtaWx5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9udEZhbWlseSA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLl90c3Bhbiwge1xuICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IHRoaXMuX2ZvbnRGYW1pbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1RleHQucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IHZhbHVlO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLl90c3Bhbiwge1xuICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBcIlwiLmNvbmNhdCh0aGlzLl9mb250U2l6ZSwgXCJweFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljVGV4dC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9udFN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgICBhZGRTVkdQcm9wZXJ0aWVzKHRoaXMuX3RzcGFuLCB7XG4gICAgICAgICAgICAgICAgJ2ZvbnQtc3R5bGUnOiBcIlwiLmNvbmNhdCh0aGlzLl9mb250U3R5bGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNUZXh0LnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5fdHNwYW4sIHtcbiAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnOiBcIlwiLmNvbmNhdCh0aGlzLl9mb250V2VpZ2h0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXNvbWV0cmljVGV4dC5wcm90b3R5cGUsIFwic2VsZWN0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGFibGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RhYmxlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNWR1Byb3BlcnRpZXModGhpcy5fdGV4dEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICctd2Via2l0LXVzZXItc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICctbW96LXVzZXItc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICctbXMtdXNlci1zZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXItc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cydcbiAgICAgICAgICAgICAgICAgICAgXS5tYXAoZnVuY3Rpb24gKGRlY2wpIHsgcmV0dXJuIFwiXCIuY29uY2F0KGRlY2wsIFwiOiBub25lXCIpOyB9KS5qb2luKCc7JylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNUZXh0LnByb3RvdHlwZSwgXCJvcmlnaW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuX29yaWdpbiwgdGV4dEFuY2hvciA9IF9hWzBdLCBhbGlnbm1lbnRCYXNlbGluZSA9IF9hWzFdO1xuICAgICAgICAgICAgYWRkU1ZHUHJvcGVydGllcyh0aGlzLl90c3Bhbiwge1xuICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6IHRoaXMuX29yaWdpbkhhc2hbdGV4dEFuY2hvcl0sXG4gICAgICAgICAgICAgICAgJ2FsaWdubWVudC1iYXNlbGluZSc6IHRoaXMuX29yaWdpbkhhc2hbYWxpZ25tZW50QmFzZWxpbmVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNUZXh0LnByb3RvdHlwZSwgXCJyaWdodFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JpZ2h0ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNUZXh0LnByb3RvdHlwZSwgXCJsZWZ0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZWZ0ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElzb21ldHJpY1RleHQucHJvdG90eXBlLCBcInRvcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3AgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9wID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJc29tZXRyaWNUZXh0LnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBJc29tZXRyaWNUZXh0O1xufShJc29tZXRyaWNHcmFwaGljQWJzdHJhY3QpKTtcbmV4cG9ydCB7IElzb21ldHJpY1RleHQgfTtcbiIsImV4cG9ydCB7IElzb21ldHJpY1RleHQgfSBmcm9tICcuL0lzb21ldHJpY1RleHQnO1xuIiwiZXhwb3J0IHsgTGluZUNhcCwgTGluZUpvaW4sIFBsYW5lVmlldywgQXhpcyB9IGZyb20gJ0Bjb25zdGFudHMnO1xuZXhwb3J0IHsgSXNvbWV0cmljQ2FudmFzIH0gZnJvbSAnQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY0NhbnZhcyc7XG5leHBvcnQgeyBJc29tZXRyaWNHcm91cCB9IGZyb20gJ0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNHcm91cCc7XG5leHBvcnQgeyBJc29tZXRyaWNSZWN0YW5nbGUgfSBmcm9tICdAY2xhc3Nlcy9wdWJsaWMvSXNvbWV0cmljUmVjdGFuZ2xlJztcbmV4cG9ydCB7IElzb21ldHJpY0NpcmNsZSB9IGZyb20gJ0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNDaXJjbGUnO1xuZXhwb3J0IHsgSXNvbWV0cmljUGVudGFncmFtIH0gZnJvbSAnQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY1BlbnRhZ3JhbSc7XG5leHBvcnQgeyBJc29tZXRyaWNTdGFyUG9seWdvbiB9IGZyb20gJ0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNTdGFyUG9seWdvbic7XG5leHBvcnQgeyBJc29tZXRyaWNQYXRoIH0gZnJvbSAnQGNsYXNzZXMvcHVibGljL0lzb21ldHJpY1BhdGgnO1xuZXhwb3J0IHsgSXNvbWV0cmljVGV4dCB9IGZyb20gJ0BjbGFzc2VzL3B1YmxpYy9Jc29tZXRyaWNUZXh0JztcbiIsImV4cG9ydCBkZWZhdWx0ICggSXNvbWV0cmljTW9kdWxlLCBjb250YWluZXIgKSA9PiB7XG5cbiAgICBjb25zdCB7IElzb21ldHJpY0NhbnZhcywgSXNvbWV0cmljUmVjdGFuZ2xlLCBQbGFuZVZpZXcgfSA9IElzb21ldHJpY01vZHVsZTtcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNvbG9yKCkge1xuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IHRoaXMuZmlsbENvbG9yID09PSAnd2hpdGUnID8gJyNFRUUnIDogJ3doaXRlJztcbiAgICB9XG5cbiAgICBjb25zdCBjdWJlID0gbmV3IElzb21ldHJpY0NhbnZhcyh7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI0NDQycsXG4gICAgICAgIHNjYWxlOiAxMjAsXG4gICAgICAgIHdpZHRoOiA1MDAsXG4gICAgICAgIGhlaWdodDogMzIwXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtoZWlnaHQ6IDEsIHdpZHRoOiAxfTtcbiAgICBjb25zdCB0b3BQaWVjZSA9IG5ldyBJc29tZXRyaWNSZWN0YW5nbGUoey4uLmNvbW1vblByb3BzLCBwbGFuZVZpZXc6IFBsYW5lVmlldy5UT1B9KTtcbiAgICBjb25zdCByaWdodFBpZWNlID0gbmV3IElzb21ldHJpY1JlY3RhbmdsZSh7Li4uY29tbW9uUHJvcHMsIHBsYW5lVmlldzogUGxhbmVWaWV3LkZST05UfSk7XG4gICAgY29uc3QgbGVmdFBpZWNlID0gbmV3IElzb21ldHJpY1JlY3RhbmdsZSh7Li4uY29tbW9uUHJvcHMsIHBsYW5lVmlldzogUGxhbmVWaWV3LlNJREV9KTtcblxuICAgIHRvcFBpZWNlLnRvcCA9IDE7XG4gICAgdG9wUGllY2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0b2dnbGVDb2xvciwgdHJ1ZSk7XG5cbiAgICByaWdodFBpZWNlLnJpZ2h0ID0gMTtcbiAgICByaWdodFBpZWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdG9nZ2xlQ29sb3IsIHRydWUpO1xuXG4gICAgbGVmdFBpZWNlLmxlZnQgPSAxO1xuICAgIGxlZnRQaWVjZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZUNvbG9yLCB0cnVlKTtcblxuICAgIGN1YmVcbiAgICAgICAgLmFkZENoaWxkKHRvcFBpZWNlKVxuICAgICAgICAuYWRkQ2hpbGQocmlnaHRQaWVjZSlcbiAgICAgICAgLmFkZENoaWxkKGxlZnRQaWVjZSk7XG5cbn07IiwiZXhwb3J0IGRlZmF1bHQgKCBJc29tZXRyaWNNb2R1bGUsIGNvbnRhaW5lciApID0+IHtcblxuICAgIGNvbnN0IHsgSXNvbWV0cmljQ2FudmFzLCBJc29tZXRyaWNQYXRoLCBJc29tZXRyaWNSZWN0YW5nbGUsIElzb21ldHJpY1BlbnRhZ3JhbSwgUGxhbmVWaWV3IH0gPSBJc29tZXRyaWNNb2R1bGU7XG5cbiAgICBjb25zdCBjdWJlID0gbmV3IElzb21ldHJpY0NhbnZhcyh7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI0NDQycsXG4gICAgICAgIHNjYWxlOiAxMjAsXG4gICAgICAgIHdpZHRoOiA1MDAsXG4gICAgICAgIGhlaWdodDogMzIwXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtoZWlnaHQ6IDEsIHdpZHRoOiAxfTtcblxuICAgIGNvbnN0IGR1cmF0aW9uID0gMztcblxuICAgIGNvbnN0IHJlY3RhbmdsZUFuaW1hdGlvblByb3BzID0ge1xuICAgICAgICBwcm9wZXJ0eTogJ2hlaWdodCcsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICB2YWx1ZXM6IFsxLCAwLjUsIDFdXG4gICAgfTtcblxuICAgIGNvbnN0IGNvbG9yQW5pbWF0aW9uUHJvcHMgPSB7XG4gICAgICAgIHByb3BlcnR5OiAnZmlsbENvbG9yJyxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIHZhbHVlczogWycjRkZGJywgJyNEREQnLCAnI0ZGRiddXG4gICAgfTtcblxuICAgIGNvbnN0IHRvcFBpZWNlID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCBzdGFyID0gbmV3IElzb21ldHJpY1BlbnRhZ3JhbSh7IHJhZGl1czogMC4zNSwgcGxhbmVWaWV3OiBQbGFuZVZpZXcuVE9QLCByaWdodDogMC41LCBsZWZ0OiAwLjUsIHRvcDogMX0pO1xuICAgIGNvbnN0IHJpZ2h0UGllY2UgPSBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHsuLi5jb21tb25Qcm9wcywgcGxhbmVWaWV3OiBQbGFuZVZpZXcuRlJPTlQsIHJpZ2h0OiAxfSk7XG4gICAgY29uc3QgbGVmdFBpZWNlID0gbmV3IElzb21ldHJpY1JlY3RhbmdsZSh7Li4uY29tbW9uUHJvcHMsIHBsYW5lVmlldzogUGxhbmVWaWV3LlNJREUsIGxlZnQ6IDF9KTtcblxuICAgIHRvcFBpZWNlXG4gICAgICAgIC5tb3ZlVG8oMCwgMCwgMSlcbiAgICAgICAgLmxpbmVUbygxLCAwLCAxKVxuICAgICAgICAubGluZVRvKDEsIDEsIDEpXG4gICAgICAgIC5saW5lVG8oMCwgMSwgMSk7XG5cbiAgICB0b3BQaWVjZVxuICAgICAgICAuYWRkQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiAncGF0aCcsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICAgICdNMCAwIDEgTDEgMCAxIEwxIDEgMSBMMCAxIDEnLFxuICAgICAgICAgICAgICAgICdNMCAwIDAuNSBMMSAwIDAuNSBMMSAxIDAuNSBMMCAxIDAuNScsXG4gICAgICAgICAgICAgICAgJ00wIDAgMSBMMSAwIDEgTDEgMSAxIEwwIDEgMSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgICAgLmFkZEFuaW1hdGlvbihjb2xvckFuaW1hdGlvblByb3BzKTtcblxuICAgIHN0YXJcbiAgICAgICAgLmFkZEFuaW1hdGlvbih7XG4gICAgICAgICAgICBwcm9wZXJ0eTogJ3RvcCcsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHZhbHVlczogWzEsIDAuNSwgMV1cbiAgICAgICAgfSk7XG5cbiAgICByaWdodFBpZWNlXG4gICAgICAgIC5hZGRBbmltYXRpb24ocmVjdGFuZ2xlQW5pbWF0aW9uUHJvcHMpXG4gICAgICAgIC5hZGRBbmltYXRpb24oY29sb3JBbmltYXRpb25Qcm9wcyk7XG5cbiAgICBsZWZ0UGllY2VcbiAgICAgICAgLmFkZEFuaW1hdGlvbihyZWN0YW5nbGVBbmltYXRpb25Qcm9wcylcbiAgICAgICAgLmFkZEFuaW1hdGlvbihjb2xvckFuaW1hdGlvblByb3BzKTtcblxuICAgIGN1YmUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2VBbmltYXRpb25zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZUFuaW1hdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY3ViZS5hZGRDaGlsZHJlbih0b3BQaWVjZSwgcmlnaHRQaWVjZSwgbGVmdFBpZWNlLCBzdGFyKTtcblxufTsiLCJpbXBvcnQgJy4uL2ltYWdlcy9ibG9ja19zaWRlLnBuZyc7XG5pbXBvcnQgJy4uL2ltYWdlcy9ibG9ja190b3AucG5nJztcblxuZXhwb3J0IGRlZmF1bHQgKCBJc29tZXRyaWNNb2R1bGUsIGNvbnRhaW5lciApID0+IHtcblxuICAgIGNvbnN0IHsgSXNvbWV0cmljQ2FudmFzLCBJc29tZXRyaWNSZWN0YW5nbGUsIElzb21ldHJpY1RleHQsIFBsYW5lVmlldyB9ID0gSXNvbWV0cmljTW9kdWxlO1xuXG4gICAgY29uc3QgY3ViZSA9IG5ldyBJc29tZXRyaWNDYW52YXMoe1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNDQ0MnLFxuICAgICAgICBzY2FsZTogMTIwLFxuICAgICAgICB3aWR0aDogNTAwLFxuICAgICAgICBoZWlnaHQ6IDMyMFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVjdGFuZ2xlQ29tbW9uUHJvcHMgPSB7IGhlaWdodDogMSwgd2lkdGg6IDEgfTtcblxuICAgIGNvbnN0IHRleHRDb21tb25Qcm9wcyA9IHtcbiAgICAgICAgZm9udFNpemU6IDE1LFxuICAgICAgICBmaWxsQ29sb3I6ICcjNjY2JyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIHJpZ2h0OiAwLjUsXG4gICAgICAgIGxlZnQ6IDAuNSxcbiAgICAgICAgdG9wOiAwLjUsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0IHBpZWNlcyA9IFtQbGFuZVZpZXcuVE9QLCBQbGFuZVZpZXcuRlJPTlQsIFBsYW5lVmlldy5TSURFXS5tYXAoKHZpZXcsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmYWNlOiBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHsuLi5yZWN0YW5nbGVDb21tb25Qcm9wcywgcGxhbmVWaWV3OiB2aWV3fSksXG4gICAgICAgICAgICBsYWJlbDogbmV3IElzb21ldHJpY1RleHQoey4uLnRleHRDb21tb25Qcm9wcywgcGxhbmVWaWV3OiB2aWV3fSksXG4gICAgICAgICAgICBwcm9wZXJ0eTogWyd0b3AnLCAncmlnaHQnLCAnbGVmdCddW2luZGV4XVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcGllY2VzLmZvckVhY2goKHBpZWNlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBmYWNlLCBsYWJlbCwgcHJvcGVydHkgfSA9IHBpZWNlO1xuXG4gICAgICAgIGZhY2VbcHJvcGVydHldID0gMTtcbiAgICAgICAgbGFiZWxbcHJvcGVydHldID0gMTtcbiAgICAgICAgbGFiZWwudGV4dCA9IGAke3Byb3BlcnR5LnRvVXBwZXJDYXNlKCl9IDDCumA7XG5cbiAgICAgICAgZmFjZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID0gbGFiZWwucm90YXRpb24gKyA0NTtcbiAgICAgICAgICAgIGxhYmVsLnJvdGF0aW9uID0gcm90YXRpb24gPT09IDM2MCA/IDAgOiByb3RhdGlvbjtcbiAgICAgICAgICAgIGxhYmVsLnRleHQgPSBsYWJlbC50ZXh0LnJlcGxhY2UoL1xcZCsvLCBsYWJlbC5yb3RhdGlvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1YmUuYWRkQ2hpbGQocGllY2UuZmFjZSk7XG4gICAgICAgIGN1YmUuYWRkQ2hpbGQocGllY2UubGFiZWwpO1xuICAgIH0pO1xuXG59OyIsImV4cG9ydCBkZWZhdWx0ICggSXNvbWV0cmljTW9kdWxlLCBjb250YWluZXIgKSA9PiB7XG5cbiAgICBjb25zdCB7IElzb21ldHJpY0NhbnZhcywgSXNvbWV0cmljR3JvdXAsIElzb21ldHJpY1BhdGggfSA9IElzb21ldHJpY01vZHVsZTtcblxuICAgIGNvbnN0IGlzb21ldHJpYyA9IG5ldyBJc29tZXRyaWNDYW52YXMoe1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNDQ0MnLFxuICAgICAgICBzY2FsZTogMTIwLFxuICAgICAgICB3aWR0aDogNTAwLFxuICAgICAgICBoZWlnaHQ6IDMyMFxuICAgIH0pO1xuXG4gICAgY29uc3QgYm90dG9tVCA9IG5ldyBJc29tZXRyaWNQYXRoKCk7XG4gICAgY29uc3QgYm90dG9tUiA9IG5ldyBJc29tZXRyaWNQYXRoKCk7XG4gICAgY29uc3QgYm90dG9tTCA9IG5ldyBJc29tZXRyaWNQYXRoKCk7XG5cbiAgICBjb25zdCB0b3BUID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCB0b3BSID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCB0b3BMID0gbmV3IElzb21ldHJpY1BhdGgoKTtcblxuICAgIGJvdHRvbVQubXQoMCwgMCwgLjUpLmx0KDEsIDAsIC41KS5sdCgxLCAxLCAuNSkubHQoMCwgMSwgLjUpO1xuICAgIGJvdHRvbVIubXQoMSwgMCwgLjUpLmx0KDEsIDAsIDApLmx0KDEsIDEsIDApLmx0KDEsIDEsIC41KTtcbiAgICBib3R0b21MLm10KDEsIDEsIC41KS5sdCgxLCAxLCAwKS5sdCgwLCAxLCAwKS5sdCgwLCAxLCAuNSk7XG5cbiAgICB0b3BULm10KC4yNSwgLjI1LCAxKS5sdCguNzUsIC4yNSwgMSkubHQoLjc1LCAuNzUsIC43NSkubHQoLjI1LCAuNzUsIC43NSk7XG4gICAgdG9wUi5tdCguNzUsIC4yNSwgMSkubHQoLjc1LCAuNzUsIC43NSkubHQoLjc1LCAuNzUsIC4yNSkubHQoLjc1LCAuMjUsIC4yNSk7XG4gICAgdG9wTC5tdCguNzUsIC43NSwgLjc1KS5sdCguMjUsIC43NSwgLjc1KS5sdCguMjUsIC43NSwgLjI1KS5sdCguNzUsIC43NSwgLjI1KTtcblxuICAgIGNvbnN0IGJvdHRvbVBpZWNlID0gbmV3IElzb21ldHJpY0dyb3VwKCk7XG4gICAgY29uc3QgdG9wUGllY2UgPSBuZXcgSXNvbWV0cmljR3JvdXAoKTtcbiAgICB0b3BQaWVjZS50b3AgPSAuMjU7XG5cbiAgICBib3R0b21QaWVjZS5hZGRDaGlsZHJlbihib3R0b21ULCBib3R0b21SLCBib3R0b21MKTtcbiAgICB0b3BQaWVjZS5hZGRDaGlsZHJlbih0b3BULCB0b3BSLCB0b3BMKTtcblxuICAgIGxldCBmbGlwID0gdHJ1ZTtcblxuICAgIHRvcFBpZWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJpZ2h0ID0gZmxpcCA/IDAuMjUgOiAtMC4yNTtcbiAgICAgICAgZmxpcCA9ICFmbGlwO1xuICAgIH0pO1xuXG4gICAgaXNvbWV0cmljLmFkZENoaWxkcmVuKGJvdHRvbVBpZWNlLCB0b3BQaWVjZSk7XG5cbn07IiwiZXhwb3J0IGRlZmF1bHQgKCBJc29tZXRyaWNNb2R1bGUsIGNvbnRhaW5lciApID0+IHtcblxuICAgIGNvbnN0IHsgSXNvbWV0cmljQ2FudmFzLCBJc29tZXRyaWNQYXRoIH0gPSBJc29tZXRyaWNNb2R1bGU7XG5cbiAgICBjb25zdCBpc29tZXRyaWMgPSBuZXcgSXNvbWV0cmljQ2FudmFzKHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjQ0NDJyxcbiAgICAgICAgc2NhbGU6IDEyMCxcbiAgICAgICAgd2lkdGg6IDUwMCxcbiAgICAgICAgaGVpZ2h0OiAzMjBcbiAgICB9KTtcblxuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCB0b3AxID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCB0b3AyID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCB0b3AzID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCB0b3A0ID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCBsZWZ0MSA9IG5ldyBJc29tZXRyaWNQYXRoKCk7XG4gICAgY29uc3QgbGVmdDIgPSBuZXcgSXNvbWV0cmljUGF0aCgpO1xuXG4gICAgLy8gTSByIGwgdCAoTW92ZSB0byByaWdodCBsZWZ0IHRvcClcbiAgICAvLyBMIHIgbCB0IChMaW5lIHRvIHJpZ2h0IGxlZnQgdG9wKVxuICAgIC8vIEMgY3IgY2wgY3QgciBsIHQgKEN1cnZlIHRvIGNvbnRyb2wtcmlnaHQgY29udHJvbC1sZWZ0IGNvbnRyb2wtdG9wIHJpZ2h0IGxlZnQgdG9wKVxuICAgIHJpZ2h0LmRyYXcoJ00xIDAgMCBMMSAxIDAgTDEgMSAwLjI1IEwxIDAuNSAwLjI1IEwxIDAuNSAxIEwxIDAgMScpO1xuICAgIHRvcDEuZHJhdygnTTAuMjUgMC41IDEgQzAuNSAwLjUgMC43NSAwLjc1IDAuNSAxIEwwLjc1IDAgMSBDMC41IDAgMC43NSAwLjI1IDAgMSBMMC4yNSAwLjUgMScpO1xuICAgIHRvcDIuZHJhdygnTTEgMCAxIEwwLjc1IDAgMSBMMC43NSAwLjUgMSBMMSAwLjUgMSBMMSAwIDEgTTAgMCAxIEwwLjI1IDAgMSBMMC4yNSAwLjUgMSBMMCAwLjUgMSBMMCAwIDEnKTtcbiAgICB0b3AzLmRyYXcoJ00wIDAuNSAwLjUgTDAuNSAwLjUgMC41IEwwLjUgMSAwLjUgTDAgMSAwLjUnKTtcbiAgICB0b3A0LmRyYXcoJ00wLjUgMC41IDAuNSBMMSAwLjUgMC4yNSBMMSAxIDAuMjUgTDAuNSAxIDAuNScpO1xuICAgIGxlZnQxLmRyYXcoJ00wIDAuNSAxIEwwIDAuNSAwLjUgTDAuNSAwLjUgMC41IEwxIDAuNSAwLjI1IEwxIDAuNSAxIEwwLjc1IDAuNSAxIEMwLjUgMC41IDAuNzUgMC4yNSAwLjUgMSBMMCAwLjUgMScpO1xuICAgIGxlZnQyLmRyYXcoJ00wIDEgMC41IEwwLjUgMSAwLjUgTDEgMSAwLjI1IEwxIDEgMCBMMCAxIDAnKTtcblxuICAgIGlzb21ldHJpYy5hZGRDaGlsZHJlbihyaWdodCwgdG9wMSwgdG9wMiwgdG9wMywgdG9wNCwgbGVmdDEsIGxlZnQyKTtcblxufTsiLCJleHBvcnQgZGVmYXVsdCAoIElzb21ldHJpY01vZHVsZSwgY29udGFpbmVyICkgPT4ge1xuXG4gICAgY29uc3QgeyBJc29tZXRyaWNDYW52YXMsIElzb21ldHJpY1BhdGggfSA9IElzb21ldHJpY01vZHVsZTtcblxuICAgIGNvbnN0IGN1YmUgPSBuZXcgSXNvbWV0cmljQ2FudmFzKHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjQ0NDJyxcbiAgICAgICAgc2NhbGU6IDEyMCxcbiAgICAgICAgd2lkdGg6IDUwMCxcbiAgICAgICAgaGVpZ2h0OiAzMjBcbiAgICB9KTtcblxuICAgIGNvbnN0IHVuZGVyID0gbmV3IElzb21ldHJpY1BhdGgoeyBmaWxsQ29sb3I6ICcjRUVFJyB9KTtcbiAgICBjb25zdCB0b3AgPSBuZXcgSXNvbWV0cmljUGF0aCgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IElzb21ldHJpY1BhdGgoKTtcbiAgICBjb25zdCBsZWZ0ID0gbmV3IElzb21ldHJpY1BhdGgoKTtcblxuICAgIHVuZGVyXG4gICAgICAgIC5tdCgwLCAwLCAxKVxuICAgICAgICAubXQoMC4yNSwgMCwgMSkuY3QoMC41LCAwLCAwLjc1LCAwLjc1LCAwLCAxKS5sdCgxLCAwLCAxKVxuICAgICAgICAubHQoMSwgMCwgMC43NSkuY3QoMC43NSwgMCwgMC41LCAxLCAwLCAwLjI1KS5sdCgxLCAwLCAwKVxuICAgICAgICAubHQoMSwgMC4yNSwgMCkuY3QoMC43NSwgMC41LCAwLCAxLCAwLjc1LCAwKS5sdCgxLCAxLCAwKVxuICAgICAgICAubHQoMC43NSwgMSwgMCkuY3QoMC41LCAwLjc1LCAwLCAwLjI1LCAxLCAwKS5sdCgwLCAxLCAwKVxuICAgICAgICAubHQoMCwgMSwgMC4yNSkuY3QoMCwgMC43NSwgMC41LCAwLCAxLCAwLjc1KS5sdCgwLCAxLCAxKVxuICAgICAgICAubHQoMCwgMC43NSwgMSkuY3QoMCwgMC41LCAwLjc1LCAwLCAwLjI1LCAxKS5sdCgwLCAwLCAxKTtcblxuICAgIHRvcFxuICAgICAgICAubXQoMCwgMCwgMSlcbiAgICAgICAgLmx0KDAuMjUsIDAsIDEpLmN0KDAuNSwgMC4yNSwgMSwgMC43NSwgMCwgMSkubHQoMSwgMCwgMSlcbiAgICAgICAgLmx0KDEsIDAuMjUsIDEpLmN0KDAuNzUsIDAuNSwgMSwgMSwgMC43NSwgMSkubHQoMSwgMSwgMSlcbiAgICAgICAgLmx0KDAuNzUsIDEsIDEpLmN0KDAuNSwgMC43NSwgMSwgMC4yNSwgMSwgMSkubHQoMCwgMSwgMSlcbiAgICAgICAgLmx0KDAsIDAuNzUsIDEpLmN0KDAuMjUsIDAuNSwgMSwgMCwgMC4yNSwgMSkubHQoMCwgMCwgMSk7XG5cbiAgICByaWdodFxuICAgICAgICAubXQoMSwgMCwgMSlcbiAgICAgICAgLmx0KDEsIDAsIDAuNzUpLmN0KDEsIDAuMjUsIDAuNSwgMSwgMCwgMC4yNSkubHQoMSwgMCwgMClcbiAgICAgICAgLmx0KDEsIDAuMjUsIDApLmN0KDEsIDAuNSwgMC4yNSwgMSwgMC43NSwgMCkubHQoMSwgMSwgMClcbiAgICAgICAgLmx0KDEsIDEsIDAuMjUpLmN0KDEsIDAuNzUsIDAuNSwgMSwgMSwgMC43NSkubHQoMSwgMSwgMSlcbiAgICAgICAgLmx0KDEsIDAuNzUsIDEpLmN0KDEsIDAuNSwgMC43NSwgMSwgMC4yNSwgMSkubHQoMSwgMCwgMSk7XG5cbiAgICBsZWZ0XG4gICAgICAgIC5tdCgxLCAxLCAxKVxuICAgICAgICAubHQoMSwgMSwgMC43NSkuY3QoMC43NSwgMSwgMC41LCAxLCAxLCAwLjI1KS5sdCgxLCAxLCAwKVxuICAgICAgICAubHQoMC43NSwgMSwgMCkuY3QoMC41LCAxLCAwLjI1LCAwLjI1LCAxLCAwKS5sdCgwLCAxLCAwKVxuICAgICAgICAubHQoMCwgMSwgMC4yNSkuY3QoMC4yNSwgMSwgMC41LCAwLCAxLCAwLjc1KS5sdCgwLCAxLCAxKVxuICAgICAgICAubHQoMC4yNSwgMSwgMSkuY3QoMC41LCAxLCAwLjc1LCAwLjc1LCAxLCAxKS5sdCgxLCAxLCAxKTtcblxuICAgIGN1YmUuYWRkQ2hpbGRyZW4odW5kZXIsIHRvcCwgcmlnaHQsIGxlZnQpO1xuXG59OyIsImV4cG9ydCBkZWZhdWx0ICggSXNvbWV0cmljTW9kdWxlLCBjb250YWluZXIgKSA9PiB7XG5cbiAgICBjb25zdCB7IElzb21ldHJpY0NhbnZhcywgSXNvbWV0cmljU3RhclBvbHlnb24sIFBsYW5lVmlldyB9ID0gSXNvbWV0cmljTW9kdWxlO1xuXG4gICAgY29uc3QgY3ViZSA9IG5ldyBJc29tZXRyaWNDYW52YXMoe1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNDQ0MnLFxuICAgICAgICBzY2FsZTogMTIwLFxuICAgICAgICB3aWR0aDogNTAwLFxuICAgICAgICBoZWlnaHQ6IDMyMFxuICAgIH0pO1xuXG4gICAgY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgICAgIHJhZGl1czogMC41LFxuICAgICAgICBwb2ludHM6IDgsXG4gICAgICAgIGRlbnNpdHk6IDIsXG4gICAgICAgIHJpZ2h0OiAwLjUsXG4gICAgICAgIGxlZnQ6IDAuNSxcbiAgICAgICAgdG9wOiAwLjVcbiAgICB9O1xuXG4gICAgY29uc3QgcGxhbmVzID0gW1BsYW5lVmlldy5TSURFLCBQbGFuZVZpZXcuRlJPTlQsIFBsYW5lVmlldy5UT1BdO1xuXG4gICAgY29uc3QgcGxhbmVQcm9wc0hhc2ggPSB7XG4gICAgICAgIFtQbGFuZVZpZXcuVE9QXTogJ3RvcCcsXG4gICAgICAgIFtQbGFuZVZpZXcuRlJPTlRdOiAncmlnaHQnLFxuICAgICAgICBbUGxhbmVWaWV3LlNJREVdOiAnbGVmdCdcbiAgICB9O1xuXG4gICAgcGxhbmVzLmZvckVhY2goKHBsYW5lVmlldykgPT4ge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHsgLi4uY29tbW9uUHJvcHMsIHBsYW5lVmlldyB9O1xuICAgICAgICBjb25zdCBjb29yZCA9IHBsYW5lUHJvcHNIYXNoW3BsYW5lVmlld107XG4gICAgICAgIGNvbnN0IHN0YXJQb2x5Z29uQmFjayA9IG5ldyBJc29tZXRyaWNTdGFyUG9seWdvbih7Li4ucHJvcHMsIGlkOiBgJHtjb29yZH0tYmFja2AsIGZpbGxDb2xvcjogJyNFRUUnfSk7XG4gICAgICAgIGNvbnN0IHN0YXJQb2x5Z29uRnJvbnQgPSBuZXcgSXNvbWV0cmljU3RhclBvbHlnb24oey4uLnByb3BzLCBpZDogYCR7Y29vcmR9LWZyb250YH0pO1xuICAgICAgICBzdGFyUG9seWdvbkJhY2tbY29vcmRdID0gMDtcbiAgICAgICAgc3RhclBvbHlnb25Gcm9udFtjb29yZF0gPSAxO1xuICAgICAgICBjdWJlLmFkZENoaWxkcmVuKHN0YXJQb2x5Z29uQmFjaywgc3RhclBvbHlnb25Gcm9udCk7XG4gICAgfSk7XG5cbiAgICBwbGFuZXMuZm9yRWFjaCgocGxhbmVWaWV3KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvb3JkID0gcGxhbmVQcm9wc0hhc2hbcGxhbmVWaWV3XTtcbiAgICAgICAgY29uc3Qgc3RhclBvbHlnb25CYWNrID0gY3ViZS5nZXRDaGlsZEJ5SWQoYCR7Y29vcmR9LWJhY2tgKTtcbiAgICAgICAgY29uc3Qgc3RhclBvbHlnb25Gcm9udCA9IGN1YmUuZ2V0Q2hpbGRCeUlkKGAke2Nvb3JkfS1mcm9udGApO1xuICAgICAgICBjdWJlLnNlbmRDaGlsZFRvQmFjayhzdGFyUG9seWdvbkJhY2spO1xuICAgICAgICBjdWJlLmJyaW5nQ2hpbGRUb0Zyb250KHN0YXJQb2x5Z29uRnJvbnQpO1xuICAgIH0pO1xuXG59OyIsImV4cG9ydCBkZWZhdWx0ICggSXNvbWV0cmljTW9kdWxlLCBjb250YWluZXIgKSA9PiB7XG5cbiAgICBjb25zdCB7IElzb21ldHJpY0NhbnZhcywgSXNvbWV0cmljR3JvdXAsIElzb21ldHJpY1JlY3RhbmdsZSwgUGxhbmVWaWV3IH0gPSBJc29tZXRyaWNNb2R1bGU7XG5cbiAgICBjb25zdCBjYW52YXMgPSBuZXcgSXNvbWV0cmljQ2FudmFzKHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjQ0NDJyxcbiAgICAgICAgc2NhbGU6IDIwLFxuICAgICAgICB3aWR0aDogNTAwLFxuICAgICAgICBoZWlnaHQ6IDMyMFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRQbGFuZXMoKSB7XG4gICAgICAgIGN1YmUucmlnaHQgPSBjdWJlLmxlZnQgPSBjdWJlLnRvcCA9IDA7XG4gICAgICAgIHBsYW5lVG9wLmZpbGxPcGFjaXR5ID0gcGxhbmVSaWdodC5maWxsT3BhY2l0eSA9IHBsYW5lTGVmdC5maWxsT3BhY2l0eSA9IDAuMjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlUGxhbmUoKSB7XG4gICAgICAgIHJlc2V0UGxhbmVzKCk7XG4gICAgICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgICAgICBjdWJlLmRyYWcgPSB0aGlzLnBsYW5lVmlldztcbiAgICB9XG5cbiAgICBjb25zdCBwbGFuZVByb3BzID0geyBoZWlnaHQ6IDYsIHdpZHRoOiA2LCBmaWxsT3BhY2l0eTogMC4yNSB9O1xuICAgIGNvbnN0IHBsYW5lVG9wID0gbmV3IElzb21ldHJpY1JlY3RhbmdsZSh7IC4uLnBsYW5lUHJvcHMsIHBsYW5lVmlldzogUGxhbmVWaWV3LlRPUCwgZmlsbE9wYWNpdHk6IDEgfSk7XG4gICAgY29uc3QgcGxhbmVSaWdodCA9IG5ldyBJc29tZXRyaWNSZWN0YW5nbGUoeyAuLi5wbGFuZVByb3BzLCBwbGFuZVZpZXc6IFBsYW5lVmlldy5GUk9OVCB9KTtcbiAgICBjb25zdCBwbGFuZUxlZnQgPSBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHsgLi4ucGxhbmVQcm9wcywgcGxhbmVWaWV3OiBQbGFuZVZpZXcuU0lERSB9KTtcblxuICAgIGNvbnN0IGN1YmVQcm9wcyA9IHsgaGVpZ2h0OiAxLCB3aWR0aDogMSB9O1xuICAgIGNvbnN0IGN1YmVUb3AgPSBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHsgLi4uY3ViZVByb3BzLCBwbGFuZVZpZXc6IFBsYW5lVmlldy5UT1AsIHRvcDogMSB9KTtcbiAgICBjb25zdCBjdWJlUmlnaHQgPSBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHsgLi4uY3ViZVByb3BzLCBwbGFuZVZpZXc6IFBsYW5lVmlldy5GUk9OVCwgcmlnaHQ6IDEgfSk7XG4gICAgY29uc3QgY3ViZUxlZnQgPSBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHsgLi4uY3ViZVByb3BzLCBwbGFuZVZpZXc6IFBsYW5lVmlldy5TSURFLCBsZWZ0OiAxIH0pO1xuXG4gICAgY29uc3QgY3ViZSA9IG5ldyBJc29tZXRyaWNHcm91cCgpO1xuXG4gICAgY29uc3QgYm91bmRzID0gWzAsIDVdO1xuICAgIGN1YmUuZHJhZyA9ICdUT1AnO1xuICAgIGN1YmUuYm91bmRzID0geyB0b3A6IGJvdW5kcywgcmlnaHQ6IGJvdW5kcywgbGVmdDogYm91bmRzIH07XG5cbiAgICBwbGFuZVRvcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoYW5nZVBsYW5lLCB0cnVlKTtcbiAgICBwbGFuZVJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hhbmdlUGxhbmUsIHRydWUpO1xuICAgIHBsYW5lTGVmdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoYW5nZVBsYW5lLCB0cnVlKTtcblxuICAgIGN1YmUuYWRkQ2hpbGRyZW4oY3ViZVRvcCwgY3ViZVJpZ2h0LCBjdWJlTGVmdCk7XG4gICAgY2FudmFzLmFkZENoaWxkcmVuKHBsYW5lVG9wLCBwbGFuZVJpZ2h0LCBwbGFuZUxlZnQsIGN1YmUpO1xuXG59OyIsImltcG9ydCAnLi4vaW1hZ2VzL2Jsb2NrX3NpZGUucG5nJztcbmltcG9ydCAnLi4vaW1hZ2VzL2Jsb2NrX3RvcC5wbmcnO1xuXG5leHBvcnQgZGVmYXVsdCAoIElzb21ldHJpY01vZHVsZSwgY29udGFpbmVyICkgPT4ge1xuXG4gICAgY29uc3QgeyBJc29tZXRyaWNDYW52YXMsIElzb21ldHJpY1BhdGgsIElzb21ldHJpY1JlY3RhbmdsZSwgUGxhbmVWaWV3LCBBeGlzIH0gPSBJc29tZXRyaWNNb2R1bGU7XG5cbiAgICBjb25zdCBpc29tZXRyaWMgPSBuZXcgSXNvbWV0cmljQ2FudmFzKHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjOEFBQTNGJyxcbiAgICAgICAgc2NhbGU6IDEyMCxcbiAgICAgICAgd2lkdGg6IDUwMCxcbiAgICAgICAgaGVpZ2h0OiAzMjBcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbW1vblRleHR1cmVQcm9wcyA9IHtcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgcGl4ZWxhdGVkOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IHRleHR1cmVTaWRlcyA9IHtcbiAgICAgICAgdXJsOiAnaW1hZ2VzL2Jsb2NrX3NpZGUucG5nJyxcbiAgICAgICAgLi4uY29tbW9uVGV4dHVyZVByb3BzXG4gICAgfTtcblxuICAgIGNvbnN0IHRleHR1cmVUb3AgPSB7XG4gICAgICAgIHVybDogJ2ltYWdlcy9ibG9ja190b3AucG5nJyxcbiAgICAgICAgcGxhbmVWaWV3OiBQbGFuZVZpZXcuVE9QLFxuICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgICAgYXhpczogQXhpcy5MRUZULFxuICAgICAgICAgICAgdmFsdWU6IDI2LjU2NTBcbiAgICAgICAgfSxcbiAgICAgICAgLi4uY29tbW9uVGV4dHVyZVByb3BzXG4gICAgfTtcblxuICAgIGNvbnN0IHNpZGUgPSBuZXcgSXNvbWV0cmljUGF0aCh7XG4gICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgIHBsYW5lVmlldzogUGxhbmVWaWV3LlNJREUsXG4gICAgICAgICAgICAuLi50ZXh0dXJlU2lkZXNcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZnJvbnQgPSBuZXcgSXNvbWV0cmljUmVjdGFuZ2xlKHtcbiAgICAgICAgcGxhbmVWaWV3OiBQbGFuZVZpZXcuRlJPTlQsXG4gICAgICAgIGhlaWdodDogMC41LFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgdGV4dHVyZTogdGV4dHVyZVNpZGVzXG4gICAgfSk7XG5cbiAgICBjb25zdCBjaG9wID0gbmV3IElzb21ldHJpY1BhdGgoe1xuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlVG9wXG4gICAgfSk7XG5cbiAgICBzaWRlLmRyYXcoJ00xIDEgMCBMMSAxIDAuNSBMMCAxIDEgTDAgMSAwJyk7XG4gICAgY2hvcC5kcmF3KCdNMSAxIDAuNSBMMCAxIDEgTDAgMCAxIEwxIDAgMC41Jyk7XG5cbiAgICBzaWRlLmxlZnQgPSAxO1xuICAgIGZyb250LnJpZ2h0ID0gMTtcblxuICAgIGlzb21ldHJpYy5hZGRDaGlsZHJlbihzaWRlLCBmcm9udCwgY2hvcCk7XG5cbn07IiwiaW1wb3J0ICdnb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcnVuX3ByZXR0aWZ5Lm1pbic7XG5pbXBvcnQgJy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcHJldHRpZnkubWluLmNzcyc7XG5pbXBvcnQgJy4vdG9tb3Jyb3cubWluLmNzcyc7XG5pbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuaW1wb3J0ICogYXMgSXNvbWV0cmljTW9kdWxlIGZyb20gJy4uL3NyYyc7XG5pbXBvcnQgZGVtbzEgZnJvbSAnLi9kZW1vMSc7XG5pbXBvcnQgZGVtbzIgZnJvbSAnLi9kZW1vMic7XG5pbXBvcnQgZGVtbzMgZnJvbSAnLi9kZW1vMyc7XG5pbXBvcnQgZGVtbzQgZnJvbSAnLi9kZW1vNCc7XG5pbXBvcnQgZGVtbzUgZnJvbSAnLi9kZW1vNSc7XG5pbXBvcnQgZGVtbzYgZnJvbSAnLi9kZW1vNic7XG5pbXBvcnQgZGVtbzcgZnJvbSAnLi9kZW1vNyc7XG5pbXBvcnQgZGVtbzggZnJvbSAnLi9kZW1vOCc7XG5pbXBvcnQgZGVtbzkgZnJvbSAnLi9kZW1vOSc7XG5cbmNvbnN0IGZ1bmN0aW9Ub1N0cmluZyA9IChmbikgPT4ge1xuICAgIGNvbnN0IGFydGljbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhcnRpY2xlJyk7XG4gICAgY29uc3QgcHJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyk7XG4gICAgYXJ0aWNsZS5jbGFzc0xpc3QuYWRkKCdmdW5jdGlvbi1jb250YWluZXInKTtcbiAgICBwcmUuY2xhc3NMaXN0LmFkZCgncHJldHR5cHJpbnQnKTtcbiAgICBhcnRpY2xlLmFwcGVuZENoaWxkKHByZSk7XG4gICAgcHJlLmlubmVySFRNTCA9IGZuLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGFydGljbGU7XG59O1xuXG5jb25zdCBkZW1vcyA9IG5ldyBNYXAoW1xuICAgIFsnZGVtbzEnLCBkZW1vMV0sXG4gICAgWydkZW1vMicsIGRlbW8yXSxcbiAgICBbJ2RlbW8zJywgZGVtbzNdLFxuICAgIFsnZGVtbzQnLCBkZW1vNF0sXG4gICAgWydkZW1vNScsIGRlbW81XSxcbiAgICBbJ2RlbW82JywgZGVtbzZdLFxuICAgIFsnZGVtbzcnLCBkZW1vN10sXG4gICAgWydkZW1vOCcsIGRlbW84XSxcbiAgICBbJ2RlbW85JywgZGVtbzldLFxuXSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICBkZW1vcy5mb3JFYWNoKChtb2R1bGUsIGRpdikgPT4ge1xuICAgICAgICBjb25zdCBkZW1vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2KTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGVtby1jb250YWluZXInKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdkZW1vLXdyYXBwZXInKTtcblxuICAgICAgICBtb2R1bGUoSXNvbWV0cmljTW9kdWxlLCB3cmFwcGVyKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICBkZW1vLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIGRlbW8uYXBwZW5kQ2hpbGQoZnVuY3Rpb1RvU3RyaW5nKG1vZHVsZSkpO1xuICAgIH0pO1xuXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///741\n')},966:(module,exports)=>{eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(){var r=null;\n(function(){function X(e){function j(){try{J.doScroll("left")}catch(e){P(j,50);return}w("poll")}function w(j){if(!(j.type=="readystatechange"&&x.readyState!="complete")&&((j.type=="load"?n:x)[z](i+j.type,w,!1),!m&&(m=!0)))e.call(n,j.type||j)}var Y=x.addEventListener,m=!1,C=!0,t=Y?"addEventListener":"attachEvent",z=Y?"removeEventListener":"detachEvent",i=Y?"":"on";if(x.readyState=="complete")e.call(n,"lazy");else{if(x.createEventObject&&J.doScroll){try{C=!n.frameElement}catch(A){}C&&j()}x[t](i+"DOMContentLoaded",\nw,!1);x[t](i+"readystatechange",w,!1);n[t](i+"load",w,!1)}}function Q(){S&&X(function(){var e=K.length;$(e?function(){for(var j=0;j<e;++j)(function(e){P(function(){n.exports[K[e]].apply(n,arguments)},0)})(j)}:void 0)})}for(var n=window,P=n.setTimeout,x=document,J=x.documentElement,L=x.head||x.getElementsByTagName("head")[0]||J,z="",A=x.scripts,m=A.length;--m>=0;){var M=A[m],T=M.src.match(/^[^#?]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/);if(T){z=T[1]||"";M.parentNode.removeChild(M);break}}var S=!0,D=\n[],N=[],K=[];z.replace(/[&?]([^&=]+)=([^&]+)/g,function(e,j,w){w=decodeURIComponent(w);j=decodeURIComponent(j);j=="autorun"?S=!/^[0fn]/i.test(w):j=="lang"?D.push(w):j=="skin"?N.push(w):j=="callback"&&K.push(w)});m=0;for(z=D.length;m<z;++m)(function(){var e=x.createElement("script");e.onload=e.onerror=e.onreadystatechange=function(){if(e&&(!e.readyState||/loaded|complete/.test(e.readyState)))e.onerror=e.onload=e.onreadystatechange=r,--R,R||P(Q,0),e.parentNode&&e.parentNode.removeChild(e),e=r};e.type=\n"text/javascript";e.src="https://google-code-prettify.googlecode.com/svn/loader/lang-"+encodeURIComponent(D[m])+".js";L.insertBefore(e,L.firstChild)})(D[m]);for(var R=D.length,A=[],m=0,z=N.length;m<z;++m)A.push("https://google-code-prettify.googlecode.com/svn/loader/skins/"+encodeURIComponent(N[m])+".css");A.push("https://google-code-prettify.googlecode.com/svn/loader/prettify.css");(function(e){function j(m){if(m!==w){var n=x.createElement("link");n.rel="stylesheet";n.type="text/css";if(m+1<w)n.error=\nn.onerror=function(){j(m+1)};n.href=e[m];L.appendChild(n)}}var w=e.length;j(0)})(A);var $=function(){window.PR_SHOULD_USE_CONTINUATION=!0;var e;(function(){function j(a){function d(f){var b=f.charCodeAt(0);if(b!==92)return b;var a=f.charAt(1);return(b=i[a])?b:"0"<=a&&a<="7"?parseInt(f.substring(1),8):a==="u"||a==="x"?parseInt(f.substring(2),16):f.charCodeAt(1)}function h(f){if(f<32)return(f<16?"\\\\x0":"\\\\x")+f.toString(16);f=String.fromCharCode(f);return f==="\\\\"||f==="-"||f==="]"||f==="^"?"\\\\"+f:\nf}function b(f){var b=f.substring(1,f.length-1).match(/\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\S\\s]|[^\\\\]/g),f=[],a=b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,g=b.length;a<g;++a){var k=b[a];if(/\\\\[bdsw]/i.test(k))c.push(k);else{var k=d(k),o;a+2<g&&"-"===b[a+1]?(o=d(b[a+2]),a+=2):o=k;f.push([k,o]);o<65||k>122||(o<65||k>90||f.push([Math.max(65,k)|32,Math.min(o,90)|32]),o<97||k>122||f.push([Math.max(97,k)&-33,Math.min(o,122)&-33]))}}f.sort(function(f,a){return f[0]-\na[0]||a[1]-f[1]});b=[];g=[];for(a=0;a<f.length;++a)k=f[a],k[0]<=g[1]+1?g[1]=Math.max(g[1],k[1]):b.push(g=k);for(a=0;a<b.length;++a)k=b[a],c.push(h(k[0])),k[1]>k[0]&&(k[1]+1>k[0]&&c.push("-"),c.push(h(k[1])));c.push("]");return c.join("")}function e(f){for(var a=f.source.match(/\\[(?:[^\\\\\\]]|\\\\[\\S\\s])*]|\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\\\d+|\\\\[^\\dux]|\\(\\?[!:=]|[()^]|[^()[\\\\^]+/g),c=a.length,d=[],g=0,k=0;g<c;++g){var o=a[g];o==="("?++k:"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&(o<=k?d[o]=-1:a[g]=h(o))}for(g=\n1;g<d.length;++g)-1===d[g]&&(d[g]=++j);for(k=g=0;g<c;++g)o=a[g],o==="("?(++k,d[k]||(a[g]="(?:")):"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&o<=k&&(a[g]="\\\\"+d[o]);for(g=0;g<c;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(f.ignoreCase&&F)for(g=0;g<c;++g)o=a[g],f=o.charAt(0),o.length>=2&&f==="["?a[g]=b(o):f!=="\\\\"&&(a[g]=o.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var j=0,F=!1,l=!1,I=0,c=a.length;I<c;++I){var p=a[I];if(p.ignoreCase)l=\n!0;else if(/[a-z]/i.test(p.source.replace(/\\\\u[\\da-f]{4}|\\\\x[\\da-f]{2}|\\\\[^UXux]/gi,""))){F=!0;l=!1;break}}for(var i={b:8,t:9,n:10,v:11,f:12,r:13},q=[],I=0,c=a.length;I<c;++I){p=a[I];if(p.global||p.multiline)throw Error(""+p);q.push("(?:"+e(p)+")")}return RegExp(q.join("|"),l?"gi":"g")}function m(a,d){function h(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)h(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)e[l]="\\n",F[l<<1]=j++,F[l++<<1|1]=a}}else if(c==\n3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\\r\\n?/g,"\\n"):c.replace(/[\\t\\n\\r ]+/g," "),e[l]=c,F[l<<1]=j,j+=c.length,F[l++<<1|1]=a)}var b=/(?:^|\\s)nocode(?:\\s|$)/,e=[],j=0,F=[],l=0;h(a);return{a:e.join("").replace(/\\n$/,""),d:F}}function n(a,d,h,b){d&&(a={a:d,e:a},h(a),b.push.apply(b,a.g))}function x(a){for(var d=void 0,h=a.firstChild;h;h=h.nextSibling)var b=h.nodeType,d=b===1?d?a:h:b===3?S.test(h.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function h(a){for(var l=a.e,j=[l,"pln"],c=\n0,p=a.a.match(e)||[],m={},q=0,f=p.length;q<f;++q){var B=p[q],y=m[B],u=void 0,g;if(typeof y==="string")g=!1;else{var k=b[B.charAt(0)];if(k)u=B.match(k[1]),y=k[0];else{for(g=0;g<i;++g)if(k=d[g],u=B.match(k[1])){y=k[0];break}u||(y="pln")}if((g=y.length>=5&&"lang-"===y.substring(0,5))&&!(u&&typeof u[1]==="string"))g=!1,y="src";g||(m[B]=y)}k=c;c+=B.length;if(g){g=u[1];var o=B.indexOf(g),H=o+g.length;u[2]&&(H=B.length-u[2].length,o=H-g.length);y=y.substring(5);n(l+k,B.substring(0,o),h,j);n(l+k+o,g,A(y,\ng),j);n(l+k+H,B.substring(H),h,j)}else j.push(l+k,y)}a.g=j}var b={},e;(function(){for(var h=a.concat(d),l=[],i={},c=0,p=h.length;c<p;++c){var m=h[c],q=m[3];if(q)for(var f=q.length;--f>=0;)b[q.charAt(f)]=m;m=m[1];q=""+m;i.hasOwnProperty(q)||(l.push(m),i[q]=r)}l.push(/[\\S\\s]/);e=j(l)})();var i=d.length;return h}function t(a){var d=[],h=[];a.tripleQuotedStrings?d.push(["str",/^(?:\'\'\'(?:[^\'\\\\]|\\\\[\\S\\s]|\'\'?(?=[^\']))*(?:\'\'\'|$)|"""(?:[^"\\\\]|\\\\[\\S\\s]|""?(?=[^"]))*(?:"""|$)|\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$))/,\nr,"\'\\""]):a.multiLineStrings?d.push(["str",/^(?:\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$)|`(?:[^\\\\`]|\\\\[\\S\\s])*(?:`|$))/,r,"\'\\"`"]):d.push(["str",/^(?:\'(?:[^\\n\\r\'\\\\]|\\\\.)*(?:\'|$)|"(?:[^\\n\\r"\\\\]|\\\\.)*(?:"|$))/,r,"\\"\'"]);a.verbatimStrings&&h.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,r]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,r,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\n\\r]*)/,\nr,"#"]),h.push(["str",/^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,r])):d.push(["com",/^#[^\\n\\r]*/,r,"#"]));a.cStyleComments&&(h.push(["com",/^\\/\\/[^\\n\\r]*/,r]),h.push(["com",/^\\/\\*[\\S\\s]*?(?:\\*\\/|$)/,r]));if(b=a.regexLiterals){var e=(b=b>1?"":"\\n\\r")?".":"[\\\\S\\\\s]";h.push(["lang-regex",RegExp("^(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*("+\n("/(?=[^/*"+b+"])(?:[^/\\\\x5B\\\\x5C"+b+"]|\\\\x5C"+e+"|\\\\x5B(?:[^\\\\x5C\\\\x5D"+b+"]|\\\\x5C"+e+")*(?:\\\\x5D|$))+/")+")")])}(b=a.types)&&h.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&h.push(["kwd",RegExp("^(?:"+b.replace(/[\\s,]+/g,"|")+")\\\\b"),r]);d.push(["pln",/^\\s+/,r," \\r\\n\\t\\u00a0"]);b="^.[^\\\\s\\\\w.$@\'\\"`/\\\\\\\\]*";a.regexLiterals&&(b+="(?!s*/)");h.push(["lit",/^@[$_a-z][\\w$@]*/i,r],["typ",/^(?:[@_]?[A-Z]+[a-z][\\w$@]*|\\w+_t\\b)/,r],["pln",/^[$_a-z][\\w$@]*/i,r],["lit",/^(?:0x[\\da-f]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+-]?\\d+)?)[a-z]*/i,\nr,"0123456789"],["pln",/^\\\\[\\S\\s]?/,r],["pun",RegExp(b),r]);return C(d,h)}function z(a,d,h){function b(a){var c=a.nodeType;if(c==1&&!j.test(a.className))if("br"===a.nodeName)e(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&h){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(l.createTextNode(d),a.nextSibling),e(a),c||a.parentNode.removeChild(a)}}\nfunction e(a){function b(a,c){var d=c?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),h=a.nextSibling;f.appendChild(d);for(var e=h;e;e=h)h=e.nextSibling,f.appendChild(e)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var j=/(?:^|\\s)nocode(?:\\s|$)/,m=/\\r\\n?|\\n/,l=a.ownerDocument,i=l.createElement("li");a.firstChild;)i.appendChild(a.firstChild);for(var c=[i],p=0;p<c.length;++p)b(c[p]);d===(d|0)&&c[0].setAttribute("value",\nd);var n=l.createElement("ol");n.className="linenums";for(var d=Math.max(0,d-1|0)||0,p=0,q=c.length;p<q;++p)i=c[p],i.className="L"+(p+d)%10,i.firstChild||i.appendChild(l.createTextNode("\\u00a0")),n.appendChild(i);a.appendChild(n)}function i(a,d){for(var h=d.length;--h>=0;){var b=d[h];U.hasOwnProperty(b)?V.console&&console.warn("cannot override language handler %s",b):U[b]=a}}function A(a,d){if(!a||!U.hasOwnProperty(a))a=/^\\s*</.test(d)?"default-markup":"default-code";return U[a]}function D(a){var d=\na.h;try{var h=m(a.c,a.i),b=h.a;a.a=b;a.d=h.d;a.e=0;A(d,b)(a);var e=/\\bMSIE\\s(\\d+)/.exec(navigator.userAgent),e=e&&+e[1]<=8,d=/\\n/g,i=a.a,j=i.length,h=0,l=a.d,n=l.length,b=0,c=a.g,p=c.length,t=0;c[p]=j;var q,f;for(f=q=0;f<p;)c[f]!==c[f+2]?(c[q++]=c[f++],c[q++]=c[f++]):f+=2;p=q;for(f=q=0;f<p;){for(var x=c[f],y=c[f+1],u=f+2;u+2<=p&&c[u+1]===y;)u+=2;c[q++]=x;c[q++]=y;f=u}c.length=q;var g=a.c,k;if(g)k=g.style.display,g.style.display="none";try{for(;b<n;){var o=l[b+2]||j,H=c[t+2]||j,u=Math.min(o,H),E=l[b+\n1],W;if(E.nodeType!==1&&(W=i.substring(h,u))){e&&(W=W.replace(d,"\\r"));E.nodeValue=W;var Z=E.ownerDocument,s=Z.createElement("span");s.className=c[t+1];var z=E.parentNode;z.replaceChild(s,E);s.appendChild(E);h<o&&(l[b+1]=E=Z.createTextNode(i.substring(u,o)),z.insertBefore(E,s.nextSibling))}h=u;h>=o&&(b+=2);h>=H&&(t+=2)}}finally{if(g)g.style.display=k}}catch(v){V.console&&console.log(v&&v.stack||v)}}var V=window,G=["break,continue,do,else,for,if,return,while"],O=[[G,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],\n"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],J=[O,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],K=[O,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],\nL=[K,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],O=[O,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],M=[G,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],\nN=[G,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],R=[G,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],G=[G,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/,\nS=/\\S/,T=t({keywords:[J,L,O,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",M,N,G],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),U={};i(T,["default-code"]);i(C([],[["pln",/^[^<?]+/],["dec",/^<!\\w[^>]*(?:>|$)/],["com",/^<\\!--[\\S\\s]*?(?:--\\>|$)/],["lang-",/^<\\?([\\S\\s]+?)(?:\\?>|$)/],["lang-",/^<%([\\S\\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",\n/^<xmp\\b[^>]*>([\\S\\s]+?)<\\/xmp\\b[^>]*>/i],["lang-js",/^<script\\b[^>]*>([\\S\\s]*?)(<\\/script\\b[^>]*>)/i],["lang-css",/^<style\\b[^>]*>([\\S\\s]*?)(<\\/style\\b[^>]*>)/i],["lang-in.tag",/^(<\\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);i(C([["pln",/^\\s+/,r," \\t\\r\\n"],["atv",/^(?:"[^"]*"?|\'[^\']*\'?)/,r,"\\"\'"]],[["tag",/^^<\\/?[a-z](?:[\\w-.:]*\\w)?|\\/?>$/i],["atn",/^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],["lang-uq.val",/^=\\s*([^\\s"\'>]*(?:[^\\s"\'/>]|\\/(?=\\s)))/],["pun",/^[/<->]+/],\n["lang-js",/^on\\w+\\s*=\\s*"([^"]+)"/i],["lang-js",/^on\\w+\\s*=\\s*\'([^\']+)\'/i],["lang-js",/^on\\w+\\s*=\\s*([^\\s"\'>]+)/i],["lang-css",/^style\\s*=\\s*"([^"]+)"/i],["lang-css",/^style\\s*=\\s*\'([^\']+)\'/i],["lang-css",/^style\\s*=\\s*([^\\s"\'>]+)/i]]),["in.tag"]);i(C([],[["atv",/^[\\S\\s]+/]]),["uq.val"]);i(t({keywords:J,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);i(t({keywords:"null,true,false"}),["json"]);i(t({keywords:L,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),\n["cs"]);i(t({keywords:K,cStyleComments:!0}),["java"]);i(t({keywords:G,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);i(t({keywords:M,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);i(t({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);i(t({keywords:N,\nhashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);i(t({keywords:O,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);i(t({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);i(t({keywords:R,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);\ni(C([],[["str",/^[\\S\\s]+/]]),["regex"]);var X=V.PR={createSimpleLexer:C,registerLangHandler:i,sourceDecorator:t,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:function(a,d,e){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;e&&z(b,e,!0);D({h:d,j:e,c:b,i:1});return b.innerHTML},\nprettyPrint:e=e=function(a,d){function e(){for(var b=V.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;p<j.length&&c.now()<b;p++){for(var d=j[p],m=k,l=d;l=l.previousSibling;){var n=l.nodeType,s=(n===7||n===8)&&l.nodeValue;if(s?!/^\\??prettify\\b/.test(s):n!==3||/\\S/.test(l.nodeValue))break;if(s){m={};s.replace(/\\b(\\w+)=([\\w%+\\-.:]+)/g,function(a,b,c){m[b]=c});break}}l=d.className;if((m!==k||f.test(l))&&!w.test(l)){n=!1;for(s=d.parentNode;s;s=s.parentNode)if(g.test(s.tagName)&&s.className&&f.test(s.className)){n=\n!0;break}if(!n){d.className+=" prettyprinted";n=m.lang;if(!n){var n=l.match(q),A;if(!n&&(A=x(d))&&u.test(A.tagName))n=A.className.match(q);n&&(n=n[1])}if(y.test(d.tagName))s=1;else var s=d.currentStyle,v=i.defaultView,s=(s=s?s.whiteSpace:v&&v.getComputedStyle?v.getComputedStyle(d,r).getPropertyValue("white-space"):0)&&"pre"===s.substring(0,3);v=m.linenums;if(!(v=v==="true"||+v))v=(v=l.match(/\\blinenums\\b(?::(\\d+))?/))?v[1]&&v[1].length?+v[1]:!0:!1;v&&z(d,v,s);t={h:n,c:d,j:v,i:s};D(t)}}}p<j.length?\nP(e,250):"function"===typeof a&&a()}for(var b=d||document.body,i=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],j=[],m=0;m<b.length;++m)for(var l=0,n=b[m].length;l<n;++l)j.push(b[m][l]);var b=r,c=Date;c.now||(c={now:function(){return+new Date}});var p=0,t,q=/\\blang(?:uage)?-([\\w.]+)(?!\\S)/,f=/\\bprettyprint\\b/,w=/\\bprettyprinted\\b/,y=/pre|xmp/i,u=/^code$/i,g=/^(?:pre|code|xmp)$/i,k={};e()}}; true&&\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return X}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))})();return e}();R||P(Q,0)})();}()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YSw0REFBNEQsc0JBQXNCLEtBQUssdUJBQXVCLG9CQUFvQixFQUFFLCtDQUErQyxtRUFBbUUsTUFBTSxLQUFLLG1EQUFtRCxPQUFPLEVBQUUsT0FBTyxjQUFjLG1DQUFtQyxLQUFLLG1CQUFtQixFQUFFLHVFQUF1RTtBQUNqZ0IsR0FBRyxNQUFNLE9BQU8sOEJBQThCLFNBQVMsT0FBTyxtQkFBbUIsMERBQTBELFlBQVkseUJBQXlCLHlLQUF5SyxhQUFhLDhGQUE4RixZQUFZLEdBQUcsaUJBQWlCLE9BQU87QUFDM2Usb0NBQW9DLCtKQUErSixXQUFXLDhCQUE4QixJQUFJLG9CQUFvQixlQUFlLFdBQVcsZUFBZSxpQkFBaUIsRUFBRSw2SUFBNkksTUFBTSxLQUFzQztBQUN6ZixpQ0FBOEIsRUFBRSxtQ0FBQyxXQUFXLFNBQVM7QUFBQSxrR0FBQyxDQUFDLElBQUksU0FBUyxHQUFHLFVBQVUsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL0BlbGNoaW5pbmV0L2lzb21ldHJpYy8uL25vZGVfbW9kdWxlcy8ucG5wbS9nb29nbGUtY29kZS1wcmV0dGlmeUAxLjAuNS9ub2RlX21vZHVsZXMvZ29vZ2xlLWNvZGUtcHJldHRpZnkvYmluL3J1bl9wcmV0dGlmeS5taW4uanM/ZmM4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oKXt2YXIgcj1udWxsO1xuKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gWChlKXtmdW5jdGlvbiBqKCl7dHJ5e0ouZG9TY3JvbGwoXCJsZWZ0XCIpfWNhdGNoKGUpe1Aoaiw1MCk7cmV0dXJufXcoXCJwb2xsXCIpfWZ1bmN0aW9uIHcoail7aWYoIShqLnR5cGU9PVwicmVhZHlzdGF0ZWNoYW5nZVwiJiZ4LnJlYWR5U3RhdGUhPVwiY29tcGxldGVcIikmJigoai50eXBlPT1cImxvYWRcIj9uOngpW3pdKGkrai50eXBlLHcsITEpLCFtJiYobT0hMCkpKWUuY2FsbChuLGoudHlwZXx8ail9dmFyIFk9eC5hZGRFdmVudExpc3RlbmVyLG09ITEsQz0hMCx0PVk/XCJhZGRFdmVudExpc3RlbmVyXCI6XCJhdHRhY2hFdmVudFwiLHo9WT9cInJlbW92ZUV2ZW50TGlzdGVuZXJcIjpcImRldGFjaEV2ZW50XCIsaT1ZP1wiXCI6XCJvblwiO2lmKHgucmVhZHlTdGF0ZT09XCJjb21wbGV0ZVwiKWUuY2FsbChuLFwibGF6eVwiKTtlbHNle2lmKHguY3JlYXRlRXZlbnRPYmplY3QmJkouZG9TY3JvbGwpe3RyeXtDPSFuLmZyYW1lRWxlbWVudH1jYXRjaChBKXt9QyYmaigpfXhbdF0oaStcIkRPTUNvbnRlbnRMb2FkZWRcIixcbncsITEpO3hbdF0oaStcInJlYWR5c3RhdGVjaGFuZ2VcIix3LCExKTtuW3RdKGkrXCJsb2FkXCIsdywhMSl9fWZ1bmN0aW9uIFEoKXtTJiZYKGZ1bmN0aW9uKCl7dmFyIGU9Sy5sZW5ndGg7JChlP2Z1bmN0aW9uKCl7Zm9yKHZhciBqPTA7ajxlOysraikoZnVuY3Rpb24oZSl7UChmdW5jdGlvbigpe24uZXhwb3J0c1tLW2VdXS5hcHBseShuLGFyZ3VtZW50cyl9LDApfSkoail9OnZvaWQgMCl9KX1mb3IodmFyIG49d2luZG93LFA9bi5zZXRUaW1lb3V0LHg9ZG9jdW1lbnQsSj14LmRvY3VtZW50RWxlbWVudCxMPXguaGVhZHx8eC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF18fEosej1cIlwiLEE9eC5zY3JpcHRzLG09QS5sZW5ndGg7LS1tPj0wOyl7dmFyIE09QVttXSxUPU0uc3JjLm1hdGNoKC9eW14jP10qXFwvcnVuX3ByZXR0aWZ5XFwuanMoXFw/W14jXSopPyg/OiMuKik/JC8pO2lmKFQpe3o9VFsxXXx8XCJcIjtNLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoTSk7YnJlYWt9fXZhciBTPSEwLEQ9XG5bXSxOPVtdLEs9W107ei5yZXBsYWNlKC9bJj9dKFteJj1dKyk9KFteJl0rKS9nLGZ1bmN0aW9uKGUsaix3KXt3PWRlY29kZVVSSUNvbXBvbmVudCh3KTtqPWRlY29kZVVSSUNvbXBvbmVudChqKTtqPT1cImF1dG9ydW5cIj9TPSEvXlswZm5dL2kudGVzdCh3KTpqPT1cImxhbmdcIj9ELnB1c2godyk6aj09XCJza2luXCI/Ti5wdXNoKHcpOmo9PVwiY2FsbGJhY2tcIiYmSy5wdXNoKHcpfSk7bT0wO2Zvcih6PUQubGVuZ3RoO208ejsrK20pKGZ1bmN0aW9uKCl7dmFyIGU9eC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Uub25sb2FkPWUub25lcnJvcj1lLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGUmJighZS5yZWFkeVN0YXRlfHwvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KGUucmVhZHlTdGF0ZSkpKWUub25lcnJvcj1lLm9ubG9hZD1lLm9ucmVhZHlzdGF0ZWNoYW5nZT1yLC0tUixSfHxQKFEsMCksZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksZT1yfTtlLnR5cGU9XG5cInRleHQvamF2YXNjcmlwdFwiO2Uuc3JjPVwiaHR0cHM6Ly9nb29nbGUtY29kZS1wcmV0dGlmeS5nb29nbGVjb2RlLmNvbS9zdm4vbG9hZGVyL2xhbmctXCIrZW5jb2RlVVJJQ29tcG9uZW50KERbbV0pK1wiLmpzXCI7TC5pbnNlcnRCZWZvcmUoZSxMLmZpcnN0Q2hpbGQpfSkoRFttXSk7Zm9yKHZhciBSPUQubGVuZ3RoLEE9W10sbT0wLHo9Ti5sZW5ndGg7bTx6OysrbSlBLnB1c2goXCJodHRwczovL2dvb2dsZS1jb2RlLXByZXR0aWZ5Lmdvb2dsZWNvZGUuY29tL3N2bi9sb2FkZXIvc2tpbnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KE5bbV0pK1wiLmNzc1wiKTtBLnB1c2goXCJodHRwczovL2dvb2dsZS1jb2RlLXByZXR0aWZ5Lmdvb2dsZWNvZGUuY29tL3N2bi9sb2FkZXIvcHJldHRpZnkuY3NzXCIpOyhmdW5jdGlvbihlKXtmdW5jdGlvbiBqKG0pe2lmKG0hPT13KXt2YXIgbj14LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO24ucmVsPVwic3R5bGVzaGVldFwiO24udHlwZT1cInRleHQvY3NzXCI7aWYobSsxPHcpbi5lcnJvcj1cbm4ub25lcnJvcj1mdW5jdGlvbigpe2oobSsxKX07bi5ocmVmPWVbbV07TC5hcHBlbmRDaGlsZChuKX19dmFyIHc9ZS5sZW5ndGg7aigwKX0pKEEpO3ZhciAkPWZ1bmN0aW9uKCl7d2luZG93LlBSX1NIT1VMRF9VU0VfQ09OVElOVUFUSU9OPSEwO3ZhciBlOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGooYSl7ZnVuY3Rpb24gZChmKXt2YXIgYj1mLmNoYXJDb2RlQXQoMCk7aWYoYiE9PTkyKXJldHVybiBiO3ZhciBhPWYuY2hhckF0KDEpO3JldHVybihiPWlbYV0pP2I6XCIwXCI8PWEmJmE8PVwiN1wiP3BhcnNlSW50KGYuc3Vic3RyaW5nKDEpLDgpOmE9PT1cInVcInx8YT09PVwieFwiP3BhcnNlSW50KGYuc3Vic3RyaW5nKDIpLDE2KTpmLmNoYXJDb2RlQXQoMSl9ZnVuY3Rpb24gaChmKXtpZihmPDMyKXJldHVybihmPDE2P1wiXFxcXHgwXCI6XCJcXFxceFwiKStmLnRvU3RyaW5nKDE2KTtmPVN0cmluZy5mcm9tQ2hhckNvZGUoZik7cmV0dXJuIGY9PT1cIlxcXFxcInx8Zj09PVwiLVwifHxmPT09XCJdXCJ8fGY9PT1cIl5cIj9cIlxcXFxcIitmOlxuZn1mdW5jdGlvbiBiKGYpe3ZhciBiPWYuc3Vic3RyaW5nKDEsZi5sZW5ndGgtMSkubWF0Y2goL1xcXFx1W1xcZEEtRmEtZl17NH18XFxcXHhbXFxkQS1GYS1mXXsyfXxcXFxcWzAtM11bMC03XXswLDJ9fFxcXFxbMC03XXsxLDJ9fFxcXFxbXFxTXFxzXXxbXlxcXFxdL2cpLGY9W10sYT1iWzBdPT09XCJeXCIsYz1bXCJbXCJdO2EmJmMucHVzaChcIl5cIik7Zm9yKHZhciBhPWE/MTowLGc9Yi5sZW5ndGg7YTxnOysrYSl7dmFyIGs9YlthXTtpZigvXFxcXFtiZHN3XS9pLnRlc3QoaykpYy5wdXNoKGspO2Vsc2V7dmFyIGs9ZChrKSxvO2ErMjxnJiZcIi1cIj09PWJbYSsxXT8obz1kKGJbYSsyXSksYSs9Mik6bz1rO2YucHVzaChbayxvXSk7bzw2NXx8az4xMjJ8fChvPDY1fHxrPjkwfHxmLnB1c2goW01hdGgubWF4KDY1LGspfDMyLE1hdGgubWluKG8sOTApfDMyXSksbzw5N3x8az4xMjJ8fGYucHVzaChbTWF0aC5tYXgoOTcsaykmLTMzLE1hdGgubWluKG8sMTIyKSYtMzNdKSl9fWYuc29ydChmdW5jdGlvbihmLGEpe3JldHVybiBmWzBdLVxuYVswXXx8YVsxXS1mWzFdfSk7Yj1bXTtnPVtdO2ZvcihhPTA7YTxmLmxlbmd0aDsrK2Epaz1mW2FdLGtbMF08PWdbMV0rMT9nWzFdPU1hdGgubWF4KGdbMV0sa1sxXSk6Yi5wdXNoKGc9ayk7Zm9yKGE9MDthPGIubGVuZ3RoOysrYSlrPWJbYV0sYy5wdXNoKGgoa1swXSkpLGtbMV0+a1swXSYmKGtbMV0rMT5rWzBdJiZjLnB1c2goXCItXCIpLGMucHVzaChoKGtbMV0pKSk7Yy5wdXNoKFwiXVwiKTtyZXR1cm4gYy5qb2luKFwiXCIpfWZ1bmN0aW9uIGUoZil7Zm9yKHZhciBhPWYuc291cmNlLm1hdGNoKC9cXFsoPzpbXlxcXFxcXF1dfFxcXFxbXFxTXFxzXSkqXXxcXFxcdVtcXGRBLUZhLWZdezR9fFxcXFx4W1xcZEEtRmEtZl17Mn18XFxcXFxcZCt8XFxcXFteXFxkdXhdfFxcKFxcP1shOj1dfFsoKV5dfFteKClbXFxcXF5dKy9nKSxjPWEubGVuZ3RoLGQ9W10sZz0wLGs9MDtnPGM7KytnKXt2YXIgbz1hW2ddO289PT1cIihcIj8rK2s6XCJcXFxcXCI9PT1vLmNoYXJBdCgwKSYmKG89K28uc3Vic3RyaW5nKDEpKSYmKG88PWs/ZFtvXT0tMTphW2ddPWgobykpfWZvcihnPVxuMTtnPGQubGVuZ3RoOysrZyktMT09PWRbZ10mJihkW2ddPSsraik7Zm9yKGs9Zz0wO2c8YzsrK2cpbz1hW2ddLG89PT1cIihcIj8oKytrLGRba118fChhW2ddPVwiKD86XCIpKTpcIlxcXFxcIj09PW8uY2hhckF0KDApJiYobz0rby5zdWJzdHJpbmcoMSkpJiZvPD1rJiYoYVtnXT1cIlxcXFxcIitkW29dKTtmb3IoZz0wO2c8YzsrK2cpXCJeXCI9PT1hW2ddJiZcIl5cIiE9PWFbZysxXSYmKGFbZ109XCJcIik7aWYoZi5pZ25vcmVDYXNlJiZGKWZvcihnPTA7ZzxjOysrZylvPWFbZ10sZj1vLmNoYXJBdCgwKSxvLmxlbmd0aD49MiYmZj09PVwiW1wiP2FbZ109YihvKTpmIT09XCJcXFxcXCImJihhW2ddPW8ucmVwbGFjZSgvW0EtWmEtel0vZyxmdW5jdGlvbihhKXthPWEuY2hhckNvZGVBdCgwKTtyZXR1cm5cIltcIitTdHJpbmcuZnJvbUNoYXJDb2RlKGEmLTMzLGF8MzIpK1wiXVwifSkpO3JldHVybiBhLmpvaW4oXCJcIil9Zm9yKHZhciBqPTAsRj0hMSxsPSExLEk9MCxjPWEubGVuZ3RoO0k8YzsrK0kpe3ZhciBwPWFbSV07aWYocC5pZ25vcmVDYXNlKWw9XG4hMDtlbHNlIGlmKC9bYS16XS9pLnRlc3QocC5zb3VyY2UucmVwbGFjZSgvXFxcXHVbXFxkYS1mXXs0fXxcXFxceFtcXGRhLWZdezJ9fFxcXFxbXlVYdXhdL2dpLFwiXCIpKSl7Rj0hMDtsPSExO2JyZWFrfX1mb3IodmFyIGk9e2I6OCx0OjksbjoxMCx2OjExLGY6MTIscjoxM30scT1bXSxJPTAsYz1hLmxlbmd0aDtJPGM7KytJKXtwPWFbSV07aWYocC5nbG9iYWx8fHAubXVsdGlsaW5lKXRocm93IEVycm9yKFwiXCIrcCk7cS5wdXNoKFwiKD86XCIrZShwKStcIilcIil9cmV0dXJuIFJlZ0V4cChxLmpvaW4oXCJ8XCIpLGw/XCJnaVwiOlwiZ1wiKX1mdW5jdGlvbiBtKGEsZCl7ZnVuY3Rpb24gaChhKXt2YXIgYz1hLm5vZGVUeXBlO2lmKGM9PTEpe2lmKCFiLnRlc3QoYS5jbGFzc05hbWUpKXtmb3IoYz1hLmZpcnN0Q2hpbGQ7YztjPWMubmV4dFNpYmxpbmcpaChjKTtjPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcImJyXCI9PT1jfHxcImxpXCI9PT1jKWVbbF09XCJcXG5cIixGW2w8PDFdPWorKyxGW2wrKzw8MXwxXT1hfX1lbHNlIGlmKGM9PVxuM3x8Yz09NCljPWEubm9kZVZhbHVlLGMubGVuZ3RoJiYoYz1kP2MucmVwbGFjZSgvXFxyXFxuPy9nLFwiXFxuXCIpOmMucmVwbGFjZSgvW1xcdFxcblxcciBdKy9nLFwiIFwiKSxlW2xdPWMsRltsPDwxXT1qLGorPWMubGVuZ3RoLEZbbCsrPDwxfDFdPWEpfXZhciBiPS8oPzpefFxccylub2NvZGUoPzpcXHN8JCkvLGU9W10saj0wLEY9W10sbD0wO2goYSk7cmV0dXJue2E6ZS5qb2luKFwiXCIpLnJlcGxhY2UoL1xcbiQvLFwiXCIpLGQ6Rn19ZnVuY3Rpb24gbihhLGQsaCxiKXtkJiYoYT17YTpkLGU6YX0saChhKSxiLnB1c2guYXBwbHkoYixhLmcpKX1mdW5jdGlvbiB4KGEpe2Zvcih2YXIgZD12b2lkIDAsaD1hLmZpcnN0Q2hpbGQ7aDtoPWgubmV4dFNpYmxpbmcpdmFyIGI9aC5ub2RlVHlwZSxkPWI9PT0xP2Q/YTpoOmI9PT0zP1MudGVzdChoLm5vZGVWYWx1ZSk/YTpkOmQ7cmV0dXJuIGQ9PT1hP3ZvaWQgMDpkfWZ1bmN0aW9uIEMoYSxkKXtmdW5jdGlvbiBoKGEpe2Zvcih2YXIgbD1hLmUsaj1bbCxcInBsblwiXSxjPVxuMCxwPWEuYS5tYXRjaChlKXx8W10sbT17fSxxPTAsZj1wLmxlbmd0aDtxPGY7KytxKXt2YXIgQj1wW3FdLHk9bVtCXSx1PXZvaWQgMCxnO2lmKHR5cGVvZiB5PT09XCJzdHJpbmdcIilnPSExO2Vsc2V7dmFyIGs9YltCLmNoYXJBdCgwKV07aWYoayl1PUIubWF0Y2goa1sxXSkseT1rWzBdO2Vsc2V7Zm9yKGc9MDtnPGk7KytnKWlmKGs9ZFtnXSx1PUIubWF0Y2goa1sxXSkpe3k9a1swXTticmVha311fHwoeT1cInBsblwiKX1pZigoZz15Lmxlbmd0aD49NSYmXCJsYW5nLVwiPT09eS5zdWJzdHJpbmcoMCw1KSkmJiEodSYmdHlwZW9mIHVbMV09PT1cInN0cmluZ1wiKSlnPSExLHk9XCJzcmNcIjtnfHwobVtCXT15KX1rPWM7Yys9Qi5sZW5ndGg7aWYoZyl7Zz11WzFdO3ZhciBvPUIuaW5kZXhPZihnKSxIPW8rZy5sZW5ndGg7dVsyXSYmKEg9Qi5sZW5ndGgtdVsyXS5sZW5ndGgsbz1ILWcubGVuZ3RoKTt5PXkuc3Vic3RyaW5nKDUpO24obCtrLEIuc3Vic3RyaW5nKDAsbyksaCxqKTtuKGwraytvLGcsQSh5LFxuZyksaik7bihsK2srSCxCLnN1YnN0cmluZyhIKSxoLGopfWVsc2Ugai5wdXNoKGwrayx5KX1hLmc9an12YXIgYj17fSxlOyhmdW5jdGlvbigpe2Zvcih2YXIgaD1hLmNvbmNhdChkKSxsPVtdLGk9e30sYz0wLHA9aC5sZW5ndGg7YzxwOysrYyl7dmFyIG09aFtjXSxxPW1bM107aWYocSlmb3IodmFyIGY9cS5sZW5ndGg7LS1mPj0wOyliW3EuY2hhckF0KGYpXT1tO209bVsxXTtxPVwiXCIrbTtpLmhhc093blByb3BlcnR5KHEpfHwobC5wdXNoKG0pLGlbcV09cil9bC5wdXNoKC9bXFxTXFxzXS8pO2U9aihsKX0pKCk7dmFyIGk9ZC5sZW5ndGg7cmV0dXJuIGh9ZnVuY3Rpb24gdChhKXt2YXIgZD1bXSxoPVtdO2EudHJpcGxlUXVvdGVkU3RyaW5ncz9kLnB1c2goW1wic3RyXCIsL14oPzonJycoPzpbXidcXFxcXXxcXFxcW1xcU1xcc118Jyc/KD89W14nXSkpKig/OicnJ3wkKXxcIlwiXCIoPzpbXlwiXFxcXF18XFxcXFtcXFNcXHNdfFwiXCI/KD89W15cIl0pKSooPzpcIlwiXCJ8JCl8Jyg/OlteJ1xcXFxdfFxcXFxbXFxTXFxzXSkqKD86J3wkKXxcIig/OlteXCJcXFxcXXxcXFxcW1xcU1xcc10pKig/OlwifCQpKS8sXG5yLFwiJ1xcXCJcIl0pOmEubXVsdGlMaW5lU3RyaW5ncz9kLnB1c2goW1wic3RyXCIsL14oPzonKD86W14nXFxcXF18XFxcXFtcXFNcXHNdKSooPzonfCQpfFwiKD86W15cIlxcXFxdfFxcXFxbXFxTXFxzXSkqKD86XCJ8JCl8YCg/OlteXFxcXGBdfFxcXFxbXFxTXFxzXSkqKD86YHwkKSkvLHIsXCInXFxcImBcIl0pOmQucHVzaChbXCJzdHJcIiwvXig/OicoPzpbXlxcblxccidcXFxcXXxcXFxcLikqKD86J3wkKXxcIig/OlteXFxuXFxyXCJcXFxcXXxcXFxcLikqKD86XCJ8JCkpLyxyLFwiXFxcIidcIl0pO2EudmVyYmF0aW1TdHJpbmdzJiZoLnB1c2goW1wic3RyXCIsL15AXCIoPzpbXlwiXXxcIlwiKSooPzpcInwkKS8scl0pO3ZhciBiPWEuaGFzaENvbW1lbnRzO2ImJihhLmNTdHlsZUNvbW1lbnRzPyhiPjE/ZC5wdXNoKFtcImNvbVwiLC9eIyg/OiMjKD86W14jXXwjKD8hIyMpKSooPzojIyN8JCl8LiopLyxyLFwiI1wiXSk6ZC5wdXNoKFtcImNvbVwiLC9eIyg/Oig/OmRlZmluZXxlKD86bHxuZClpZnxlbHNlfGVycm9yfGlmbj9kZWZ8aW5jbHVkZXxsaW5lfHByYWdtYXx1bmRlZnx3YXJuaW5nKVxcYnxbXlxcblxccl0qKS8sXG5yLFwiI1wiXSksaC5wdXNoKFtcInN0clwiLC9ePCg/Oig/Oig/OlxcLlxcLlxcLykqfFxcLz8pKD86W1xcdy1dKyg/OlxcL1tcXHctXSspKyk/W1xcdy1dK1xcLmgoPzpofHBwfFxcK1xcKyk/fFthLXpdXFx3Kik+LyxyXSkpOmQucHVzaChbXCJjb21cIiwvXiNbXlxcblxccl0qLyxyLFwiI1wiXSkpO2EuY1N0eWxlQ29tbWVudHMmJihoLnB1c2goW1wiY29tXCIsL15cXC9cXC9bXlxcblxccl0qLyxyXSksaC5wdXNoKFtcImNvbVwiLC9eXFwvXFwqW1xcU1xcc10qPyg/OlxcKlxcL3wkKS8scl0pKTtpZihiPWEucmVnZXhMaXRlcmFscyl7dmFyIGU9KGI9Yj4xP1wiXCI6XCJcXG5cXHJcIik/XCIuXCI6XCJbXFxcXFNcXFxcc11cIjtoLnB1c2goW1wibGFuZy1yZWdleFwiLFJlZ0V4cChcIl4oPzpeXlxcXFwuP3xbKy1dfFshPV09Pz0/fFxcXFwjfCU9P3wmJj89P3xcXFxcKHxcXFxcKj0/fFsrXFxcXC1dPXwtPnxcXFxcLz0/fDo6P3w8PD89P3w+Pj8+Pz0/fCx8O3xcXFxcP3xAfFxcXFxbfH58e3xcXFxcXlxcXFxePz0/fFxcXFx8XFxcXHw/PT98YnJlYWt8Y2FzZXxjb250aW51ZXxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGluc3RhbmNlb2Z8cmV0dXJufHRocm93fHRyeXx0eXBlb2YpXFxcXHMqKFwiK1xuKFwiLyg/PVteLypcIitiK1wiXSkoPzpbXi9cXFxceDVCXFxcXHg1Q1wiK2IrXCJdfFxcXFx4NUNcIitlK1wifFxcXFx4NUIoPzpbXlxcXFx4NUNcXFxceDVEXCIrYitcIl18XFxcXHg1Q1wiK2UrXCIpKig/OlxcXFx4NUR8JCkpKy9cIikrXCIpXCIpXSl9KGI9YS50eXBlcykmJmgucHVzaChbXCJ0eXBcIixiXSk7Yj0oXCJcIithLmtleXdvcmRzKS5yZXBsYWNlKC9eIHwgJC9nLFwiXCIpO2IubGVuZ3RoJiZoLnB1c2goW1wia3dkXCIsUmVnRXhwKFwiXig/OlwiK2IucmVwbGFjZSgvW1xccyxdKy9nLFwifFwiKStcIilcXFxcYlwiKSxyXSk7ZC5wdXNoKFtcInBsblwiLC9eXFxzKy8scixcIiBcXHJcXG5cXHRcXHUwMGEwXCJdKTtiPVwiXi5bXlxcXFxzXFxcXHcuJEAnXFxcImAvXFxcXFxcXFxdKlwiO2EucmVnZXhMaXRlcmFscyYmKGIrPVwiKD8hcyovKVwiKTtoLnB1c2goW1wibGl0XCIsL15AWyRfYS16XVtcXHckQF0qL2kscl0sW1widHlwXCIsL14oPzpbQF9dP1tBLVpdK1thLXpdW1xcdyRAXSp8XFx3K190XFxiKS8scl0sW1wicGxuXCIsL15bJF9hLXpdW1xcdyRAXSovaSxyXSxbXCJsaXRcIiwvXig/OjB4W1xcZGEtZl0rfCg/OlxcZCg/Ol9cXGQrKSpcXGQqKD86XFwuXFxkKik/fFxcLlxcZFxcKykoPzplWystXT9cXGQrKT8pW2Etel0qL2ksXG5yLFwiMDEyMzQ1Njc4OVwiXSxbXCJwbG5cIiwvXlxcXFxbXFxTXFxzXT8vLHJdLFtcInB1blwiLFJlZ0V4cChiKSxyXSk7cmV0dXJuIEMoZCxoKX1mdW5jdGlvbiB6KGEsZCxoKXtmdW5jdGlvbiBiKGEpe3ZhciBjPWEubm9kZVR5cGU7aWYoYz09MSYmIWoudGVzdChhLmNsYXNzTmFtZSkpaWYoXCJiclwiPT09YS5ub2RlTmFtZSllKGEpLGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2Vsc2UgZm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWIoYSk7ZWxzZSBpZigoYz09M3x8Yz09NCkmJmgpe3ZhciBkPWEubm9kZVZhbHVlLGk9ZC5tYXRjaChtKTtpZihpKWM9ZC5zdWJzdHJpbmcoMCxpLmluZGV4KSxhLm5vZGVWYWx1ZT1jLChkPWQuc3Vic3RyaW5nKGkuaW5kZXgraVswXS5sZW5ndGgpKSYmYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsLmNyZWF0ZVRleHROb2RlKGQpLGEubmV4dFNpYmxpbmcpLGUoYSksY3x8YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfX1cbmZ1bmN0aW9uIGUoYSl7ZnVuY3Rpb24gYihhLGMpe3ZhciBkPWM/YS5jbG9uZU5vZGUoITEpOmEsZj1hLnBhcmVudE5vZGU7aWYoZil7dmFyIGY9YihmLDEpLGg9YS5uZXh0U2libGluZztmLmFwcGVuZENoaWxkKGQpO2Zvcih2YXIgZT1oO2U7ZT1oKWg9ZS5uZXh0U2libGluZyxmLmFwcGVuZENoaWxkKGUpfXJldHVybiBkfWZvcig7IWEubmV4dFNpYmxpbmc7KWlmKGE9YS5wYXJlbnROb2RlLCFhKXJldHVybjtmb3IodmFyIGE9YihhLm5leHRTaWJsaW5nLDApLGQ7KGQ9YS5wYXJlbnROb2RlKSYmZC5ub2RlVHlwZT09PTE7KWE9ZDtjLnB1c2goYSl9Zm9yKHZhciBqPS8oPzpefFxccylub2NvZGUoPzpcXHN8JCkvLG09L1xcclxcbj98XFxuLyxsPWEub3duZXJEb2N1bWVudCxpPWwuY3JlYXRlRWxlbWVudChcImxpXCIpO2EuZmlyc3RDaGlsZDspaS5hcHBlbmRDaGlsZChhLmZpcnN0Q2hpbGQpO2Zvcih2YXIgYz1baV0scD0wO3A8Yy5sZW5ndGg7KytwKWIoY1twXSk7ZD09PShkfDApJiZjWzBdLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXG5kKTt2YXIgbj1sLmNyZWF0ZUVsZW1lbnQoXCJvbFwiKTtuLmNsYXNzTmFtZT1cImxpbmVudW1zXCI7Zm9yKHZhciBkPU1hdGgubWF4KDAsZC0xfDApfHwwLHA9MCxxPWMubGVuZ3RoO3A8cTsrK3ApaT1jW3BdLGkuY2xhc3NOYW1lPVwiTFwiKyhwK2QpJTEwLGkuZmlyc3RDaGlsZHx8aS5hcHBlbmRDaGlsZChsLmNyZWF0ZVRleHROb2RlKFwiXFx1MDBhMFwiKSksbi5hcHBlbmRDaGlsZChpKTthLmFwcGVuZENoaWxkKG4pfWZ1bmN0aW9uIGkoYSxkKXtmb3IodmFyIGg9ZC5sZW5ndGg7LS1oPj0wOyl7dmFyIGI9ZFtoXTtVLmhhc093blByb3BlcnR5KGIpP1YuY29uc29sZSYmY29uc29sZS53YXJuKFwiY2Fubm90IG92ZXJyaWRlIGxhbmd1YWdlIGhhbmRsZXIgJXNcIixiKTpVW2JdPWF9fWZ1bmN0aW9uIEEoYSxkKXtpZighYXx8IVUuaGFzT3duUHJvcGVydHkoYSkpYT0vXlxccyo8Ly50ZXN0KGQpP1wiZGVmYXVsdC1tYXJrdXBcIjpcImRlZmF1bHQtY29kZVwiO3JldHVybiBVW2FdfWZ1bmN0aW9uIEQoYSl7dmFyIGQ9XG5hLmg7dHJ5e3ZhciBoPW0oYS5jLGEuaSksYj1oLmE7YS5hPWI7YS5kPWguZDthLmU9MDtBKGQsYikoYSk7dmFyIGU9L1xcYk1TSUVcXHMoXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCksZT1lJiYrZVsxXTw9OCxkPS9cXG4vZyxpPWEuYSxqPWkubGVuZ3RoLGg9MCxsPWEuZCxuPWwubGVuZ3RoLGI9MCxjPWEuZyxwPWMubGVuZ3RoLHQ9MDtjW3BdPWo7dmFyIHEsZjtmb3IoZj1xPTA7ZjxwOyljW2ZdIT09Y1tmKzJdPyhjW3ErK109Y1tmKytdLGNbcSsrXT1jW2YrK10pOmYrPTI7cD1xO2ZvcihmPXE9MDtmPHA7KXtmb3IodmFyIHg9Y1tmXSx5PWNbZisxXSx1PWYrMjt1KzI8PXAmJmNbdSsxXT09PXk7KXUrPTI7Y1txKytdPXg7Y1txKytdPXk7Zj11fWMubGVuZ3RoPXE7dmFyIGc9YS5jLGs7aWYoZylrPWcuc3R5bGUuZGlzcGxheSxnLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7dHJ5e2Zvcig7YjxuOyl7dmFyIG89bFtiKzJdfHxqLEg9Y1t0KzJdfHxqLHU9TWF0aC5taW4obyxIKSxFPWxbYitcbjFdLFc7aWYoRS5ub2RlVHlwZSE9PTEmJihXPWkuc3Vic3RyaW5nKGgsdSkpKXtlJiYoVz1XLnJlcGxhY2UoZCxcIlxcclwiKSk7RS5ub2RlVmFsdWU9Vzt2YXIgWj1FLm93bmVyRG9jdW1lbnQscz1aLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3MuY2xhc3NOYW1lPWNbdCsxXTt2YXIgej1FLnBhcmVudE5vZGU7ei5yZXBsYWNlQ2hpbGQocyxFKTtzLmFwcGVuZENoaWxkKEUpO2g8byYmKGxbYisxXT1FPVouY3JlYXRlVGV4dE5vZGUoaS5zdWJzdHJpbmcodSxvKSksei5pbnNlcnRCZWZvcmUoRSxzLm5leHRTaWJsaW5nKSl9aD11O2g+PW8mJihiKz0yKTtoPj1IJiYodCs9Mil9fWZpbmFsbHl7aWYoZylnLnN0eWxlLmRpc3BsYXk9a319Y2F0Y2godil7Vi5jb25zb2xlJiZjb25zb2xlLmxvZyh2JiZ2LnN0YWNrfHx2KX19dmFyIFY9d2luZG93LEc9W1wiYnJlYWssY29udGludWUsZG8sZWxzZSxmb3IsaWYscmV0dXJuLHdoaWxlXCJdLE89W1tHLFwiYXV0byxjYXNlLGNoYXIsY29uc3QsZGVmYXVsdCxkb3VibGUsZW51bSxleHRlcm4sZmxvYXQsZ290byxpbmxpbmUsaW50LGxvbmcscmVnaXN0ZXIsc2hvcnQsc2lnbmVkLHNpemVvZixzdGF0aWMsc3RydWN0LHN3aXRjaCx0eXBlZGVmLHVuaW9uLHVuc2lnbmVkLHZvaWQsdm9sYXRpbGVcIl0sXG5cImNhdGNoLGNsYXNzLGRlbGV0ZSxmYWxzZSxpbXBvcnQsbmV3LG9wZXJhdG9yLHByaXZhdGUscHJvdGVjdGVkLHB1YmxpYyx0aGlzLHRocm93LHRydWUsdHJ5LHR5cGVvZlwiXSxKPVtPLFwiYWxpZ25vZixhbGlnbl91bmlvbixhc20sYXhpb20sYm9vbCxjb25jZXB0LGNvbmNlcHRfbWFwLGNvbnN0X2Nhc3QsY29uc3RleHByLGRlY2x0eXBlLGRlbGVnYXRlLGR5bmFtaWNfY2FzdCxleHBsaWNpdCxleHBvcnQsZnJpZW5kLGdlbmVyaWMsbGF0ZV9jaGVjayxtdXRhYmxlLG5hbWVzcGFjZSxudWxscHRyLHByb3BlcnR5LHJlaW50ZXJwcmV0X2Nhc3Qsc3RhdGljX2Fzc2VydCxzdGF0aWNfY2FzdCx0ZW1wbGF0ZSx0eXBlaWQsdHlwZW5hbWUsdXNpbmcsdmlydHVhbCx3aGVyZVwiXSxLPVtPLFwiYWJzdHJhY3QsYXNzZXJ0LGJvb2xlYW4sYnl0ZSxleHRlbmRzLGZpbmFsLGZpbmFsbHksaW1wbGVtZW50cyxpbXBvcnQsaW5zdGFuY2VvZixpbnRlcmZhY2UsbnVsbCxuYXRpdmUscGFja2FnZSxzdHJpY3RmcCxzdXBlcixzeW5jaHJvbml6ZWQsdGhyb3dzLHRyYW5zaWVudFwiXSxcbkw9W0ssXCJhcyxiYXNlLGJ5LGNoZWNrZWQsZGVjaW1hbCxkZWxlZ2F0ZSxkZXNjZW5kaW5nLGR5bmFtaWMsZXZlbnQsZml4ZWQsZm9yZWFjaCxmcm9tLGdyb3VwLGltcGxpY2l0LGluLGludGVybmFsLGludG8saXMsbGV0LGxvY2ssb2JqZWN0LG91dCxvdmVycmlkZSxvcmRlcmJ5LHBhcmFtcyxwYXJ0aWFsLHJlYWRvbmx5LHJlZixzYnl0ZSxzZWFsZWQsc3RhY2thbGxvYyxzdHJpbmcsc2VsZWN0LHVpbnQsdWxvbmcsdW5jaGVja2VkLHVuc2FmZSx1c2hvcnQsdmFyLHZpcnR1YWwsd2hlcmVcIl0sTz1bTyxcImRlYnVnZ2VyLGV2YWwsZXhwb3J0LGZ1bmN0aW9uLGdldCxudWxsLHNldCx1bmRlZmluZWQsdmFyLHdpdGgsSW5maW5pdHksTmFOXCJdLE09W0csXCJhbmQsYXMsYXNzZXJ0LGNsYXNzLGRlZixkZWwsZWxpZixleGNlcHQsZXhlYyxmaW5hbGx5LGZyb20sZ2xvYmFsLGltcG9ydCxpbixpcyxsYW1iZGEsbm9ubG9jYWwsbm90LG9yLHBhc3MscHJpbnQscmFpc2UsdHJ5LHdpdGgseWllbGQsRmFsc2UsVHJ1ZSxOb25lXCJdLFxuTj1bRyxcImFsaWFzLGFuZCxiZWdpbixjYXNlLGNsYXNzLGRlZixkZWZpbmVkLGVsc2lmLGVuZCxlbnN1cmUsZmFsc2UsaW4sbW9kdWxlLG5leHQsbmlsLG5vdCxvcixyZWRvLHJlc2N1ZSxyZXRyeSxzZWxmLHN1cGVyLHRoZW4sdHJ1ZSx1bmRlZix1bmxlc3MsdW50aWwsd2hlbix5aWVsZCxCRUdJTixFTkRcIl0sUj1bRyxcImFzLGFzc2VydCxjb25zdCxjb3B5LGRyb3AsZW51bSxleHRlcm4sZmFpbCxmYWxzZSxmbixpbXBsLGxldCxsb2csbG9vcCxtYXRjaCxtb2QsbW92ZSxtdXQscHJpdixwdWIscHVyZSxyZWYsc2VsZixzdGF0aWMsc3RydWN0LHRydWUsdHJhaXQsdHlwZSx1bnNhZmUsdXNlXCJdLEc9W0csXCJjYXNlLGRvbmUsZWxpZixlc2FjLGV2YWwsZmksZnVuY3Rpb24saW4sbG9jYWwsc2V0LHRoZW4sdW50aWxcIl0sUT0vXihESVJ8RklMRXx2ZWN0b3J8KGRlfHByaW9yaXR5Xyk/cXVldWV8bGlzdHxzdGFja3woY29uc3RfKT9pdGVyYXRvcnwobXVsdGkpPyhzZXR8bWFwKXxiaXRzZXR8dT8oaW50fGZsb2F0KVxcZCopXFxiLyxcblM9L1xcUy8sVD10KHtrZXl3b3JkczpbSixMLE8sXCJjYWxsZXIsZGVsZXRlLGRpZSxkbyxkdW1wLGVsc2lmLGV2YWwsZXhpdCxmb3JlYWNoLGZvcixnb3RvLGlmLGltcG9ydCxsYXN0LGxvY2FsLG15LG5leHQsbm8sb3VyLHByaW50LHBhY2thZ2UscmVkbyxyZXF1aXJlLHN1Yix1bmRlZix1bmxlc3MsdW50aWwsdXNlLHdhbnRhcnJheSx3aGlsZSxCRUdJTixFTkRcIixNLE4sR10saGFzaENvbW1lbnRzOiEwLGNTdHlsZUNvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczohMH0pLFU9e307aShULFtcImRlZmF1bHQtY29kZVwiXSk7aShDKFtdLFtbXCJwbG5cIiwvXltePD9dKy9dLFtcImRlY1wiLC9ePCFcXHdbXj5dKig/Oj58JCkvXSxbXCJjb21cIiwvXjxcXCEtLVtcXFNcXHNdKj8oPzotLVxcPnwkKS9dLFtcImxhbmctXCIsL148XFw/KFtcXFNcXHNdKz8pKD86XFw/PnwkKS9dLFtcImxhbmctXCIsL148JShbXFxTXFxzXSs/KSg/OiU+fCQpL10sW1wicHVuXCIsL14oPzo8WyU/XXxbJT9dPikvXSxbXCJsYW5nLVwiLFxuL148eG1wXFxiW14+XSo+KFtcXFNcXHNdKz8pPFxcL3htcFxcYltePl0qPi9pXSxbXCJsYW5nLWpzXCIsL148c2NyaXB0XFxiW14+XSo+KFtcXFNcXHNdKj8pKDxcXC9zY3JpcHRcXGJbXj5dKj4pL2ldLFtcImxhbmctY3NzXCIsL148c3R5bGVcXGJbXj5dKj4oW1xcU1xcc10qPykoPFxcL3N0eWxlXFxiW14+XSo+KS9pXSxbXCJsYW5nLWluLnRhZ1wiLC9eKDxcXC8/W2Etel1bXjw+XSo+KS9pXV0pLFtcImRlZmF1bHQtbWFya3VwXCIsXCJodG1cIixcImh0bWxcIixcIm14bWxcIixcInhodG1sXCIsXCJ4bWxcIixcInhzbFwiXSk7aShDKFtbXCJwbG5cIiwvXlxccysvLHIsXCIgXFx0XFxyXFxuXCJdLFtcImF0dlwiLC9eKD86XCJbXlwiXSpcIj98J1teJ10qJz8pLyxyLFwiXFxcIidcIl1dLFtbXCJ0YWdcIiwvXl48XFwvP1thLXpdKD86W1xcdy0uOl0qXFx3KT98XFwvPz4kL2ldLFtcImF0blwiLC9eKD8hc3R5bGVbXFxzPV18b24pW2Etel0oPzpbXFx3Oi1dKlxcdyk/L2ldLFtcImxhbmctdXEudmFsXCIsL149XFxzKihbXlxcc1wiJz5dKig/OlteXFxzXCInLz5dfFxcLyg/PVxccykpKS9dLFtcInB1blwiLC9eWy88LT5dKy9dLFxuW1wibGFuZy1qc1wiLC9eb25cXHcrXFxzKj1cXHMqXCIoW15cIl0rKVwiL2ldLFtcImxhbmctanNcIiwvXm9uXFx3K1xccyo9XFxzKicoW14nXSspJy9pXSxbXCJsYW5nLWpzXCIsL15vblxcdytcXHMqPVxccyooW15cXHNcIic+XSspL2ldLFtcImxhbmctY3NzXCIsL15zdHlsZVxccyo9XFxzKlwiKFteXCJdKylcIi9pXSxbXCJsYW5nLWNzc1wiLC9ec3R5bGVcXHMqPVxccyonKFteJ10rKScvaV0sW1wibGFuZy1jc3NcIiwvXnN0eWxlXFxzKj1cXHMqKFteXFxzXCInPl0rKS9pXV0pLFtcImluLnRhZ1wiXSk7aShDKFtdLFtbXCJhdHZcIiwvXltcXFNcXHNdKy9dXSksW1widXEudmFsXCJdKTtpKHQoe2tleXdvcmRzOkosaGFzaENvbW1lbnRzOiEwLGNTdHlsZUNvbW1lbnRzOiEwLHR5cGVzOlF9KSxbXCJjXCIsXCJjY1wiLFwiY3BwXCIsXCJjeHhcIixcImN5Y1wiLFwibVwiXSk7aSh0KHtrZXl3b3JkczpcIm51bGwsdHJ1ZSxmYWxzZVwifSksW1wianNvblwiXSk7aSh0KHtrZXl3b3JkczpMLGhhc2hDb21tZW50czohMCxjU3R5bGVDb21tZW50czohMCx2ZXJiYXRpbVN0cmluZ3M6ITAsdHlwZXM6UX0pLFxuW1wiY3NcIl0pO2kodCh7a2V5d29yZHM6SyxjU3R5bGVDb21tZW50czohMH0pLFtcImphdmFcIl0pO2kodCh7a2V5d29yZHM6RyxoYXNoQ29tbWVudHM6ITAsbXVsdGlMaW5lU3RyaW5nczohMH0pLFtcImJhc2hcIixcImJzaFwiLFwiY3NoXCIsXCJzaFwiXSk7aSh0KHtrZXl3b3JkczpNLGhhc2hDb21tZW50czohMCxtdWx0aUxpbmVTdHJpbmdzOiEwLHRyaXBsZVF1b3RlZFN0cmluZ3M6ITB9KSxbXCJjdlwiLFwicHlcIixcInB5dGhvblwiXSk7aSh0KHtrZXl3b3JkczpcImNhbGxlcixkZWxldGUsZGllLGRvLGR1bXAsZWxzaWYsZXZhbCxleGl0LGZvcmVhY2gsZm9yLGdvdG8saWYsaW1wb3J0LGxhc3QsbG9jYWwsbXksbmV4dCxubyxvdXIscHJpbnQscGFja2FnZSxyZWRvLHJlcXVpcmUsc3ViLHVuZGVmLHVubGVzcyx1bnRpbCx1c2Usd2FudGFycmF5LHdoaWxlLEJFR0lOLEVORFwiLGhhc2hDb21tZW50czohMCxtdWx0aUxpbmVTdHJpbmdzOiEwLHJlZ2V4TGl0ZXJhbHM6Mn0pLFtcInBlcmxcIixcInBsXCIsXCJwbVwiXSk7aSh0KHtrZXl3b3JkczpOLFxuaGFzaENvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczohMH0pLFtcInJiXCIsXCJydWJ5XCJdKTtpKHQoe2tleXdvcmRzOk8sY1N0eWxlQ29tbWVudHM6ITAscmVnZXhMaXRlcmFsczohMH0pLFtcImphdmFzY3JpcHRcIixcImpzXCJdKTtpKHQoe2tleXdvcmRzOlwiYWxsLGFuZCxieSxjYXRjaCxjbGFzcyxlbHNlLGV4dGVuZHMsZmFsc2UsZmluYWxseSxmb3IsaWYsaW4saXMsaXNudCxsb29wLG5ldyxubyxub3QsbnVsbCxvZixvZmYsb24sb3IscmV0dXJuLHN1cGVyLHRoZW4sdGhyb3csdHJ1ZSx0cnksdW5sZXNzLHVudGlsLHdoZW4sd2hpbGUseWVzXCIsaGFzaENvbW1lbnRzOjMsY1N0eWxlQ29tbWVudHM6ITAsbXVsdGlsaW5lU3RyaW5nczohMCx0cmlwbGVRdW90ZWRTdHJpbmdzOiEwLHJlZ2V4TGl0ZXJhbHM6ITB9KSxbXCJjb2ZmZWVcIl0pO2kodCh7a2V5d29yZHM6UixjU3R5bGVDb21tZW50czohMCxtdWx0aWxpbmVTdHJpbmdzOiEwfSksW1wicmNcIixcInJzXCIsXCJydXN0XCJdKTtcbmkoQyhbXSxbW1wic3RyXCIsL15bXFxTXFxzXSsvXV0pLFtcInJlZ2V4XCJdKTt2YXIgWD1WLlBSPXtjcmVhdGVTaW1wbGVMZXhlcjpDLHJlZ2lzdGVyTGFuZ0hhbmRsZXI6aSxzb3VyY2VEZWNvcmF0b3I6dCxQUl9BVFRSSUJfTkFNRTpcImF0blwiLFBSX0FUVFJJQl9WQUxVRTpcImF0dlwiLFBSX0NPTU1FTlQ6XCJjb21cIixQUl9ERUNMQVJBVElPTjpcImRlY1wiLFBSX0tFWVdPUkQ6XCJrd2RcIixQUl9MSVRFUkFMOlwibGl0XCIsUFJfTk9DT0RFOlwibm9jb2RlXCIsUFJfUExBSU46XCJwbG5cIixQUl9QVU5DVFVBVElPTjpcInB1blwiLFBSX1NPVVJDRTpcInNyY1wiLFBSX1NUUklORzpcInN0clwiLFBSX1RBRzpcInRhZ1wiLFBSX1RZUEU6XCJ0eXBcIixwcmV0dHlQcmludE9uZTpmdW5jdGlvbihhLGQsZSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtiLmlubmVySFRNTD1cIjxwcmU+XCIrYStcIjwvcHJlPlwiO2I9Yi5maXJzdENoaWxkO2UmJnooYixlLCEwKTtEKHtoOmQsajplLGM6YixpOjF9KTtyZXR1cm4gYi5pbm5lckhUTUx9LFxucHJldHR5UHJpbnQ6ZT1lPWZ1bmN0aW9uKGEsZCl7ZnVuY3Rpb24gZSgpe2Zvcih2YXIgYj1WLlBSX1NIT1VMRF9VU0VfQ09OVElOVUFUSU9OP2Mubm93KCkrMjUwOkluZmluaXR5O3A8ai5sZW5ndGgmJmMubm93KCk8YjtwKyspe2Zvcih2YXIgZD1qW3BdLG09ayxsPWQ7bD1sLnByZXZpb3VzU2libGluZzspe3ZhciBuPWwubm9kZVR5cGUscz0obj09PTd8fG49PT04KSYmbC5ub2RlVmFsdWU7aWYocz8hL15cXD8/cHJldHRpZnlcXGIvLnRlc3Qocyk6biE9PTN8fC9cXFMvLnRlc3QobC5ub2RlVmFsdWUpKWJyZWFrO2lmKHMpe209e307cy5yZXBsYWNlKC9cXGIoXFx3Kyk9KFtcXHclK1xcLS46XSspL2csZnVuY3Rpb24oYSxiLGMpe21bYl09Y30pO2JyZWFrfX1sPWQuY2xhc3NOYW1lO2lmKChtIT09a3x8Zi50ZXN0KGwpKSYmIXcudGVzdChsKSl7bj0hMTtmb3Iocz1kLnBhcmVudE5vZGU7cztzPXMucGFyZW50Tm9kZSlpZihnLnRlc3Qocy50YWdOYW1lKSYmcy5jbGFzc05hbWUmJmYudGVzdChzLmNsYXNzTmFtZSkpe249XG4hMDticmVha31pZighbil7ZC5jbGFzc05hbWUrPVwiIHByZXR0eXByaW50ZWRcIjtuPW0ubGFuZztpZighbil7dmFyIG49bC5tYXRjaChxKSxBO2lmKCFuJiYoQT14KGQpKSYmdS50ZXN0KEEudGFnTmFtZSkpbj1BLmNsYXNzTmFtZS5tYXRjaChxKTtuJiYobj1uWzFdKX1pZih5LnRlc3QoZC50YWdOYW1lKSlzPTE7ZWxzZSB2YXIgcz1kLmN1cnJlbnRTdHlsZSx2PWkuZGVmYXVsdFZpZXcscz0ocz1zP3Mud2hpdGVTcGFjZTp2JiZ2LmdldENvbXB1dGVkU3R5bGU/di5nZXRDb21wdXRlZFN0eWxlKGQscikuZ2V0UHJvcGVydHlWYWx1ZShcIndoaXRlLXNwYWNlXCIpOjApJiZcInByZVwiPT09cy5zdWJzdHJpbmcoMCwzKTt2PW0ubGluZW51bXM7aWYoISh2PXY9PT1cInRydWVcInx8K3YpKXY9KHY9bC5tYXRjaCgvXFxibGluZW51bXNcXGIoPzo6KFxcZCspKT8vKSk/dlsxXSYmdlsxXS5sZW5ndGg/K3ZbMV06ITA6ITE7diYmeihkLHYscyk7dD17aDpuLGM6ZCxqOnYsaTpzfTtEKHQpfX19cDxqLmxlbmd0aD9cblAoZSwyNTApOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiZhKCl9Zm9yKHZhciBiPWR8fGRvY3VtZW50LmJvZHksaT1iLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50LGI9W2IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwcmVcIiksYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvZGVcIiksYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInhtcFwiKV0saj1bXSxtPTA7bTxiLmxlbmd0aDsrK20pZm9yKHZhciBsPTAsbj1iW21dLmxlbmd0aDtsPG47KytsKWoucHVzaChiW21dW2xdKTt2YXIgYj1yLGM9RGF0ZTtjLm5vd3x8KGM9e25vdzpmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX19KTt2YXIgcD0wLHQscT0vXFxibGFuZyg/OnVhZ2UpPy0oW1xcdy5dKykoPyFcXFMpLyxmPS9cXGJwcmV0dHlwcmludFxcYi8sdz0vXFxicHJldHR5cHJpbnRlZFxcYi8seT0vcHJlfHhtcC9pLHU9L15jb2RlJC9pLGc9L14oPzpwcmV8Y29kZXx4bXApJC9pLGs9e307ZSgpfX07dHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmXG5kZWZpbmUoXCJnb29nbGUtY29kZS1wcmV0dGlmeVwiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KX0pKCk7cmV0dXJuIGV9KCk7Unx8UChRLDApfSkoKTt9KClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///966\n')}},__webpack_module_cache__={};function __webpack_require__(I){var g=__webpack_module_cache__[I];if(void 0!==g)return g.exports;var C=__webpack_module_cache__[I]={exports:{}};return __webpack_modules__[I](C,C.exports,__webpack_require__),C.exports}__webpack_require__.d=(I,g)=>{for(var C in g)__webpack_require__.o(g,C)&&!__webpack_require__.o(I,C)&&Object.defineProperty(I,C,{enumerable:!0,get:g[C]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(I){if("object"==typeof window)return window}}(),__webpack_require__.o=(I,g)=>Object.prototype.hasOwnProperty.call(I,g),__webpack_require__.r=I=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},(()=>{var I;__webpack_require__.g.importScripts&&(I=__webpack_require__.g.location+"");var g=__webpack_require__.g.document;if(!I&&g&&(g.currentScript&&"SCRIPT"===g.currentScript.tagName.toUpperCase()&&(I=g.currentScript.src),!I)){var C=g.getElementsByTagName("script");if(C.length)for(var t=C.length-1;t>-1&&(!I||!/^http(s?):/.test(I));)I=C[t--].src}if(!I)throw new Error("Automatic publicPath is not supported in this browser");I=I.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=I+"../"})();var __webpack_exports__=__webpack_require__(741),__webpack_export_target__=window;for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__]=__webpack_exports__[__webpack_i__];__webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,"__esModule",{value:!0})})();